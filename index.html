<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multidimensional Data Linearization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segue UI', Roboto, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            min-width: 320px;
            padding: 15px;
            color: #eee;
        }

        .container {
            margin: 0 auto;
        }

        .content-wrapper {
            max-width: 1600px;
            min-width: 320px;
            margin: 0 auto;
        }

        h1 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 2em;
            text-align: center;
        }

        .subtitle {
            color: #aaa;
            margin-bottom: 15px;
            text-align: center;
        }

        .section-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }


        .section-container h2 {
            color: #fff;
            font-size: 1.3em;
            margin: 0 0 15px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .simulation-wrapper {
            padding: 15px 15px 15px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .simulation-wrapper > h2 {
            color: #fff;
            font-size: 1.8em;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            grid-template-rows: auto 1fr; /* Header row + content row */
            gap: 15px;
            margin-bottom: 15px;
        }

        .control-section {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Removed problematic subgrid rules that were causing dropdown stacking */

        .section-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 5px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 500;
            color: #bbb;
            margin-bottom: 5px;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="number"], select {
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transition: all 0.3s;
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #4a9eff;
            background: rgba(255, 255, 255, 0.15);
        }

        select option {
            background: #2a2a3e;
            color: #fff;
        }

        .query-controls {
            background: rgba(255, 200, 0, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 200, 0, 0.3);
        }

        .query-title {
            font-weight: 600;
            color: #ffc107;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        .range-inputs {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .range-group {
            display: flex;
            gap: 15px;
            align-items: center;
            color: #ddd;
        }

        .range-group input {
            width: 60px;
        }

        .spatial-views {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            .spatial-views {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        .viz-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            max-width: 100%;
            cursor: crosshair;
            margin: 0 auto;
        }

        .linear-views {
            margin-bottom: 15px;
        }

        .linear-viz {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            grid-template-rows: auto auto; /* Label row + value row, both natural size */
            gap: 5px 15px; /* row-gap column-gap - tight gap between label/value, normal gap between metrics */
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
        }

        @media (min-width: 1200px) {
            .metrics {
                grid-template-columns: repeat(8, 1fr);
            }
        }

        @media (max-width: 1199px) and (min-width: 800px) {
            .metrics {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 799px) and (min-width: 400px) {
            .metrics {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 399px) {
            .metrics {
                grid-template-columns: 1fr;
            }
        }

        .metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            backdrop-filter: blur(10px);
            display: grid;
            grid-template-rows: subgrid; /* Align with parent grid rows */
            grid-row: span 2; /* Span both label and value rows */
        }

        /* Fallback for browsers without subgrid support */
        @supports not (grid-template-rows: subgrid) {
            .metric {
                display: block;
                grid-row: auto;
            }
        }

        .metric-label {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #fff;
        }

        .metric-suffix {
            font-size: 0.5em;
            color: rgba(255, 255, 255, 0.7);
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .explanation {
            margin: 40px auto 0 auto;
            padding: 15px 15px 15px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .explanation h2 {
            color: #fff;
            font-size: 1.8em;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .explanation-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        @media (min-width: 1200px) {
            .explanation-content {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .explanation-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .explanation-section h3 {
            color: #4a9eff;
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .explanation-section p {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .explanation-section ul {
            color: #ccc;
            margin-left: 15px;
            line-height: 1.6;
        }

        .explanation-section li {
            margin-bottom: 8px;
        }

        .color-example {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
            vertical-align: middle;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .highlight-blue {
            background: rgba(74, 158, 255, 0.7);
        }

        .highlight-white {
            background: rgba(255, 255, 255, 0.4);
        }

        .gradient-example {
            background: linear-gradient(90deg, #00ff00, #ff0000);
        }

        /* Hide Z dimension controls for now */
        .z-control {
            display: none !important;
            /*display: flex !important;*/
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #aaa;
            font-size: 0.9em;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .reset-button {
            display: block;
            margin: 0 auto;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            width: fit-content;
        }

        .reset-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #4a9eff;
        }

        .github-link-container {
            text-align: center;
            margin: 10px 0;
        }

        .github-link {
            color: #4a9eff;
            text-decoration: none;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .preset-controls {
            display: flex;
            align-items: flex-end;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .preset-controls .control-group {
            flex: 1;
            min-width: 180px;
        }

        .preset-controls .reset-button {
            margin: 0;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .gradient-legend {
            background: linear-gradient(90deg, #00ff00, #ff0000);
        }

        .query-legend {
            border: 3px solid #4a9eff;
            background: transparent;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Multidimensional Data Linearization Visualizer</h1>
        <p class="subtitle">Explore how chunking and linearization strategies affect read patterns</p>

        <div class="github-link-container">
            <a href="https://github.com/jkeifer/vischunk" target="_blank" class="github-link">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
                View on GitHub
            </a>
        </div>

        <div class="content-wrapper simulation-wrapper">
            <h2>Interactive Simulation</h2>

            <div class="section-container">
                <h2>Simulation Controls</h2>

                <div class="preset-controls">
                    <div class="control-group">
                        <label for="presets">Scenario Presets</label>
                        <select id="presets">
                            <option value="user">User Settings</option>
                        </select>
                    </div>
                    <button class="reset-button" id="resetButton">reset to default</button>
                </div>

            <div class="controls">
                <div class="control-section">
                <div class="section-title">Array Settings</div>
                <div class="control-group">
                    <label for="sizeX">Array Size X</label>
                    <input type="number" id="sizeX" min="1" max="64" value="16">
                </div>

                <div class="control-group">
                    <label for="sizeY">Array Size Y</label>
                    <input type="number" id="sizeY" min="1" max="64" value="16">
                </div>

                <div class="control-group z-control" id="arraySizeZGroup">
                    <label for="sizeZ">Array Size Z</label>
                    <input type="number" id="sizeZ" min="1" max="16" value="1">
                </div>


                <div class="control-group">
                    <label for="cellAlgorithm">Cell Linearization (within chunk)</label>
                    <select id="cellAlgorithm">
                        <option value="row-major">Row-Major</option>
                        <option value="col-major">Column-Major</option>
                        <option value="z-order">Z-Order (Morton)</option>
                        <option value="hilbert">Hilbert Curve</option>
                    </select>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Chunk Settings</div>
                <div class="control-group">
                    <label for="chunkX">Chunk Size X</label>
                    <input type="number" id="chunkX" min="1" max="64" value="4">
                </div>

                <div class="control-group">
                    <label for="chunkY">Chunk Size Y</label>
                    <input type="number" id="chunkY" min="1" max="64" value="4">
                </div>

                <div class="control-group z-control" id="chunkZGroup">
                    <label for="chunkZ">Chunk Size Z</label>
                    <input type="number" id="chunkZ" min="1" max="16" value="1">
                </div>

                <div class="control-group">
                    <label for="chunkAlgorithm">Chunk Linearization</label>
                    <select id="chunkAlgorithm">
                        <option value="row-major">Row-Major</option>
                        <option value="col-major">Column-Major</option>
                        <option value="z-order">Z-Order (Morton)</option>
                        <option value="hilbert">Hilbert Curve</option>
                    </select>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Query Region</div>
                <div class="range-group">
                    <label for="queryX1">X:</label>
                    <input type="number" id="queryX1" min="0" value="3">
                    <span>to</span>
                    <input type="number" id="queryX2" min="0" value="10">
                </div>
                <div class="range-group">
                    <label for="queryY1">Y:</label>
                    <input type="number" id="queryY1" min="0" value="3">
                    <span>to</span>
                    <input type="number" id="queryY2" min="0" value="10">
                </div>
                <div class="range-group z-control" id="zRange">
                    <label for="queryZ1">Z:</label>
                    <input type="number" id="queryZ1" min="0" value="0">
                    <span>to</span>
                    <input type="number" id="queryZ2" min="0" value="0">
                </div>
            </div>
        </div>

    </div>

    <div class="section-container">
        <h2>Performance Metrics</h2>
        <div class="metrics">
            <div class="metric">
                <div class="metric-label">Requested Cells</div>
                <div class="metric-value" id="requested-cells">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Cells Read</div>
                <div class="metric-value" id="actual-cells">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Read Amplification</div>
                <div class="metric-value" id="amplification">1.0<span class="metric-suffix">x</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Read Efficiency</div>
                <div class="metric-value" id="efficiency">100<span class="metric-suffix">%</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Chunks Touched</div>
                <div class="metric-value" id="chunks-touched">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Range Reads</div>
                <div class="metric-value" id="byte-ranges">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Coalescing Factor</div>
                <div class="metric-value" id="coalescing-factor">1.0<span class="metric-suffix">x</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Storage Alignment</div>
                <div class="metric-value" id="storage-alignment">1.0</div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>Simulation Visualizations</h2>
        <div class="spatial-views">
            <div class="viz-panel">
                <div class="viz-title">Array Cells</div>
                <div class="canvas-container">
                    <canvas id="spatial-unchunked"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color gradient-legend"></div>
                        <span>Linearization Order</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color query-legend"></div>
                        <span>Query Region</span>
                    </div>
                </div>
            </div>

            <div class="viz-panel">
                <div class="viz-title">Array Chunks</div>
                <div class="canvas-container">
                    <canvas id="spatial-chunked"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color gradient-legend"></div>
                        <span>Linearization Order</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color query-legend"></div>
                        <span>Chunks to Read</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="linear-views">
            <div class="linear-viz">
                <div class="viz-title">Storage Linearization — Cells</div>
                <div class="canvas-container">
                    <canvas id="linear-unchunked"></canvas>
                </div>
            </div>

            <div class="linear-viz">
                <div class="viz-title">Storage Linearization — Chunks</div>
                <div class="canvas-container">
                    <canvas id="linear-chunked"></canvas>
                </div>
            </div>
        </div>
    </div>
        </div>

    <div class="tooltip" id="tooltip"></div>

    <div class="content-wrapper explanation">
        <h2>How to Interpret the Visualizations</h2>

        <div class="explanation-content">
            <div class="explanation-section">
                <h3>Color Coding</h3>
                <p><span class="color-example gradient-example"></span><strong>Green to Red Gradient:</strong> Shows the linearization order from first (green) to last (red) in memory. This helps you understand how different algorithms arrange data sequentially.</p>

                <p><span class="color-example highlight-blue"></span><strong>Blue Highlights:</strong> Indicate query regions and all cells that need to be read to satisfy the query. This includes both requested cells and extra cells read due to chunking.</p>

                <p><span class="color-example highlight-white"></span><strong>White Overlays:</strong> Show currently hovered elements. Direct hovers have both overlay and outline, while cross-highlighted elements show only the overlay.</p>
            </div>

            <div class="explanation-section">
                <h3>Array Views (Top Row)</h3>
                <p><strong>Left - Logical Array:</strong> Shows how individual cells are organized and linearized within chunks. Each cell's color represents its position in the combined linearization order.</p>

                <p><strong>Right - Chunked Array:</strong> Displays chunk-level organization where all cells in the same chunk share the same color. This shows how chunks are linearized relative to each other.</p>

                <p><strong>Interactive Cross-highlighting:</strong> Hovering in one view highlights corresponding elements in all other views, helping you trace relationships between logical and physical layouts.</p>
            </div>

            <div class="explanation-section">
                <h3>Linear Storage Views (Bottom Row)</h3>
                <p><strong>Top Linear View:</strong> Shows how data is actually stored in linear memory, with the same cell-level coloring as the logical array. Blue regions indicate cells that need to be read.</p>

                <p><strong>Bottom Linear View:</strong> Same linear layout but colored by chunks to show how chunking affects the distribution of read operations. Blue bars below show the byte ranges that need to be fetched.</p>

                <p><strong>Byte Range Indicators:</strong> Lines below each linear view show how many separate read operations are required - fewer ranges mean better I/O performance.</p>
            </div>

            <div class="explanation-section">
                <h3>Performance Metrics</h3>
                <p><strong>Requested Cells:</strong> The number of cells in your query region that you actually want to read.</p>

                <p><strong>Actual Cells Read:</strong> The total number of cells that must be read due to chunking, including both requested and extra cells.</p>

                <p><strong>Read Amplification:</strong> Shows how much extra data you read due to chunking. Values > 1.0 indicate wasted bandwidth. Lower is better.</p>

                <p><strong>Read Efficiency:</strong> Percentage of useful data in each read operation. Higher percentages indicate better performance with less wasted I/O.</p>

                <p><strong>Chunks Touched:</strong> How many chunks intersect with your query region. Fewer chunks generally mean more efficient access patterns.</p>

                <p><strong>Range Reads:</strong> Number of separate read operations needed. Fewer range reads reduce I/O overhead and improve performance.</p>

                <p><strong>Coalescing Factor:</strong> Shows how much read coalescing improves I/O efficiency compared to worst-case (chunks touched ÷ range reads). Values > 1.0 indicate that multiple chunks are being read in fewer operations due to spatial locality.</p>
                <p><strong>Storage Alignment:</strong> Overall measure of how well your query aligns with the storage layout, combining read efficiency and coalescing. Higher values indicate better alignment between your access pattern and chunking strategy.</p>
            </div>

            <div class="explanation-section">
                <h3>Algorithm Comparison</h3>
                <p><strong>Row-Major:</strong> Best for queries that access consecutive rows. Common in C/C++ and most programming languages.</p>

                <p><strong>Column-Major:</strong> Optimal for column-wise access patterns. Used in Fortran, R, and some scientific computing applications.</p>

                <p><strong>Z-Order (Morton):</strong> Space-filling curve that preserves spatial locality well. Good for 2D range queries and spatial databases.</p>

                <p><strong>Hilbert Curve:</strong> Optimal space-filling curve with the best spatial locality preservation. Excellent for 2D spatial queries but more complex to compute.</p>
            </div>

            <div class="explanation-section">
                <h3>Optimization Tips</h3>
                <p><strong>Match Access Patterns:</strong> Choose linearization algorithms that align with how your application accesses data most frequently.</p>

                <p><strong>Chunk Size Balance:</strong> Larger chunks reduce metadata overhead but may increase read amplification. Smaller chunks provide finer granularity but more management overhead.</p>

                <p><strong>Query Shape Matters:</strong> Square queries often work best with space-filling curves, while rectangular queries may favor row/column-major ordering.</p>

                <p><strong>Monitor Metrics:</strong> Use the real-time metrics to compare different configurations and find the optimal balance for your specific use case.</p>
            </div>
        </div>
    </div>

    <script>
        // Configuration constants
        const CONFIG = {
            MAX_CANVAS_SIZE: 400,      // Maximum canvas size in pixels
            MIN_CELL_SIZE: 2,          // Minimum cell size for drawing details
            VIEWPORT_CELL_SIZE: 8,     // Cell size threshold for viewport rendering
            LRU_CONFIG_CACHE_SIZE: 50, // Max number of recent configurations to cache (for chunk/cell mappings)
            LRU_DETAIL_CACHE_SIZE: 20000, // Max number of recent detail items to cache (colors, coordinates)
            RESIZE_DEBOUNCE_MS: 150    // Debounce timeout for resize events
        };

        class LRUCache {
            constructor(maxSize) {
                this.maxSize = maxSize;
                this.cache = new Map();
            }

            get(key) {
                const item = this.cache.get(key);
                if (item) {
                    // Refresh it by deleting and re-setting
                    this.cache.delete(key);
                    this.cache.set(key, item);
                }
                return item;
            }

            set(key, value) {
                // Delete old entry if it exists to refresh its position
                if (this.cache.has(key)) {
                    this.cache.delete(key);
                }
                // If the cache is full, evict the least recently used item
                else if (this.cache.size >= this.maxSize && this.maxSize > 0) {
                    // .keys().next().value gets the first (oldest) key in the Map
                    this.cache.delete(this.cache.keys().next().value);
                }
                this.cache.set(key, value);
            }

            has(key) {
                return this.cache.has(key);
            }

            clear() {
                this.cache.clear();
            }
        }

        class CacheKeyGenerator {
            static createLinearizationKey(x, y, z, sizeX, sizeY, sizeZ, algorithm) {
                return `${x},${y},${z},${sizeX},${sizeY},${sizeZ},${algorithm}`;
            }

            static createCellPositionKey(algorithm, chunkX, chunkY, chunkZ) {
                return `cell-${algorithm}-${chunkX}-${chunkY}-${chunkZ}`;
            }

            static createChunkPositionKey(algorithm, chunksX, chunksY) {
                return `${algorithm}-${chunksX}-${chunksY}`;
            }

            static createChunkColorMapKey(chunksX, chunksY, chunksZ, algorithm) {
                return `${chunksX},${chunksY},${chunksZ},${algorithm}`;
            }

            static createPositionToCellMapKey(sizeX, sizeY, cellAlgorithm, chunkAlgorithm, chunkSizeX, chunkSizeY) {
                return `${sizeX},${sizeY},${cellAlgorithm},${chunkAlgorithm},${chunkSizeX},${chunkSizeY}`;
            }

            static createColorKey(position, maxPosition) {
                return `${position}-${maxPosition}`;
            }
        }

        class ChunkCoordinateManager {
            constructor(chunkPositionCache) {
                this.chunkPositionCache = chunkPositionCache;
            }

            getChunkCoordinatesFromSequentialIndex(sequentialIndex, params) {
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);

                if (params.chunkAlgorithm === 'z-order' || params.chunkAlgorithm === 'hilbert') {
                    return this.getNonSequentialChunkCoordinates(sequentialIndex, params, chunksX, chunksY);
                } else if (params.chunkAlgorithm === 'col-major') {
                    return {
                        cx: Math.floor(sequentialIndex / chunksY),
                        cy: sequentialIndex % chunksY
                    };
                } else {
                    // Row-major (default)
                    return {
                        cy: Math.floor(sequentialIndex / chunksX),
                        cx: sequentialIndex % chunksX
                    };
                }
            }

            getNonSequentialChunkCoordinates(sequentialIndex, params, chunksX, chunksY) {
                const cacheKey = CacheKeyGenerator.createChunkPositionKey(params.chunkAlgorithm, chunksX, chunksY);
                const coordCacheKey = cacheKey + '-coords';

                const coordMap = this.chunkPositionCache.get(coordCacheKey);
                if (!coordMap || !coordMap.has(sequentialIndex)) {
                    throw new Error(`Coordinate mapping not found for sequential position ${sequentialIndex} in algorithm ${params.chunkAlgorithm}`);
                }
                return coordMap.get(sequentialIndex);
            }

            calculateActualCellsInChunk(chunkCX, chunkCY, params) {
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY] = params.chunk;

                const startX = chunkCX * chunkX;
                const startY = chunkCY * chunkY;
                const endX = Math.min(startX + chunkX, sizeX);
                const endY = Math.min(startY + chunkY, sizeY);
                
                return (endX - startX) * (endY - startY);
            }
        }

        class LinearizationEngine {
            constructor(linearizationCache, positionCache, chunkPositionCache, cellPositionCache) {
                this.linearizationCache = linearizationCache;
                this.positionCache = positionCache;
                this.chunkPositionCache = chunkPositionCache;
                this.cellPositionCache = cellPositionCache;
                this.chunkCoordManager = new ChunkCoordinateManager(chunkPositionCache);
            }

            linearizeCoordinate(x, y, z, sizeX, sizeY, sizeZ, algorithm) {
                const key = CacheKeyGenerator.createLinearizationKey(x, y, z, sizeX, sizeY, sizeZ, algorithm);
                if (this.linearizationCache.has(key)) {
                    return this.linearizationCache.get(key);
                }

                let result = this.calculateLinearPosition(x, y, z, sizeX, sizeY, sizeZ, algorithm);
                this.linearizationCache.set(key, result);
                return result;
            }

            calculateLinearPosition(x, y, z, sizeX, sizeY, sizeZ, algorithm) {
                switch(algorithm) {
                    case 'row-major':
                        return x + y * sizeX + z * sizeX * sizeY;
                    case 'col-major':
                        return y + x * sizeY + z * sizeX * sizeY;
                    case 'z-order':
                        return sizeZ > 0 ? this.mortonEncode3D(x, y, z) : this.mortonEncode2D(x, y);
                    case 'hilbert':
                        if (sizeZ > 0) {
                            return z * sizeX * sizeY + this.hilbertEncode2D(x, y, Math.max(sizeX, sizeY));
                        } else {
                            return this.hilbertEncode2D(x, y, Math.max(sizeX, sizeY));
                        }
                    default:
                        return x + y * sizeX + z * sizeX * sizeY;
                }
            }

            getIntraChunkPosition(x, y, z, params) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const localX = x % chunkX;
                const localY = y % chunkY;
                const localZ = z % chunkZ;
                const rawPos = this.linearizeCoordinate(localX, localY, localZ, chunkX, chunkY, chunkZ, params.cellAlgorithm);

                if (params.cellAlgorithm === 'z-order' || params.cellAlgorithm === 'hilbert') {
                    return this.getNormalizedCellPosition(rawPos, params, chunkX, chunkY, chunkZ);
                }

                return rawPos;
            }

            getNormalizedCellPosition(rawPos, params, chunkX, chunkY, chunkZ) {
                const cacheKey = CacheKeyGenerator.createCellPositionKey(params.cellAlgorithm, chunkX, chunkY, chunkZ);

                if (!this.cellPositionCache.has(cacheKey)) {
                    this.buildCellPositionCache(cacheKey, params, chunkX, chunkY, chunkZ);
                }

                const positionMap = this.cellPositionCache.get(cacheKey);
                if (!positionMap || !positionMap.has(rawPos)) {
                    throw new Error(`Cell position ${rawPos} not found in cache for algorithm ${params.cellAlgorithm}`);
                }
                return positionMap.get(rawPos);
            }

            buildCellPositionCache(cacheKey, params, chunkX, chunkY, chunkZ) {
                const allCellPositions = [];
                for (let cz = 0; cz < Math.max(1, chunkZ); cz++) {
                    for (let cy = 0; cy < chunkY; cy++) {
                        for (let cx = 0; cx < chunkX; cx++) {
                            const pos = this.linearizeCoordinate(cx, cy, cz, chunkX, chunkY, chunkZ, params.cellAlgorithm);
                            allCellPositions.push(pos);
                        }
                    }
                }
                allCellPositions.sort((a, b) => a - b);

                const positionMap = new Map();
                allCellPositions.forEach((pos, seqIndex) => {
                    positionMap.set(pos, seqIndex);
                });
                this.cellPositionCache.set(cacheKey, positionMap);
            }

            getInterChunkPosition(x, y, z, params) {
                const [sizeX, sizeY, sizeZ] = params.size;
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const chunksZ = Math.ceil(sizeZ / chunkZ);
                const chunkCX = Math.floor(x / chunkX);
                const chunkCY = Math.floor(y / chunkY);
                const chunkCZ = Math.floor(z / chunkZ);
                return this.linearizeCoordinate(chunkCX, chunkCY, chunkCZ, chunksX, chunksY, chunksZ, params.chunkAlgorithm);
            }

            getNormalizedChunkPosition(x, y, z, params) {
                const rawChunkPos = this.getInterChunkPosition(x, y, z, params);

                if (params.chunkAlgorithm === 'z-order' || params.chunkAlgorithm === 'hilbert') {
                    return this.getNormalizedNonSequentialChunkPosition(rawChunkPos, params);
                }

                return rawChunkPos;
            }

            getNormalizedNonSequentialChunkPosition(rawChunkPos, params) {
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);

                const cacheKey = CacheKeyGenerator.createChunkPositionKey(params.chunkAlgorithm, chunksX, chunksY);

                if (!this.chunkPositionCache.has(cacheKey)) {
                    this.buildChunkPositionCache(cacheKey, params, chunksX, chunksY, chunkX, chunkY);
                }

                const positionMap = this.chunkPositionCache.get(cacheKey);
                if (!positionMap || !positionMap.has(rawChunkPos)) {
                    throw new Error(`Chunk position ${rawChunkPos} not found in cache for algorithm ${params.chunkAlgorithm}`);
                }
                return positionMap.get(rawChunkPos);
            }

            buildChunkPositionCache(cacheKey, params, chunksX, chunksY, chunkX, chunkY) {
                const allChunkPositions = [];
                for (let cy = 0; cy < chunksY; cy++) {
                    for (let cx = 0; cx < chunksX; cx++) {
                        const tempX = cx * chunkX;
                        const tempY = cy * chunkY;
                        const pos = this.getInterChunkPosition(tempX, tempY, 0, params);
                        allChunkPositions.push({pos, index: cy * chunksX + cx, cx, cy});
                    }
                }
                allChunkPositions.sort((a, b) => a.pos - b.pos);

                const positionMap = new Map();
                const coordMap = new Map();
                allChunkPositions.forEach((item, seqIndex) => {
                    positionMap.set(item.pos, seqIndex);
                    coordMap.set(seqIndex, {cx: item.cx, cy: item.cy});
                });
                this.chunkPositionCache.set(cacheKey, positionMap);
                this.chunkPositionCache.set(cacheKey + '-coords', coordMap);
            }

            getGlobalPosition(x, y, z, params) {
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY, chunkZ] = params.chunk;

                const normalizedChunkPos = this.getNormalizedChunkPosition(x, y, z, params);
                const cellsBeforeThisChunk = this.calculateCellsBeforeChunk(normalizedChunkPos, params);
                const intraChunkPos = this.getIntraChunkPosition(x, y, z, params);
                
                return cellsBeforeThisChunk + intraChunkPos;
            }

            calculateCellsBeforeChunk(normalizedChunkPos, params) {
                let cellsBeforeThisChunk = 0;
                for (let i = 0; i < normalizedChunkPos; i++) {
                    const chunkCoords = this.chunkCoordManager.getChunkCoordinatesFromSequentialIndex(i, params);
                    const actualCellsInChunk = this.chunkCoordManager.calculateActualCellsInChunk(chunkCoords.cx, chunkCoords.cy, params);
                    cellsBeforeThisChunk += actualCellsInChunk;
                }
                return cellsBeforeThisChunk;
            }

            mortonEncode2D(x, y) {
                let result = 0;
                for (let i = 0; i < 16; i++) {
                    result |= ((x & (1 << i)) << i) | ((y & (1 << i)) << (i + 1));
                }
                return result;
            }

            mortonEncode3D(x, y, z) {
                let result = 0;
                for (let i = 0; i < 10; i++) {
                    result |= ((x & (1 << i)) << (2 * i)) |
                              ((y & (1 << i)) << (2 * i + 1)) |
                              ((z & (1 << i)) << (2 * i + 2));
                }
                return result;
            }

            nextPowerOfTwo(n) {
                if (n <= 1) return 1;
                return Math.pow(2, Math.ceil(Math.log2(n)));
            }

            hilbertEncode2D(x, y, maxDim) {
                const n = this.nextPowerOfTwo(maxDim);

                let d = 0;
                for (let s = n / 2; s > 0; s /= 2) {
                    let rx = (x & s) > 0 ? 1 : 0;
                    let ry = (y & s) > 0 ? 1 : 0;
                    d += s * s * ((3 * rx) ^ ry);
                    [x, y] = this.hilbertRotate(s, x, y, rx, ry);
                }
                return d;
            }

            hilbertRotate(n, x, y, rx, ry) {
                if (ry === 0) {
                    if (rx === 1) {
                        x = n - 1 - x;
                        y = n - 1 - y;
                    }
                    [x, y] = [y, x];
                }
                return [x, y];
            }
        }

        const PRESET_CONFIGS = {
            'small-tiles': {
                name: 'Small Tiles vs Large Query',
                cellAlgorithm: 'row-major',
                chunkAlgorithm: 'row-major',
                sizeX: 32, sizeY: 32, sizeZ: 1,
                chunkX: 2, chunkY: 2, chunkZ: 1,
                queryX1: 8, queryX2: 24, queryY1: 8, queryY2: 24,
                queryZ1: 0, queryZ2: 0
            },
            'large-tiles': {
                name: 'Large Tiles vs Small Query',
                cellAlgorithm: 'row-major',
                chunkAlgorithm: 'row-major',
                sizeX: 32, sizeY: 32, sizeZ: 1,
                chunkX: 16, chunkY: 16, chunkZ: 1,
                queryX1: 10, queryX2: 14, queryY1: 10, queryY2: 14,
                queryZ1: 0, queryZ2: 0
            },
            'row-vs-col': {
                name: 'Row-Major vs Column-Major',
                cellAlgorithm: 'col-major',
                chunkAlgorithm: 'row-major',
                sizeX: 16, sizeY: 16, sizeZ: 1,
                chunkX: 4, chunkY: 8, chunkZ: 1,
                queryX1: 2, queryX2: 6, queryY1: 4, queryY2: 12,
                queryZ1: 0, queryZ2: 0
            },
            'spatial-locality': {
                name: 'Spatial Locality Comparison',
                cellAlgorithm: 'hilbert',
                chunkAlgorithm: 'hilbert',
                sizeX: 16, sizeY: 16, sizeZ: 1,
                chunkX: 4, chunkY: 4, chunkZ: 1,
                queryX1: 6, queryX2: 9, queryY1: 6, queryY2: 9,
                queryZ1: 0, queryZ2: 0
            },
            'fragmentation': {
                name: 'High Fragmentation Scenario',
                cellAlgorithm: 'z-order',
                chunkAlgorithm: 'col-major',
                sizeX: 20, sizeY: 20, sizeZ: 1,
                chunkX: 3, chunkY: 3, chunkZ: 1,
                queryX1: 1, queryX2: 18, queryY1: 5, queryY2: 7,
                queryZ1: 0, queryZ2: 0
            },
            'perfect-alignment': {
                name: 'Perfect Chunk Alignment',
                cellAlgorithm: 'row-major',
                chunkAlgorithm: 'row-major',
                sizeX: 16, sizeY: 16, sizeZ: 1,
                chunkX: 4, chunkY: 4, chunkZ: 1,
                queryX1: 4, queryX2: 7, queryY1: 4, queryY2: 7,
                queryZ1: 0, queryZ2: 0
            }
        };

        const DEFAULT_USER_SETTINGS = {
            cellAlgorithm: 'row-major',
            chunkAlgorithm: 'row-major',
            sizeX: 16,
            sizeY: 16,
            sizeZ: 1,
            chunkX: 4,
            chunkY: 4,
            chunkZ: 1,
            queryX1: 3,
            queryX2: 10,
            queryY1: 3,
            queryY2: 10,
            queryZ1: 0,
            queryZ2: 0
        };

        const DEFAULT_APP_STATE = {
            currentPreset: 'user',
            presets: {
                user: DEFAULT_USER_SETTINGS
                // Other preset states get copied here as user modifies them
            }
        };

        class TooltipManager {
            constructor(tooltipElement) {
                this.tooltip = tooltipElement;
            }

            show(e, content) {
                this.tooltip.style.display = 'block';
                this.tooltip.style.position = 'absolute';
                this.tooltip.style.left = `${e.clientX + window.scrollX + 10}px`;
                this.tooltip.style.top = `${e.clientY + window.scrollY - 30}px`;
                this.tooltip.style.transform = 'none';
                this.tooltip.style.margin = '0';
                this.tooltip.textContent = content;
            }

            hide() {
                this.tooltip.style.display = 'none';
            }

            updateContent(content) {
                this.tooltip.textContent = content;
            }

            updatePosition(e) {
                if (this.tooltip.style.display === 'block') {
                    this.tooltip.style.left = `${e.clientX + window.scrollX + 10}px`;
                    this.tooltip.style.top = `${e.clientY + window.scrollY - 30}px`;
                }
            }
        }

        class SelectionState {
            constructor() {
                this.hoveredCell = null;
                this.hoveredChunk = null;
                this.selectedCell = null;
                this.selectedChunk = null;
            }

            setHoveredCell(cell) {
                this.hoveredCell = cell;
            }

            setHoveredChunk(chunk) {
                this.hoveredChunk = chunk;
            }

            setSelectedCell(cell) {
                this.selectedCell = cell;
            }

            setSelectedChunk(chunk) {
                this.selectedChunk = chunk;
            }

            clearHover() {
                this.hoveredCell = null;
                this.hoveredChunk = null;
            }

            clearSelection() {
                this.selectedCell = null;
                this.selectedChunk = null;
            }

            clearAll() {
                this.clearHover();
                this.clearSelection();
            }

            getEffectiveCell() {
                return this.selectedCell || this.hoveredCell;
            }

            getEffectiveChunk() {
                return this.selectedChunk || this.hoveredChunk;
            }

            isSelected(cell, chunk) {
                const sameCell = cell && this.selectedCell &&
                    cell.x === this.selectedCell.x && cell.y === this.selectedCell.y;
                const sameChunk = chunk && this.selectedChunk &&
                    chunk.x === this.selectedChunk.x && chunk.y === this.selectedChunk.y;
                return sameCell || sameChunk;
            }

            hasSelection() {
                return this.selectedCell || this.selectedChunk;
            }
        }

        class CoordinateService {
            constructor() {
                this.cellLayoutCache = new LRUCache(CONFIG.LRU_CONFIG_CACHE_SIZE);
                this.linearLayoutCache = new LRUCache(CONFIG.LRU_CONFIG_CACHE_SIZE);
            }

            getCanvasCoordinates(e, canvas) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

            getSpatialCellLayout(canvas, sizeX, sizeY) {
                const dpr = window.devicePixelRatio || 1;
                const cacheKey = `${canvas.width}x${canvas.height}_${sizeX}x${sizeY}_${dpr}`;
                if (this.cellLayoutCache.has(cacheKey)) {
                    return this.cellLayoutCache.get(cacheKey);
                }

                const logicalWidth = canvas.width / dpr;
                const logicalHeight = canvas.height / dpr;
                const cellSize = Math.min(logicalWidth / sizeX, logicalHeight / sizeY) * 0.9;
                const offsetX = (logicalWidth - sizeX * cellSize) / 2;
                const offsetY = (logicalHeight - sizeY * cellSize) / 2;

                const layout = { cellSize, offsetX, offsetY };
                this.cellLayoutCache.set(cacheKey, layout);
                return layout;
            }

            getSpatialCellCoordinates(canvasX, canvasY, canvas, params) {
                const [sizeX, sizeY] = params.size;
                
                // Convert canvas coordinates to logical coordinates
                const dpr = window.devicePixelRatio || 1;
                const logicalX = canvasX / dpr;
                const logicalY = canvasY / dpr;
                
                const { cellSize, offsetX, offsetY } = this.getSpatialCellLayout(canvas, sizeX, sizeY);
                
                const cellX = Math.floor((logicalX - offsetX) / cellSize);
                const cellY = Math.floor((logicalY - offsetY) / cellSize);
                
                return {
                    cellX,
                    cellY,
                    isValid: cellX >= 0 && cellX < sizeX && cellY >= 0 && cellY < sizeY,
                    layout: { cellSize, offsetX, offsetY }
                };
            }

            getLinearBarLayout(canvas, totalCells) {
                const dpr = window.devicePixelRatio || 1;
                const cacheKey = `linear_${canvas.width}x${canvas.height}_${totalCells}_${dpr}`;
                if (this.linearLayoutCache.has(cacheKey)) {
                    return this.linearLayoutCache.get(cacheKey);
                }

                const logicalWidth = canvas.width / dpr;
                const cellWidth = (logicalWidth - 40) / totalCells;
                const barHeight = 60;
                const offsetX = 20;
                const offsetY = 20;

                const layout = { cellWidth, barHeight, offsetX, offsetY };
                this.linearLayoutCache.set(cacheKey, layout);
                return layout;
            }

            getLinearCellCoordinates(canvasX, canvasY, canvas, data) {
                const { cellWidth, barHeight, offsetX, offsetY } = this.getLinearBarLayout(canvas, data.totalCells);
                
                const dpr = window.devicePixelRatio || 1;
                const logicalX = canvasX / dpr;
                const logicalY = canvasY / dpr;
                
                const isInBar = logicalY >= offsetY && logicalY <= offsetY + barHeight;
                const cellIndex = Math.floor((logicalX - offsetX) / cellWidth);
                const isValidIndex = cellIndex >= 0 && cellIndex < data.totalCells;
                
                return {
                    cellIndex,
                    isValid: isInBar && isValidIndex,
                    layout: { cellWidth, barHeight, offsetX, offsetY }
                };
            }

            getChunkBounds(chunkCX, chunkCY, chunkX, chunkY, sizeX, sizeY) {
                const startX = chunkCX * chunkX;
                const startY = chunkCY * chunkY;
                const endX = Math.min(startX + chunkX, sizeX);
                const endY = Math.min(startY + chunkY, sizeY);
                return { startX, startY, endX, endY };
            }

            getChunkCoordinatesFromCell(cellX, cellY, chunkX, chunkY) {
                return {
                    x: Math.floor(cellX / chunkX),
                    y: Math.floor(cellY / chunkY)
                };
            }

            clearCache() {
                this.cellLayoutCache.clear();
                this.linearLayoutCache.clear();
            }
        }


        class TooltipContentGenerator {
            static generateCellTooltip(cell, params, visualizer) {
                const intraChunkPos = visualizer.getIntraChunkPosition(cell.x, cell.y, 0, params);
                const globalPos = visualizer.getGlobalPosition(cell.x, cell.y, 0, params);
                return `Cell (${cell.x}, ${cell.y}) → Intra-chunk: ${intraChunkPos}, Global: ${globalPos}`;
            }

            static generateChunkTooltip(chunk, params, sizeX, sizeY, chunkX, chunkY, visualizer) {
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunkIdx = chunk.x + chunk.y * chunksX;
                const bounds = visualizer.coordinateService.getChunkBounds(chunk.x, chunk.y, chunkX, chunkY, sizeX, sizeY);
                const interChunkPos = visualizer.getInterChunkPosition(bounds.startX, bounds.startY, 0, params);
                
                return `Chunk ${chunkIdx}: cells (${bounds.startX},${bounds.startY}) to (${bounds.endX - 1},${bounds.endY - 1}), Linear pos: ${interChunkPos}`;
            }
        }

        class BaseCanvasRenderer {
            constructor(canvas, context, visualizer, coordinateService) {
                this.canvas = canvas;
                this.ctx = context;
                this.visualizer = visualizer;
                this.coordinateService = coordinateService;
            }

            getLogicalDimensions() {
                return {
                    width: this.canvas.width / (window.devicePixelRatio || 1),
                    height: this.canvas.height / (window.devicePixelRatio || 1)
                };
            }

            clearCanvas() {
                const { width, height } = this.getLogicalDimensions();
                this.ctx.clearRect(0, 0, width, height);
            }

            drawCellHighlight(x, y, cellSize, offsetX, offsetY, fillStyle = 'rgba(255, 255, 255, 0.4)', strokeStyle = '#fff', lineWidth = 3) {
                this.ctx.fillStyle = fillStyle;
                this.ctx.fillRect(
                    offsetX + x * cellSize,
                    offsetY + y * cellSize,
                    cellSize - 1,
                    cellSize - 1
                );

                this.ctx.strokeStyle = strokeStyle;
                this.ctx.lineWidth = lineWidth;
                this.ctx.strokeRect(
                    offsetX + x * cellSize,
                    offsetY + y * cellSize,
                    cellSize - 1,
                    cellSize - 1
                );
            }

            drawRectHighlight(startX, startY, endX, endY, cellSize, offsetX, offsetY, fillStyle = 'rgba(255, 255, 255, 0.4)', strokeStyle = '#fff', lineWidth = 3) {
                const width = (endX - startX) * cellSize - 1;
                const height = (endY - startY) * cellSize - 1;

                if (fillStyle) {
                    this.ctx.fillStyle = fillStyle;
                    this.ctx.fillRect(offsetX + startX * cellSize, offsetY + startY * cellSize, width, height);
                }

                if (strokeStyle) {
                    this.ctx.strokeStyle = strokeStyle;
                    this.ctx.lineWidth = lineWidth;
                    this.ctx.strokeRect(offsetX + startX * cellSize, offsetY + startY * cellSize, width, height);
                }
            }

            drawQueryRegionOutline(query, sizeX, sizeY, cellSize, offsetX, offsetY) {
                this.ctx.strokeStyle = '#4a9eff';
                this.ctx.lineWidth = 3;
                const x1 = Math.max(0, query.x[0]);
                const y1 = Math.max(0, query.y[0]);
                const x2 = Math.min(sizeX - 1, query.x[1]);
                const y2 = Math.min(sizeY - 1, query.y[1]);

                this.ctx.strokeRect(
                    offsetX + x1 * cellSize,
                    offsetY + y1 * cellSize,
                    (x2 - x1 + 1) * cellSize - 1,
                    (y2 - y1 + 1) * cellSize - 1
                );
            }

            drawLinearBar(cellWidth, barHeight, offsetX, offsetY, totalCells, getColorForPosition) {
                if (cellWidth < 1) {
                    this.drawLinearGradientBar(offsetX, offsetY, totalCells * cellWidth, barHeight);
                } else {
                    this.drawLinearCellBar(cellWidth, barHeight, offsetX, offsetY, totalCells, getColorForPosition);
                }
            }

            drawLinearGradientBar(offsetX, offsetY, width, barHeight) {
                const gradient = this.ctx.createLinearGradient(offsetX, offsetY, offsetX + width, offsetY);
                gradient.addColorStop(0, '#00ff00');
                gradient.addColorStop(1, '#ff0000');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(offsetX, offsetY, width, barHeight);
            }

            drawLinearCellBar(cellWidth, barHeight, offsetX, offsetY, totalCells, getColorForPosition) {
                for (let i = 0; i < totalCells; i++) {
                    const color = getColorForPosition(i, totalCells);
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(offsetX + i * cellWidth, offsetY, cellWidth, barHeight);
                }
            }

            drawByteRanges(ranges, cellWidth, barHeight, offsetX, offsetY, label) {
                const { width } = this.getLogicalDimensions();
                
                this.ctx.strokeStyle = '#4a9eff';
                this.ctx.lineWidth = 2;
                
                ranges.forEach(([start, end]) => {
                    const x1 = offsetX + start * cellWidth;
                    const x2 = offsetX + (end + 1) * cellWidth;

                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, offsetY + barHeight + 5);
                    this.ctx.lineTo(x2, offsetY + barHeight + 5);
                    this.ctx.stroke();

                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, offsetY + barHeight);
                    this.ctx.lineTo(x1, offsetY + barHeight + 10);
                    this.ctx.moveTo(x2, offsetY + barHeight);
                    this.ctx.lineTo(x2, offsetY + barHeight + 10);
                    this.ctx.stroke();
                });

                this.ctx.fillStyle = '#aaa';
                this.ctx.font = '11px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`${ranges.length} ${label}`, width / 2, offsetY + barHeight + 25);
            }

            highlightLinearCells(cellPositions, cellWidth, barHeight, offsetX, offsetY, fillStyle = 'rgba(74, 158, 255, 0.5)') {
                this.ctx.fillStyle = fillStyle;
                cellPositions.forEach(pos => {
                    this.ctx.fillRect(offsetX + pos * cellWidth, offsetY, cellWidth, barHeight);
                });
            }

            drawLinearChunkHighlight(chunkRange, cellWidth, barHeight, offsetX, offsetY, showOutline = false) {
                if (!chunkRange) return;

                const chunkCellCount = chunkRange.positions.length;
                const chunkPixelWidth = chunkCellCount * cellWidth;

                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.fillRect(offsetX + chunkRange.min * cellWidth, offsetY, chunkPixelWidth, barHeight);

                if (showOutline) {
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(offsetX + chunkRange.min * cellWidth, offsetY, chunkPixelWidth, barHeight);
                }
            }

            // Template method for rendering - to be implemented by subclasses
            render(params, data) {
                throw new Error('render() must be implemented by subclass');
            }
        }

        class SpatialUnchunkedRenderer extends BaseCanvasRenderer {
            render(params, data) {
                this.clearCanvas();
                
                const [sizeX, sizeY] = params.size;
                const { cellSize, offsetX, offsetY } = this.coordinateService.getSpatialCellLayout(this.canvas, sizeX, sizeY);

                this.drawCellGrid(params, data, sizeX, sizeY, cellSize, offsetX, offsetY);
                this.drawSpatialHighlights(params, sizeX, sizeY, cellSize, offsetX, offsetY);
                this.drawQueryRegionOutline(params.query, sizeX, sizeY, cellSize, offsetX, offsetY);
            }

            drawCellGrid(params, data, sizeX, sizeY, cellSize, offsetX, offsetY) {
                if (cellSize > CONFIG.MIN_CELL_SIZE) {
                    this.drawDetailedCellGrid(params, data, sizeX, sizeY, cellSize, offsetX, offsetY);
                } else {
                    const gradient = this.ctx.createLinearGradient(offsetX, offsetY, offsetX + sizeX * cellSize, offsetY + sizeY * cellSize);
                    gradient.addColorStop(0, '#00ff00');
                    gradient.addColorStop(1, '#ff0000');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(offsetX, offsetY, sizeX * cellSize, sizeY * cellSize);
                }
            }

            drawDetailedCellGrid(params, data, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const { width: logicalWidth } = this.getLogicalDimensions();

                if (cellSize < CONFIG.VIEWPORT_CELL_SIZE && data.totalCells > 1000) {
                    const startX = Math.max(0, Math.floor(-offsetX / cellSize));
                    const endX = Math.min(sizeX, Math.ceil((logicalWidth - offsetX) / cellSize));
                    const startY = Math.max(0, Math.floor(-offsetY / cellSize));
                    const endY = Math.min(sizeY, Math.ceil((logicalWidth - offsetY) / cellSize));
                    this.drawCellRange(params, data, startX, endX, startY, endY, cellSize, offsetX, offsetY);
                } else {
                    this.drawCellRange(params, data, 0, sizeX, 0, sizeY, cellSize, offsetX, offsetY);
                }
            }

            drawCellRange(params, data, startX, endX, startY, endY, cellSize, offsetX, offsetY) {
                for (let y = startY; y < endY; y++) {
                    for (let x = startX; x < endX; x++) {
                        const globalPos = this.visualizer.getGlobalPosition(x, y, 0, params);
                        const color = this.visualizer.getColorForLinearPosition(globalPos, data.totalCells - 1);

                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(
                            offsetX + x * cellSize,
                            offsetY + y * cellSize,
                            cellSize - 1,
                            cellSize - 1
                        );
                    }
                }
            }

            drawSpatialHighlights(params, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const effectiveCell = this.visualizer.getEffectiveCell();
                const effectiveChunk = this.visualizer.getEffectiveChunk();

                if (cellSize > CONFIG.MIN_CELL_SIZE && effectiveCell) {
                    this.drawCellHighlight(effectiveCell.x, effectiveCell.y, cellSize, offsetX, offsetY);
                }

                if (effectiveChunk && !effectiveCell) {
                    this.drawChunkCellHighlights(params, effectiveChunk, sizeX, sizeY, cellSize, offsetX, offsetY);
                }
            }

            drawChunkCellHighlights(params, effectiveChunk, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const [chunkSizeX, chunkSizeY] = params.chunk;

                for (let y = 0; y < sizeY; y++) {
                    for (let x = 0; x < sizeX; x++) {
                        const chunkCoords = this.coordinateService.getChunkCoordinatesFromCell(x, y, chunkSizeX, chunkSizeY);

                        if (chunkCoords.x === effectiveChunk.x && chunkCoords.y === effectiveChunk.y) {
                            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                            this.ctx.fillRect(
                                offsetX + x * cellSize,
                                offsetY + y * cellSize,
                                cellSize - 1,
                                cellSize - 1
                            );
                        }
                    }
                }
            }
        }

        class SpatialChunkedRenderer extends BaseCanvasRenderer {
            render(params, data) {
                this.clearCanvas();
                
                const [sizeX, sizeY, sizeZ] = params.size;
                const { cellSize, offsetX, offsetY } = this.coordinateService.getSpatialCellLayout(this.canvas, sizeX, sizeY);

                const chunkColorMap = this.visualizer.getOrCreateChunkColorMap(params, sizeX, sizeY, sizeZ);
                this.drawChunkGrid(params, chunkColorMap, sizeX, sizeY, sizeZ, cellSize, offsetX, offsetY);
                this.drawChunkedViewHighlights(params, data, sizeX, sizeY, cellSize, offsetX, offsetY);
            }

            drawChunkGrid(params, chunkColorMap, sizeX, sizeY, sizeZ, cellSize, offsetX, offsetY) {
                const chunkGridInfo = this.calculateChunkGridInfo(params, sizeX, sizeY, sizeZ, cellSize, offsetX, offsetY);
                
                for (let chunkCY = chunkGridInfo.startChunkY; chunkCY < chunkGridInfo.endChunkY; chunkCY++) {
                    for (let chunkCX = chunkGridInfo.startChunkX; chunkCX < chunkGridInfo.endChunkX; chunkCX++) {
                        this.drawSingleChunk(chunkColorMap, chunkCX, chunkCY, chunkGridInfo.totalChunks, 
                                           params, sizeX, sizeY, cellSize, offsetX, offsetY);
                    }
                }
            }

            calculateChunkGridInfo(params, sizeX, sizeY, sizeZ, cellSize, offsetX, offsetY) {
                const [chunkX, chunkY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const chunksZ = Math.ceil(Math.max(1, sizeZ) / Math.max(1, params.chunk[2]));

                const { width: logicalWidth, height: logicalHeight } = this.getLogicalDimensions();
                const viewport = this.getChunkViewport(
                    chunksX, chunksY, cellSize, chunkX, chunkY, offsetX, offsetY, logicalWidth, logicalHeight
                );

                return {
                    chunksX,
                    chunksY,
                    chunksZ,
                    totalChunks: chunksX * chunksY * chunksZ,
                    ...viewport
                };
            }

            getChunkViewport(chunksX, chunksY, cellSize, chunkX, chunkY, offsetX, offsetY, logicalWidth, logicalHeight) {
                if (cellSize < CONFIG.VIEWPORT_CELL_SIZE && chunksX * chunksY > 100) {
                    return {
                        startChunkX: Math.max(0, Math.floor(-offsetX / (chunkX * cellSize))),
                        endChunkX: Math.min(chunksX, Math.ceil((logicalWidth - offsetX) / (chunkX * cellSize))),
                        startChunkY: Math.max(0, Math.floor(-offsetY / (chunkY * cellSize))),
                        endChunkY: Math.min(chunksY, Math.ceil((logicalHeight - offsetY) / (chunkY * cellSize)))
                    };
                }
                return { startChunkX: 0, endChunkX: chunksX, startChunkY: 0, endChunkY: chunksY };
            }

            drawSingleChunk(chunkColorMap, chunkCX, chunkCY, totalChunks, params, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const [chunkX, chunkY] = params.chunk;
                const chunkCZ = 0;
                const chunkKey = `${chunkCX},${chunkCY},${chunkCZ}`;
                const colorIndex = chunkColorMap.get(chunkKey);
                const color = this.visualizer.getColorForLinearPosition(colorIndex, totalChunks - 1);

                const bounds = this.coordinateService.getChunkBounds(chunkCX, chunkCY, chunkX, chunkY, sizeX, sizeY);
                const chunkPixelWidth = (bounds.endX - bounds.startX) * cellSize;
                const chunkPixelHeight = (bounds.endY - bounds.startY) * cellSize;

                this.ctx.fillStyle = color;
                this.ctx.fillRect(
                    offsetX + bounds.startX * cellSize,
                    offsetY + bounds.startY * cellSize,
                    chunkPixelWidth,
                    chunkPixelHeight
                );

                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(
                    offsetX + bounds.startX * cellSize,
                    offsetY + bounds.startY * cellSize,
                    chunkPixelWidth,
                    chunkPixelHeight
                );
            }

            drawChunkedViewHighlights(params, data, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const effectiveCell = this.visualizer.getEffectiveCell();
                const effectiveChunk = this.visualizer.getEffectiveChunk();
                const [chunkX, chunkY] = params.chunk;

                if (effectiveCell) {
                    const chunkCoords = this.coordinateService.getChunkCoordinatesFromCell(effectiveCell.x, effectiveCell.y, chunkX, chunkY);
                    const bounds = this.coordinateService.getChunkBounds(chunkCoords.x, chunkCoords.y, chunkX, chunkY, sizeX, sizeY);
                    this.drawRectHighlight(bounds.startX, bounds.startY, bounds.endX, bounds.endY, cellSize, offsetX, offsetY, 'rgba(255, 255, 255, 0.4)', null);
                }

                this.drawTouchedChunksOutline(data, params, sizeX, sizeY, cellSize, offsetX, offsetY);

                if (effectiveChunk && !effectiveCell) {
                    const bounds = this.coordinateService.getChunkBounds(effectiveChunk.x, effectiveChunk.y, chunkX, chunkY, sizeX, sizeY);
                    this.drawRectHighlight(bounds.startX, bounds.startY, bounds.endX, bounds.endY, cellSize, offsetX, offsetY);
                }
            }

            drawTouchedChunksOutline(data, params, sizeX, sizeY, cellSize, offsetX, offsetY) {
                if (data.touchedChunks.size === 0) return;

                const [chunkX, chunkY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);

                let minChunkX = Infinity, minChunkY = Infinity;
                let maxChunkX = -Infinity, maxChunkY = -Infinity;

                data.touchedChunks.forEach(chunkIdx => {
                    const chunkCY = Math.floor(chunkIdx / chunksX);
                    const chunkCX = chunkIdx % chunksX;
                    minChunkX = Math.min(minChunkX, chunkCX);
                    minChunkY = Math.min(minChunkY, chunkCY);
                    maxChunkX = Math.max(maxChunkX, chunkCX);
                    maxChunkY = Math.max(maxChunkY, chunkCY);
                });

                const startX = minChunkX * chunkX;
                const startY = minChunkY * chunkY;
                const endX = Math.min((maxChunkX + 1) * chunkX, sizeX);
                const endY = Math.min((maxChunkY + 1) * chunkY, sizeY);

                this.ctx.strokeStyle = '#4a9eff';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(
                    offsetX + startX * cellSize,
                    offsetY + startY * cellSize,
                    (endX - startX) * cellSize - 1,
                    (endY - startY) * cellSize - 1
                );
            }
        }

        class LinearUnchunkedRenderer extends BaseCanvasRenderer {
            render(params, data) {
                this.clearCanvas();

                const { cellWidth, barHeight, offsetX, offsetY } = this.coordinateService.getLinearBarLayout(this.canvas, data.totalCells);
                
                this.drawLinearBar(cellWidth, barHeight, offsetX, offsetY, data.totalCells, 
                                (i, total) => this.visualizer.getColorForLinearPosition(i, total));

                const requestedPositions = this.getRequestedCellPositions(data, params);
                this.highlightLinearCells(requestedPositions, cellWidth, barHeight, offsetX, offsetY);

                this.drawLinearUnchunkedHighlights(params, cellWidth, barHeight, offsetX, offsetY);
                this.drawByteRanges(data.unchunkedRanges, cellWidth, barHeight, offsetX, offsetY, 'byte range(s)');
            }

            getRequestedCellPositions(data, params) {
                return [...data.requestedCells].map(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    return this.visualizer.getGlobalPosition(x, y, z, params);
                });
            }

            drawLinearUnchunkedHighlights(params, cellWidth, barHeight, offsetX, offsetY) {
                const effectiveCell = this.visualizer.getEffectiveCell();
                const effectiveChunk = this.visualizer.getEffectiveChunk();

                if (effectiveChunk) {
                    const chunkRange = this.visualizer.getChunkGlobalRange(effectiveChunk.x, effectiveChunk.y, params);
                    this.drawLinearChunkHighlight(chunkRange, cellWidth, barHeight, offsetX, offsetY, !effectiveCell);
                }

                if (effectiveCell) {
                    const pos = this.visualizer.getGlobalPosition(effectiveCell.x, effectiveCell.y, 0, params);
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(offsetX + pos * cellWidth, offsetY, cellWidth, barHeight);
                }
            }
        }

        class LinearChunkedRenderer extends BaseCanvasRenderer {
            render(params, data) {
                this.clearCanvas();

                const { cellWidth, barHeight, offsetX, offsetY } = this.coordinateService.getLinearBarLayout(this.canvas, data.totalCells);
                const [sizeX, sizeY, sizeZ] = params.size;

                const positionToCell = this.visualizer.getOrCreatePositionToCellMap(params, sizeX, sizeY, sizeZ);
                const spatialChunkColorMap = this.visualizer.getOrCreateChunkColorMap(params, sizeX, sizeY, sizeZ);

                this.drawLinearChunkedCells(params, data, positionToCell, spatialChunkColorMap, 
                                          cellWidth, barHeight, offsetX, offsetY, sizeX, sizeY, sizeZ);

                const actualCellPositions = this.getActualCellPositions(data, params);
                this.highlightLinearCells(actualCellPositions, cellWidth, barHeight, offsetX, offsetY);

                this.drawLinearChunkedHighlights(params, cellWidth, barHeight, offsetX, offsetY);
                this.drawByteRanges(data.chunkedRanges, cellWidth, barHeight, offsetX, offsetY, 'byte range(s) with chunking');
            }

            getActualCellPositions(data, params) {
                return [...data.actualCells].map(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    return this.visualizer.getGlobalPosition(x, y, z, params);
                });
            }

            drawLinearChunkedCells(params, data, positionToCell, spatialChunkColorMap, 
                                 cellWidth, barHeight, offsetX, offsetY, sizeX, sizeY, sizeZ) {
                const [chunkSizeX, chunkSizeY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkSizeX);
                const chunksY = Math.ceil(sizeY / chunkSizeY);
                const chunksZ3D = Math.ceil(Math.max(1, sizeZ) / Math.max(1, params.chunk[2]));
                const totalChunks3D = chunksX * chunksY * chunksZ3D;

                for (let i = 0; i < data.totalCells; i++) {
                    const color = this.getChunkedCellColor(i, positionToCell, spatialChunkColorMap, 
                                                        params, chunkSizeX, chunkSizeY, totalChunks3D, data.totalCells);
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(offsetX + i * cellWidth, offsetY, cellWidth + 0.5, barHeight);
                }
            }

            getChunkedCellColor(cellIndex, positionToCell, spatialChunkColorMap, params, chunkSizeX, chunkSizeY, totalChunks3D, totalCells) {
                const cell = positionToCell.get(cellIndex);
                if (cell && spatialChunkColorMap) {
                    const chunkCX = Math.floor(cell.x / chunkSizeX);
                    const chunkCY = Math.floor(cell.y / chunkSizeY);
                    const chunkCZ = Math.floor(cell.z / Math.max(1, params.chunk[2]));
                    const chunkKey = `${chunkCX},${chunkCY},${chunkCZ}`;
                    const colorIndex = spatialChunkColorMap.get(chunkKey);

                    if (colorIndex !== undefined) {
                        return this.visualizer.getColorForLinearPosition(colorIndex, totalChunks3D - 1);
                    }
                    return '#333';
                }
                return this.visualizer.getColorForLinearPosition(cellIndex, totalCells);
            }

            drawLinearChunkedHighlights(params, cellWidth, barHeight, offsetX, offsetY) {
                const effectiveChunk = this.visualizer.getEffectiveChunk();

                if (effectiveChunk) {
                    const chunkRange = this.visualizer.getChunkGlobalRange(effectiveChunk.x, effectiveChunk.y, params);
                    const showOutline = !this.visualizer.selectionState.hoveredCell;
                    this.drawLinearChunkHighlight(chunkRange, cellWidth, barHeight, offsetX, offsetY, showOutline);
                }
            }
        }

        class InteractionStrategy {
            constructor(visualizer, tooltipManager) {
                this.visualizer = visualizer;
                this.tooltipManager = tooltipManager;
            }

            // Template method for handling mouse moves
            handleMove(e, canvas, canvasKey) {
                const coords = this.visualizer.coordinateService.getCanvasCoordinates(e, canvas);
                const targetInfo = this.getTargetInfo(coords, canvas, canvasKey);
                
                if (targetInfo) {
                    this.updateHoverState(targetInfo);
                    this.showTooltip(e, targetInfo);
                } else {
                    this.clearHover();
                }
            }

            // Template method for handling clicks
            handleClick(e, canvas, canvasKey) {
                const coords = this.visualizer.coordinateService.getCanvasCoordinates(e, canvas);
                const targetInfo = this.getTargetInfo(coords, canvas, canvasKey);
                
                this.handleSelectionLogic(e, targetInfo);
            }

            // Abstract methods to be implemented by subclasses
            getTargetInfo(coords, canvas, canvasKey) {
                throw new Error('getTargetInfo must be implemented by subclass');
            }

            updateHoverState(targetInfo) {
                if (targetInfo.cell) {
                    this.visualizer.selectionState.setHoveredCell(targetInfo.cell);
                }
                if (targetInfo.chunk) {
                    this.visualizer.selectionState.setHoveredChunk(targetInfo.chunk);
                }
            }

            showTooltip(e, targetInfo) {
                const params = this.visualizer.getParameters();
                if (targetInfo.cell && targetInfo.usesCellTooltip) {
                    this.tooltipManager.show(e, TooltipContentGenerator.generateCellTooltip(targetInfo.cell, params, this.visualizer));
                } else if (targetInfo.chunk) {
                    const [sizeX, sizeY] = params.size;
                    const [chunkX, chunkY] = params.chunk;
                    this.tooltipManager.show(e, TooltipContentGenerator.generateChunkTooltip(targetInfo.chunk, params, sizeX, sizeY, chunkX, chunkY, this.visualizer));
                }
            }

            clearHover() {
                this.visualizer.selectionState.clearHover();
                this.tooltipManager.hide();
            }

            handleSelectionLogic(e, targetInfo) {
                const clickedCell = targetInfo?.cell;
                const clickedChunk = targetInfo?.chunk;

                if (clickedCell || clickedChunk) {
                    // Check if clicking on already selected item to deselect
                    if (this.visualizer.selectionState.isSelected(clickedCell, clickedChunk)) {
                        this.visualizer.selectionState.clearSelection();
                        this.tooltipManager.hide();
                    } else {
                        // Select new item
                        this.visualizer.selectionState.setSelectedCell(clickedCell);
                        this.visualizer.selectionState.setSelectedChunk(clickedChunk);
                        this.showTooltip(e, targetInfo);
                    }
                } else {
                    // Clicked outside any item - clear selection
                    this.visualizer.selectionState.clearSelection();
                    this.tooltipManager.hide();
                }
            }
        }

        class SpatialUnchunkedStrategy extends InteractionStrategy {
            getTargetInfo(coords, canvas, canvasKey) {
                const params = this.visualizer.getParameters();
                const { cellX, cellY, isValid } = this.visualizer.coordinateService.getSpatialCellCoordinates(coords.x, coords.y, canvas, params);
                
                if (!isValid) return null;

                const [chunkX, chunkY] = params.chunk;
                const cell = { x: cellX, y: cellY };
                const chunk = this.visualizer.coordinateService.getChunkCoordinatesFromCell(cellX, cellY, chunkX, chunkY);
                
                return { cell, chunk, usesCellTooltip: true };
            }
        }

        class SpatialChunkedStrategy extends InteractionStrategy {
            getTargetInfo(coords, canvas, canvasKey) {
                const params = this.visualizer.getParameters();
                const { cellX, cellY, isValid } = this.visualizer.coordinateService.getSpatialCellCoordinates(coords.x, coords.y, canvas, params);
                
                if (!isValid) return null;

                const [chunkX, chunkY] = params.chunk;
                const chunk = this.visualizer.coordinateService.getChunkCoordinatesFromCell(cellX, cellY, chunkX, chunkY);
                
                return { chunk, usesCellTooltip: false };
            }

            updateHoverState(targetInfo) {
                this.visualizer.selectionState.setHoveredChunk(targetInfo.chunk);
                this.visualizer.selectionState.setHoveredCell(null);
            }
        }

        class LinearStrategy extends InteractionStrategy {
            getTargetInfo(coords, canvas, canvasKey) {
                const data = this.visualizer.currentData;
                if (!data) return null;

                const { cellIndex, isValid } = this.visualizer.coordinateService.getLinearCellCoordinates(coords.x, coords.y, canvas, data);
                if (!isValid) return null;

                const params = this.visualizer.getParameters();
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY] = params.chunk;
                const foundCell = this.visualizer.getCellFromLinearIndex(cellIndex, params, sizeX, sizeY, chunkX, chunkY);
                
                if (!foundCell) return null;

                const cell = { x: foundCell.x, y: foundCell.y };
                const chunk = { x: foundCell.chunkX, y: foundCell.chunkY };
                const usesCellTooltip = canvasKey === 'linearUnchunked';
                
                return { cell, chunk, usesCellTooltip };
            }

            updateHoverState(targetInfo) {
                const usesCell = targetInfo.usesCellTooltip;
                this.visualizer.selectionState.setHoveredCell(usesCell ? targetInfo.cell : null);
                this.visualizer.selectionState.setHoveredChunk(targetInfo.chunk);
            }
        }

        class InteractionManager {
            constructor(visualizer, canvases, tooltipManager) {
                this.visualizer = visualizer;
                this.canvases = canvases;
                this.tooltipManager = tooltipManager;
                this.mouseThrottle = false;

                // Initialize strategies
                const linearStrategy = new LinearStrategy(visualizer, tooltipManager);
                this.strategies = {
                    spatialUnchunked: new SpatialUnchunkedStrategy(visualizer, tooltipManager),
                    spatialChunked: new SpatialChunkedStrategy(visualizer, tooltipManager),
                    linearUnchunked: linearStrategy,
                    linearChunked: linearStrategy
                };
            }

            handleMouseMove(e, canvasKey) {
                // Don't update anything if there's a selection - keep the selection locked
                if (this.visualizer.selectionState.hasSelection()) {
                    return;
                }

                // Throttle mouse move updates for performance
                if (this.mouseThrottle) return;
                this.mouseThrottle = true;
                requestAnimationFrame(() => {
                    this.mouseThrottle = false;
                });

                const canvas = this.canvases[canvasKey];
                const strategy = this.strategies[canvasKey];
                
                if (strategy) {
                    strategy.handleMove(e, canvas, canvasKey);
                    this.visualizer.update();
                }
            }


            handleMouseLeave() {
                this.visualizer.selectionState.clearHover();
                this.tooltipManager.hide();
                // Use requestAnimationFrame for smoother updates
                if (this.visualizer.updatePending) return;
                this.visualizer.updatePending = true;
                requestAnimationFrame(() => {
                    this.visualizer.updatePending = false;
                    this.visualizer.update();
                });
            }

            handleMouseClick(e, canvasKey) {
                const canvas = this.canvases[canvasKey];
                const strategy = this.strategies[canvasKey];
                
                if (strategy) {
                    strategy.handleClick(e, canvas, canvasKey);
                    this.visualizer.update();
                }
            }

        }

        // Global coordinate service instance
        let coordinateService;

        class CanvasManager {
            constructor(visualizer) {
                this.visualizer = visualizer;
                this.canvases = {};
                this.contexts = {};
                this.renderers = {};
                this.lastCanvasSize = new Map();
            }

            initializeCanvases() {
                this.canvases = {
                    spatialUnchunked: document.getElementById('spatial-unchunked'),
                    spatialChunked: document.getElementById('spatial-chunked'),
                    linearUnchunked: document.getElementById('linear-unchunked'),
                    linearChunked: document.getElementById('linear-chunked')
                };

                this.tooltipManager = new TooltipManager(document.getElementById('tooltip'));
                this.interactionManager = new InteractionManager(this.visualizer, this.canvases, this.tooltipManager);

                this.contexts = {};
                this.renderers = {};
                
                for (const [key, canvas] of Object.entries(this.canvases)) {
                    this.contexts[key] = canvas.getContext('2d');

                    // Create specialized renderers
                    switch(key) {
                        case 'spatialUnchunked':
                            this.renderers[key] = new SpatialUnchunkedRenderer(canvas, this.contexts[key], this.visualizer, this.visualizer.coordinateService);
                            break;
                        case 'spatialChunked':
                            this.renderers[key] = new SpatialChunkedRenderer(canvas, this.contexts[key], this.visualizer, this.visualizer.coordinateService);
                            break;
                        case 'linearUnchunked':
                            this.renderers[key] = new LinearUnchunkedRenderer(canvas, this.contexts[key], this.visualizer, this.visualizer.coordinateService);
                            break;
                        case 'linearChunked':
                            this.renderers[key] = new LinearChunkedRenderer(canvas, this.contexts[key], this.visualizer, this.visualizer.coordinateService);
                            break;
                    }

                    // Add mouse interaction for spatial and linear views
                    if (key.startsWith('spatial') || key.startsWith('linear')) {
                        canvas.addEventListener('mousemove', (e) => this.interactionManager.handleMouseMove(e, key));
                        canvas.addEventListener('mouseleave', () => this.interactionManager.handleMouseLeave());
                        canvas.addEventListener('click', (e) => this.interactionManager.handleMouseClick(e, key));
                    }
                }

                this.setupResizeHandling();
                this.setupGlobalClickHandler();

                // Force initial resize after DOM is ready
                setTimeout(() => {
                    this.resizeCanvases();
                    this.visualizer.update();
                }, 0);

                this.resizeCanvases();
            }

            setupResizeHandling() {
                let resizeRAF = null;

                const handleResize = () => {
                    if (resizeRAF) return; // Prevent multiple concurrent updates

                    resizeRAF = requestAnimationFrame(() => {
                        const needsUpdate = this.resizeCanvases();
                        if (needsUpdate) {
                            this.visualizer.update();
                        }
                        resizeRAF = null;
                    });
                };

                // Only use window resize - simpler and more reliable
                window.addEventListener('resize', handleResize);
            }

            setupGlobalClickHandler() {
                // Clear selection when clicking outside visualizations
                document.addEventListener('click', (e) => {
                    // Check if click was inside any canvas
                    let clickedCanvas = false;
                    for (const canvas of Object.values(this.canvases)) {
                        const rect = canvas.getBoundingClientRect();
                        if (e.clientX >= rect.left && e.clientX <= rect.right &&
                            e.clientY >= rect.top && e.clientY <= rect.bottom) {
                            clickedCanvas = true;
                            break;
                        }
                    }

                    // If clicked outside all canvases, clear selection
                    if (!clickedCanvas && this.visualizer.selectionState.hasSelection()) {
                        this.visualizer.selectionState.clearSelection();
                        this.tooltipManager.hide();
                        this.visualizer.update();
                    }
                });
            }

            setCanvasSize(key, width, height) {
                const canvas = this.canvases[key];
                const ctx = this.contexts[key];
                const dpr = window.devicePixelRatio || 1;

                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';

                // Reset transform before scaling to prevent accumulation
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dpr, dpr);
            }

            resizeCanvases() {
                let needsUpdate = false;

                // Spatial canvases - square aspect
                ['spatialUnchunked', 'spatialChunked'].forEach(key => {
                    const canvas = this.canvases[key];
                    const canvasContainer = canvas.parentElement; // .canvas-container
                    const vizPanel = canvasContainer.parentElement; // .viz-panel
                    const containerRect = vizPanel.getBoundingClientRect();

                    // Account for viz-panel padding (15px) and canvas-container padding (10px)
                    const vizPanelPadding = 15;
                    const canvasContainerPadding = 20; // 10px on each side
                    const totalPadding = vizPanelPadding * 2 + canvasContainerPadding;

                    const availableWidth = containerRect.width - totalPadding;
                    const size = Math.min(availableWidth, CONFIG.MAX_CANVAS_SIZE);
                    const lastSize = this.lastCanvasSize.get(key);

                    if (size > 0 && (!lastSize || lastSize.width !== size || lastSize.height !== size)) {
                        this.setCanvasSize(key, size, size);
                        this.lastCanvasSize.set(key, { width: size, height: size });
                        needsUpdate = true;
                    }
                });

                // Linear canvases - full width
                ['linearUnchunked', 'linearChunked'].forEach(key => {
                    const canvas = this.canvases[key];
                    const canvasContainer = canvas.parentElement; // .canvas-container
                    const linearViz = canvasContainer.parentElement; // .linear-viz
                    const containerRect = linearViz.getBoundingClientRect();

                    // Account for linear-viz padding (15px) and canvas-container padding (10px)
                    const linearVizPadding = 15;
                    const canvasContainerPadding = 20; // 10px on each side
                    const totalPadding = linearVizPadding * 2 + canvasContainerPadding;

                    const width = containerRect.width - totalPadding;
                    const height = 120;
                    const lastSize = this.lastCanvasSize.get(key);

                    if (width > 0 && (!lastSize || lastSize.width !== width || lastSize.height !== height)) {
                        this.setCanvasSize(key, width, height);
                        this.lastCanvasSize.set(key, { width, height });
                        needsUpdate = true;
                    }
                });

                return needsUpdate;
            }

            renderAll(params, data) {
                // Draw all views using specialized renderers
                this.renderers.spatialUnchunked.render(params, data);
                this.renderers.spatialChunked.render(params, data);
                this.renderers.linearUnchunked.render(params, data);
                this.renderers.linearChunked.render(params, data);
            }
        }

        class SettingsManager {
            constructor() {
                this.loadSettings();
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('vischunk-app-state');
                    if (saved) {
                        this.appState = JSON.parse(saved);
                    } else {
                        this.appState = DEFAULT_APP_STATE;
                    }
                } catch (error) {
                    console.warn('Failed to load settings from localStorage:', error);
                    this.appState = DEFAULT_APP_STATE;
                }

                // Initialize current visualization state from the selected preset
                const currentPreset = this.appState.currentPreset;
                const presetSettings = this.appState.presets[currentPreset] ||
                                     this.getCanonicalPreset(currentPreset);

                this.state = {
                    ...presetSettings,
                    currentPreset: currentPreset
                };
            }

            saveSettings() {
                // Save current preset settings (excluding currentPreset from the preset data)
                const currentSettings = { ...this.state };
                delete currentSettings.currentPreset;

                // Only save preset if it differs from canonical version
                const canonicalSettings = this.getCanonicalPreset(this.state.currentPreset);
                const hasChanges = canonicalSettings && Object.keys(canonicalSettings).some(key =>
                    currentSettings[key] !== canonicalSettings[key]
                );

                if (hasChanges) {
                    // Preset is modified - save it
                    this.appState.presets[this.state.currentPreset] = currentSettings;
                } else {
                    // Preset matches canonical - remove any saved version
                    delete this.appState.presets[this.state.currentPreset];
                }

                // Always save the current preset selection
                this.appState.currentPreset = this.state.currentPreset;

                // Save entire app state
                localStorage.setItem('vischunk-app-state', JSON.stringify(this.appState));
            }

            setState(newState) {
                const oldState = { ...this.state };
                this.state = { ...this.state, ...newState };
                return { oldState, hasStructuralChanges: this.checkStructuralChanges(oldState, newState) };
            }

            checkStructuralChanges(oldState, newState) {
                const structuralChanges = ['cellAlgorithm', 'chunkAlgorithm', 'sizeX', 'sizeY', 'sizeZ', 'chunkX', 'chunkY', 'chunkZ'];
                return structuralChanges.some(key =>
                    key in newState && oldState[key] !== newState[key]
                );
            }

            validateAndClampState() {
                let updates = {};
                let { sizeX, sizeY, sizeZ, chunkX, chunkY, chunkZ, queryX1, queryX2, queryY1, queryY2, queryZ1, queryZ2 } = this.state;

                // Cap dimensions to prevent browser lockup
                if (sizeX > 64) { updates.sizeX = 64; sizeX = 64; }
                if (sizeY > 64) { updates.sizeY = 64; sizeY = 64; }
                if (sizeZ > 16) { updates.sizeZ = 16; sizeZ = 16; }

                // Also prevent total cells from being too large
                const totalCells = sizeX * sizeY * Math.max(1, sizeZ);
                if (totalCells > 4096) {
                    updates.sizeX = 32; sizeX = 32;
                    updates.sizeY = 32; sizeY = 32;
                    updates.sizeZ = 1; sizeZ = 1;
                }

                // Clamp chunk sizes to valid ranges
                if (chunkX > sizeX) { updates.chunkX = sizeX; chunkX = sizeX; }
                if (chunkY > sizeY) { updates.chunkY = sizeY; chunkY = sizeY; }
                if (chunkZ > sizeZ) { updates.chunkZ = Math.max(1, sizeZ); chunkZ = Math.max(1, sizeZ); }

                // Clamp query values to valid ranges
                const maxX = sizeX - 1;
                const maxY = sizeY - 1;
                const maxZ = sizeZ - 1;

                if (queryX1 > maxX) { updates.queryX1 = Math.max(0, maxX); }
                if (queryX2 > maxX) { updates.queryX2 = Math.max(0, maxX); }
                if (queryY1 > maxY) { updates.queryY1 = Math.max(0, maxY); }
                if (queryY2 > maxY) { updates.queryY2 = Math.max(0, maxY); }
                if (queryZ1 > maxZ) { updates.queryZ1 = Math.max(0, maxZ); }
                if (queryZ2 > maxZ) { updates.queryZ2 = Math.max(0, maxZ); }

                // Handle edge cases: if array dimension is 1, set sensible defaults
                if (sizeX === 1) {
                    updates.chunkX = 1;
                    updates.queryX1 = 0;
                    updates.queryX2 = 0;
                }
                if (sizeY === 1) {
                    updates.chunkY = 1;
                    updates.queryY1 = 0;
                    updates.queryY2 = 0;
                }
                if (sizeZ === 1) {
                    updates.chunkZ = 1;
                    updates.queryZ1 = 0;
                    updates.queryZ2 = 0;
                }

                return updates;
            }

            updateDOMConstraints() {
                const { sizeX, sizeY, sizeZ } = this.state;

                document.getElementById('chunkX').max = sizeX;
                document.getElementById('chunkY').max = sizeY;
                document.getElementById('chunkZ').max = Math.max(1, sizeZ);

                document.getElementById('queryX1').max = Math.max(0, sizeX - 1);
                document.getElementById('queryX2').max = Math.max(0, sizeX - 1);
                document.getElementById('queryY1').max = Math.max(0, sizeY - 1);
                document.getElementById('queryY2').max = Math.max(0, sizeY - 1);
                document.getElementById('queryZ1').max = Math.max(0, sizeZ - 1);
                document.getElementById('queryZ2').max = Math.max(0, sizeZ - 1);
            }

            renderUI() {
                Object.keys(this.state).forEach(key => {
                    if (key === 'currentPreset') {
                        const presetsEl = document.getElementById('presets');
                        if (presetsEl) presetsEl.value = this.state[key];
                    } else {
                        const element = document.getElementById(key);
                        if (element) element.value = this.state[key];
                    }
                });
            }

            getCanonicalPreset(presetName) {
                if (presetName === 'user') {
                    return DEFAULT_USER_SETTINGS;
                } else if (PRESET_CONFIGS[presetName]) {
                    const { name, ...settings } = PRESET_CONFIGS[presetName];
                    return settings;
                }
                return null;
            }

            getCurrentPresetSettings(presetName) {
                return this.appState.presets[presetName] || this.getCanonicalPreset(presetName);
            }

            getPresetDisplayName(presetName, includeModificationIndicator = false) {
                let baseName = presetName === 'user' ? 'User Settings' :
                              PRESET_CONFIGS[presetName]?.name || presetName;

                if (includeModificationIndicator && this.isPresetModified(presetName)) {
                    baseName += ' *';
                }

                return baseName;
            }

            isPresetModified(presetName) {
                if (presetName === 'user') {
                    return false;
                } else if (PRESET_CONFIGS[presetName]) {
                    return !!(this.appState && this.appState.presets && this.appState.presets[presetName]);
                }
                return false;
            }

            loadPreset(presetName) {
                this.appState.currentPreset = presetName;
                const presetSettings = this.getCurrentPresetSettings(presetName);
                if (presetSettings) {
                    this.setState({ ...presetSettings, currentPreset: presetName });
                    return true;
                }
                return false;
            }

            resetCurrentPreset() {
                const presetName = this.state.currentPreset;

                // Remove user modifications for this preset
                if (this.appState.presets[presetName]) {
                    delete this.appState.presets[presetName];
                }

                // Load canonical preset
                const canonicalSettings = this.getCanonicalPreset(presetName);
                if (canonicalSettings) {
                    this.setState({ ...canonicalSettings, currentPreset: presetName });
                    return true;
                }
                return false;
            }

            shouldShowResetButton() {
                const canonical = this.getCanonicalPreset(this.state.currentPreset);
                return canonical && Object.keys(canonical).some(key =>
                    this.state[key] !== canonical[key]
                );
            }
        }

        class DataVisualizer {
            constructor() {
                // Initialize coordinate service and settings manager
                this.coordinateService = new CoordinateService();
                this.settingsManager = new SettingsManager();
                
                this.selectionState = new SelectionState();

                // Initialize caches with LRU policy
                this.linearizationCache = new LRUCache(CONFIG.LRU_DETAIL_CACHE_SIZE);
                this.positionCache = new LRUCache(CONFIG.LRU_DETAIL_CACHE_SIZE);
                this.chunkPositionCache = new LRUCache(CONFIG.LRU_CONFIG_CACHE_SIZE);
                this.cellPositionCache = new LRUCache(CONFIG.LRU_CONFIG_CACHE_SIZE);
                this.colorCache = new LRUCache(CONFIG.LRU_DETAIL_CACHE_SIZE);

                // Initialize linearization engine
                this.linearizationEngine = new LinearizationEngine(
                    this.linearizationCache,
                    this.positionCache,
                    this.chunkPositionCache,
                    this.cellPositionCache
                );

                // Initialize canvas manager
                this.canvasManager = new CanvasManager(this);

                this.initializeControls();
                this.canvasManager.initializeCanvases();
                this.updateUI();
                this.update();
            }


            getCellFromLinearIndex(cellIndex, params, sizeX, sizeY, chunkX, chunkY) {
                for (let cy = 0; cy < sizeY; cy++) {
                    for (let cx = 0; cx < sizeX; cx++) {
                        const globalPos = this.getGlobalPosition(cx, cy, 0, params);
                        if (globalPos === cellIndex) {
                            return { 
                                x: cx, 
                                y: cy,
                                chunkX: Math.floor(cx / chunkX),
                                chunkY: Math.floor(cy / chunkY)
                            };
                        }
                    }
                }
                return null;
            }

            setState(newState) {
                const { oldState, hasStructuralChanges } = this.settingsManager.setState(newState);

                // Caches are now managed by LRU policy.
                // Clearing them on every structural change would prevent the performance benefit
                // of switching back and forth between recent settings.
                // if (hasStructuralChanges) {
                //     this.clearCaches();
                // }
            }

            // Full UI update cycle - call this after setState() when you want to update the display
            updateUI() {
                this.settingsManager.renderUI();
                this.settingsManager.updateDOMConstraints();
                this.updateResetButton();
                this.updatePresetDisplay();
                this.update();
            }

            // Clear all caches when structural changes occur
            clearCaches() {
                this.linearizationCache.clear();
                this.positionCache.clear();
                if (this.chunkPositionCache) this.chunkPositionCache.clear();
                if (this.cellPositionCache) this.cellPositionCache.clear();
                if (this.colorCache) this.colorCache.clear();
                if (this.coordinateService) this.coordinateService.clearCache();
            }

            populatePresetOptions() {
                const presetsSelect = document.getElementById('presets');

                // Add preset options dynamically
                Object.keys(PRESET_CONFIGS).forEach(presetKey => {
                    const option = document.createElement('option');
                    option.value = presetKey;
                    option.textContent = this.settingsManager.getPresetDisplayName(presetKey, true);
                    presetsSelect.appendChild(option);
                });
            }

            initializeControls() {
                // Populate preset options
                this.populatePresetOptions();

                const controls = ['cellAlgorithm', 'chunkAlgorithm', 'sizeX', 'sizeY', 'sizeZ',
                                 'chunkX', 'chunkY', 'chunkZ',
                                 'queryX1', 'queryX2', 'queryY1', 'queryY2',
                                 'queryZ1', 'queryZ2'];

                controls.forEach(id => {
                    const element = document.getElementById(id);
                    element.addEventListener('change', (e) => {
                        let value = e.target.type === 'number' ?
                            parseInt(e.target.value) :
                            e.target.value;

                        // Validate numeric inputs
                        if (e.target.type === 'number') {
                            if (isNaN(value)) {
                                console.warn(`Invalid input value: ${e.target.value}, resetting to 1`);
                                value = 1;
                            } else {
                                // Apply proper constraints based on field type
                                if (id.startsWith('size') || id.startsWith('chunk')) {
                                    value = Math.max(1, value); // Dimensions and chunk sizes must be >= 1
                                } else {
                                    value = Math.max(0, value); // Query ranges can start at 0
                                }

                                // Apply upper limits
                                if (id.startsWith('size')) value = Math.min(value, 64); // Cap array sizes
                                if (id === 'sizeZ') value = Math.min(value, 16); // Cap Z dimension
                            }
                        }

                        this.setState({ [id]: value });
                        this.updateUI();
                        this.settingsManager.saveSettings(); // Explicit save for user input
                    });
                });

                // Add preset handler
                document.getElementById('presets').addEventListener('change', (e) => {
                    this.settingsManager.loadPreset(e.target.value);
                    this.updateUI();
                    this.settingsManager.saveSettings(); // Save when user explicitly changes preset
                });

                // Add reset button handler
                document.getElementById('resetButton').addEventListener('click', () => {
                    this.settingsManager.resetCurrentPreset();
                    this.updateUI();
                    this.settingsManager.saveSettings();
                });

                this.updateConstraints();
                this.updateResetButton();
            }

            updateResetButton() {
                const resetButton = document.getElementById('resetButton');
                const shouldShow = this.settingsManager.shouldShowResetButton();
                
                resetButton.disabled = !shouldShow;
                resetButton.style.opacity = shouldShow ? '1' : '0.5';
            }

            updatePresetDisplay() {
                const presetsSelect = document.getElementById('presets');

                // Update all preset option text to show/hide asterisks
                presetsSelect.querySelectorAll('option').forEach(option => {
                    option.textContent = this.settingsManager.getPresetDisplayName(option.value, true);
                });
            }

            updateConstraints() {
                // Validate and clamp state values using settings manager
                const updates = this.settingsManager.validateAndClampState();
                
                // Update DOM constraints
                this.settingsManager.updateDOMConstraints();

                // Apply any needed state updates
                if (Object.keys(updates).length > 0) {
                    this.setState(updates);
                    this.settingsManager.renderUI(); // Only update form values, don't trigger full UI cycle
                }
            }

            getParameters() {
                const state = this.settingsManager.state;
                return {
                    cellAlgorithm: state.cellAlgorithm,
                    chunkAlgorithm: state.chunkAlgorithm,
                    size: [
                        state.sizeX,
                        state.sizeY,
                        state.sizeZ
                    ],
                    chunk: [
                        state.chunkX,
                        state.chunkY,
                        state.chunkZ
                    ],
                    query: {
                        x: [state.queryX1, state.queryX2],
                        y: [state.queryY1, state.queryY2],
                        z: [state.queryZ1, state.queryZ2]
                    }
                };
            }

            // Delegate to LinearizationEngine methods
            linearizeCoordinate(x, y, z, sizeX, sizeY, sizeZ, algorithm) {
                return this.linearizationEngine.linearizeCoordinate(x, y, z, sizeX, sizeY, sizeZ, algorithm);
            }

            getIntraChunkPosition(x, y, z, params) {
                return this.linearizationEngine.getIntraChunkPosition(x, y, z, params);
            }

            getInterChunkPosition(x, y, z, params) {
                return this.linearizationEngine.getInterChunkPosition(x, y, z, params);
            }

            getNormalizedChunkPosition(x, y, z, params) {
                return this.linearizationEngine.getNormalizedChunkPosition(x, y, z, params);
            }

            getGlobalPosition(x, y, z, params) {
                return this.linearizationEngine.getGlobalPosition(x, y, z, params);
            }

            // Get the range of global positions for a chunk
            getChunkGlobalRange(chunkCX, chunkCY, params) {
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY] = params.chunk;
                const cellsPerChunk = chunkX * chunkY;

                const positions = [];
                for (let dy = 0; dy < chunkY; dy++) {
                    for (let dx = 0; dx < chunkX; dx++) {
                        const x = chunkCX * chunkX + dx;
                        const y = chunkCY * chunkY + dy;
                        if (x < sizeX && y < sizeY) {
                            positions.push(this.getGlobalPosition(x, y, 0, params));
                        }
                    }
                }

                if (positions.length === 0) return null;
                return {
                    min: Math.min(...positions),
                    max: Math.max(...positions),
                    positions: positions
                };
            }


            getChunkIndex(x, y, z, params) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const cx = Math.floor(x / chunkX);
                const cy = Math.floor(y / chunkY);
                const cz = Math.floor(z / chunkZ);
                const [sizeX, sizeY] = params.size;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                return cx + cy * chunksX + cz * chunksX * chunksY;
            }

            getColorForLinearPosition(position, maxPosition) {
                const key = CacheKeyGenerator.createColorKey(position, maxPosition);

                const cachedColor = this.colorCache.get(key);
                if (cachedColor) {
                    return cachedColor;
                }

                const hue = 120 - (position / maxPosition) * 120; // Green to red (120° to 0°)
                const color = `hsl(${hue}, 70%, 50%)`;

                this.colorCache.set(key, color);
                return color;
            }

            // Helper methods to get the effective cell/chunk for highlighting (selected takes precedence over hovered)
            getEffectiveCell() {
                return this.selectionState.getEffectiveCell();
            }

            getEffectiveChunk() {
                return this.selectionState.getEffectiveChunk();
            }



            update() {
                const params = this.getParameters();

                // Update Z range visibility
                document.getElementById('zRange').style.display =
                    params.size[2] > 0 ? 'flex' : 'none';

                // Calculate data
                const data = this.calculateData(params);
                this.currentData = data; // Store for mouse interactions

                // Draw all views using canvas manager
                this.canvasManager.renderAll(params, data);

                // Update metrics
                this.updateMetrics(data);
            }

            calculateData(params) {
                const [sizeX, sizeY, sizeZ] = params.size;
                const totalCells = sizeX * sizeY * Math.max(1, sizeZ);

                const { requestedCells, touchedChunks } = this.calculateRequestedCellsAndChunks(params, sizeX, sizeY, sizeZ);
                const actualCells = this.calculateActualCellsFromChunks(touchedChunks, params, sizeX, sizeY, sizeZ);

                const chunkedRanges = this.calculateByteRanges(
                    this.cellSetToPositions(actualCells, params)
                );

                const unchunkedRanges = this.calculateByteRanges(
                    this.cellSetToPositions(requestedCells, params)
                );

                return {
                    requestedCells,
                    actualCells,
                    touchedChunks,
                    chunkedRanges,
                    unchunkedRanges,
                    totalCells
                };
            }

            calculateRequestedCellsAndChunks(params, sizeX, sizeY, sizeZ) {
                const requestedCells = new Set();
                const touchedChunks = new Set();

                for (let x = params.query.x[0]; x <= Math.min(params.query.x[1], sizeX - 1); x++) {
                    for (let y = params.query.y[0]; y <= Math.min(params.query.y[1], sizeY - 1); y++) {
                        if (sizeZ > 0) {
                            for (let z = params.query.z[0]; z <= Math.min(params.query.z[1], sizeZ - 1); z++) {
                                requestedCells.add(`${x},${y},${z}`);
                                touchedChunks.add(this.getChunkIndex(x, y, z, params));
                            }
                        } else {
                            requestedCells.add(`${x},${y},0`);
                            touchedChunks.add(this.getChunkIndex(x, y, 0, params));
                        }
                    }
                }

                return { requestedCells, touchedChunks };
            }

            calculateActualCellsFromChunks(touchedChunks, params, sizeX, sizeY, sizeZ) {
                const actualCells = new Set();
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);

                touchedChunks.forEach(chunkIdx => {
                    const chunkCoords = this.getChunkCoordsFromIndex(chunkIdx, chunksX, chunksY);
                    this.addChunkCells(actualCells, chunkCoords, params, sizeX, sizeY, sizeZ);
                });

                return actualCells;
            }

            getChunkCoordsFromIndex(chunkIdx, chunksX, chunksY) {
                const cz = Math.floor(chunkIdx / (chunksX * chunksY));
                const cy = Math.floor((chunkIdx % (chunksX * chunksY)) / chunksX);
                const cx = chunkIdx % chunksX;
                return { cx, cy, cz };
            }

            addChunkCells(actualCells, chunkCoords, params, sizeX, sizeY, sizeZ) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const { cx, cy, cz } = chunkCoords;

                for (let dx = 0; dx < chunkX; dx++) {
                    for (let dy = 0; dy < chunkY; dy++) {
                        for (let dz = 0; dz < (sizeZ > 0 ? chunkZ : 1); dz++) {
                            const x = cx * chunkX + dx;
                            const y = cy * chunkY + dy;
                            const z = cz * chunkZ + dz;

                            if (x < sizeX && y < sizeY && (sizeZ === 0 || z < sizeZ)) {
                                actualCells.add(`${x},${y},${z}`);
                            }
                        }
                    }
                }
            }

            cellSetToPositions(cellSet, params) {
                return [...cellSet].map(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    return this.getGlobalPosition(x, y, z, params);
                });
            }

            calculateByteRanges(positions) {
                if (positions.length === 0) return [];

                const sorted = [...positions].sort((a, b) => a - b);
                const ranges = [];
                let start = sorted[0];
                let end = sorted[0];

                for (let i = 1; i < sorted.length; i++) {
                    if (sorted[i] === end + 1) {
                        end = sorted[i];
                    } else {
                        ranges.push([start, end]);
                        start = end = sorted[i];
                    }
                }
                ranges.push([start, end]);
                return ranges;
            }


            getOrCreateChunkColorMap(params, sizeX, sizeY, sizeZ) {
                const [chunkX, chunkY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const chunksZ = Math.ceil(Math.max(1, sizeZ) / Math.max(1, params.chunk[2]));
                const cacheKey = CacheKeyGenerator.createChunkColorMapKey(chunksX, chunksY, chunksZ, params.chunkAlgorithm);

                let chunkColorMap = this.positionCache.get(cacheKey);
                if (!chunkColorMap) {
                    chunkColorMap = this.createChunkColorMap(params, chunksX, chunksY, chunksZ);
                    this.positionCache.set(cacheKey, chunkColorMap);
                }
                return chunkColorMap;
            }

            createChunkColorMap(params, chunksX, chunksY, chunksZ) {
                const chunkPositions = [];
                for (let chunkCZ = 0; chunkCZ < chunksZ; chunkCZ++) {
                    for (let chunkCY = 0; chunkCY < chunksY; chunkCY++) {
                        for (let chunkCX = 0; chunkCX < chunksX; chunkCX++) {
                            const linearPos = this.linearizeCoordinate(chunkCX, chunkCY, chunkCZ, chunksX, chunksY, chunksZ, params.chunkAlgorithm);
                            chunkPositions.push({ chunkCX, chunkCY, chunkCZ, linearPos });
                        }
                    }
                }

                chunkPositions.sort((a, b) => a.linearPos - b.linearPos);

                const chunkColorMap = new Map();
                chunkPositions.forEach((chunk, index) => {
                    const key = `${chunk.chunkCX},${chunk.chunkCY},${chunk.chunkCZ}`;
                    chunkColorMap.set(key, index);
                });
                return chunkColorMap;
            }


            getOrCreatePositionToCellMap(params, sizeX, sizeY, sizeZ) {
                const [chunkSizeX, chunkSizeY] = params.chunk;
                const cacheKey = CacheKeyGenerator.createPositionToCellMapKey(
                    sizeX, sizeY, params.cellAlgorithm, params.chunkAlgorithm, chunkSizeX, chunkSizeY
                );
                
                let positionToCell = this.positionCache.get(cacheKey);
                if (!positionToCell) {
                    positionToCell = new Map();
                    for (let z = 0; z < Math.max(1, sizeZ); z++) {
                        for (let y = 0; y < sizeY; y++) {
                            for (let x = 0; x < sizeX; x++) {
                                const globalPos = this.getGlobalPosition(x, y, z, params);
                                positionToCell.set(globalPos, {x, y, z});
                            }
                        }
                    }
                    this.positionCache.set(cacheKey, positionToCell);
                }
                return positionToCell;
            }

            updateMetrics(data) {
                const params = this.getParameters();
                const [sizeX, sizeY] = params.size;
                const queryWidth = Math.abs(params.query.x[1] - params.query.x[0]) + 1;
                const queryHeight = Math.abs(params.query.y[1] - params.query.y[0]) + 1;
                const amplification = data.actualCells.size / Math.max(1, data.requestedCells.size);
                const coalescingFactor = data.touchedChunks.size / Math.max(1, data.chunkedRanges.length);
                const storageAlignment = 2 / (amplification + coalescingFactor);

                document.getElementById('requested-cells').textContent = data.requestedCells.size;
                document.getElementById('actual-cells').textContent = data.actualCells.size;
                document.getElementById('amplification').innerHTML =
                    amplification.toFixed(2) + '<span class="metric-suffix">x</span>';
                document.getElementById('chunks-touched').textContent = data.touchedChunks.size;
                document.getElementById('byte-ranges').textContent = data.chunkedRanges.length;
                document.getElementById('efficiency').innerHTML =
                    (100 / amplification).toFixed(1) + '<span class="metric-suffix">%</span>';
                document.getElementById('coalescing-factor').innerHTML =
                    coalescingFactor.toFixed(1) + '<span class="metric-suffix">x</span>';
                document.getElementById('storage-alignment').textContent = storageAlignment.toFixed(2);
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            new DataVisualizer();
        });
    </script>
</body>
</html>
