<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multidimensional Data Linearization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segue UI', Roboto, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            min-width: 320px;
            padding: 15px;
            color: #eee;
        }

        .container {
            margin: 0 auto;
        }

        .content-wrapper {
            max-width: 1600px;
            min-width: 320px;
            margin: 0 auto;
        }

        h1 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 2em;
            text-align: center;
        }

        .subtitle {
            color: #aaa;
            margin-bottom: 15px;
            text-align: center;
        }

        .section-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }


        .section-container h2 {
            color: #fff;
            font-size: 1.3em;
            margin: 0 0 15px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .simulation-wrapper {
            padding: 15px 15px 15px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .simulation-wrapper > h2 {
            color: #fff;
            font-size: 1.8em;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            grid-template-rows: auto 1fr; /* Header row + content row */
            gap: 15px;
            margin-bottom: 15px;
        }

        .control-section {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Removed problematic subgrid rules that were causing dropdown stacking */

        .section-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 5px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 500;
            color: #bbb;
            margin-bottom: 5px;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="number"], select {
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transition: all 0.3s;
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #4a9eff;
            background: rgba(255, 255, 255, 0.15);
        }

        select option {
            background: #2a2a3e;
            color: #fff;
        }

        .query-controls {
            background: rgba(255, 200, 0, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 200, 0, 0.3);
        }

        .query-title {
            font-weight: 600;
            color: #ffc107;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        .range-inputs {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .range-group {
            display: flex;
            gap: 15px;
            align-items: center;
            color: #ddd;
        }

        .range-group input {
            width: 60px;
        }

        .spatial-views {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            .spatial-views {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        .viz-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            max-width: 100%;
            cursor: crosshair;
            margin: 0 auto;
        }

        .linear-views {
            margin-bottom: 15px;
        }

        .linear-viz {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            grid-template-rows: auto auto; /* Label row + value row, both natural size */
            gap: 5px 15px; /* row-gap column-gap - tight gap between label/value, normal gap between metrics */
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
        }

        @media (min-width: 1200px) {
            .metrics {
                grid-template-columns: repeat(8, 1fr);
            }
        }

        @media (max-width: 1199px) and (min-width: 800px) {
            .metrics {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 799px) and (min-width: 400px) {
            .metrics {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 399px) {
            .metrics {
                grid-template-columns: 1fr;
            }
        }

        .metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            backdrop-filter: blur(10px);
            display: grid;
            grid-template-rows: subgrid; /* Align with parent grid rows */
            grid-row: span 2; /* Span both label and value rows */
        }

        /* Fallback for browsers without subgrid support */
        @supports not (grid-template-rows: subgrid) {
            .metric {
                display: block;
                grid-row: auto;
            }
        }

        .metric-label {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #fff;
        }

        .metric-suffix {
            font-size: 0.5em;
            color: rgba(255, 255, 255, 0.7);
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .explanation {
            margin: 40px auto 0 auto;
            padding: 15px 15px 15px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .explanation h2 {
            color: #fff;
            font-size: 1.8em;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .explanation-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        @media (min-width: 1200px) {
            .explanation-content {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .explanation-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .explanation-section h3 {
            color: #4a9eff;
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .explanation-section p {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .explanation-section ul {
            color: #ccc;
            margin-left: 15px;
            line-height: 1.6;
        }

        .explanation-section li {
            margin-bottom: 8px;
        }

        .color-example {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
            vertical-align: middle;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .highlight-blue {
            background: rgba(74, 158, 255, 0.7);
        }

        .highlight-white {
            background: rgba(255, 255, 255, 0.4);
        }

        .gradient-example {
            background: linear-gradient(90deg, #00ff00, #ff0000);
        }

        /* Hide Z dimension controls for now */
        .z-control {
            display: none !important;
            /*display: flex !important;*/
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #aaa;
            font-size: 0.9em;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .reset-button {
            display: block;
            margin: 0 auto;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            width: fit-content;
        }

        .reset-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #4a9eff;
        }

        .github-link-container {
            text-align: center;
            margin: 10px 0;
        }

        .github-link {
            color: #4a9eff;
            text-decoration: none;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .preset-controls {
            display: flex;
            align-items: flex-end;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .preset-controls .control-group {
            flex: 1;
            min-width: 180px;
        }

        .preset-controls .reset-button {
            margin: 0;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .gradient-legend {
            background: linear-gradient(90deg, #00ff00, #ff0000);
        }

        .query-legend {
            border: 3px solid #4a9eff;
            background: transparent;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Multidimensional Data Linearization Visualizer</h1>
        <p class="subtitle">Explore how chunking and linearization strategies affect read patterns</p>

        <div class="github-link-container">
            <a href="https://github.com/jkeifer/vischunk" target="_blank" class="github-link">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
                View on GitHub
            </a>
        </div>

        <div class="content-wrapper simulation-wrapper">
            <h2>Interactive Simulation</h2>

            <div class="section-container">
                <h2>Simulation Controls</h2>

                <div class="preset-controls">
                    <div class="control-group">
                        <label for="presets">Scenario Presets</label>
                        <select id="presets">
                            <option value="user">User Settings</option>
                        </select>
                    </div>
                    <button class="reset-button" id="resetButton">reset to default</button>
                </div>

            <div class="controls">
                <div class="control-section">
                <div class="section-title">Array Settings</div>
                <div class="control-group">
                    <label for="sizeX">Array Size X</label>
                    <input type="number" id="sizeX" min="1" max="64" value="16">
                </div>

                <div class="control-group">
                    <label for="sizeY">Array Size Y</label>
                    <input type="number" id="sizeY" min="1" max="64" value="16">
                </div>

                <div class="control-group z-control" id="arraySizeZGroup">
                    <label for="sizeZ">Array Size Z</label>
                    <input type="number" id="sizeZ" min="1" max="16" value="1">
                </div>


                <div class="control-group">
                    <label for="cellAlgorithm">Cell Linearization (within chunk)</label>
                    <select id="cellAlgorithm">
                        <option value="row-major">Row-Major</option>
                        <option value="col-major">Column-Major</option>
                        <option value="z-order">Z-Order (Morton)</option>
                        <option value="hilbert">Hilbert Curve</option>
                    </select>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Chunk Settings</div>
                <div class="control-group">
                    <label for="chunkX">Chunk Size X</label>
                    <input type="number" id="chunkX" min="1" max="64" value="4">
                </div>

                <div class="control-group">
                    <label for="chunkY">Chunk Size Y</label>
                    <input type="number" id="chunkY" min="1" max="64" value="4">
                </div>

                <div class="control-group z-control" id="chunkZGroup">
                    <label for="chunkZ">Chunk Size Z</label>
                    <input type="number" id="chunkZ" min="1" max="16" value="1">
                </div>

                <div class="control-group">
                    <label for="chunkAlgorithm">Chunk Linearization</label>
                    <select id="chunkAlgorithm">
                        <option value="row-major">Row-Major</option>
                        <option value="col-major">Column-Major</option>
                        <option value="z-order">Z-Order (Morton)</option>
                        <option value="hilbert">Hilbert Curve</option>
                    </select>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Query Region</div>
                <div class="range-group">
                    <label for="queryX1">X:</label>
                    <input type="number" id="queryX1" min="0" value="3">
                    <span>to</span>
                    <input type="number" id="queryX2" min="0" value="10">
                </div>
                <div class="range-group">
                    <label for="queryY1">Y:</label>
                    <input type="number" id="queryY1" min="0" value="3">
                    <span>to</span>
                    <input type="number" id="queryY2" min="0" value="10">
                </div>
                <div class="range-group z-control" id="zRange">
                    <label for="queryZ1">Z:</label>
                    <input type="number" id="queryZ1" min="0" value="0">
                    <span>to</span>
                    <input type="number" id="queryZ2" min="0" value="0">
                </div>
            </div>
        </div>

    </div>

    <div class="section-container">
        <h2>Performance Metrics</h2>
        <div class="metrics">
            <div class="metric">
                <div class="metric-label">Requested Cells</div>
                <div class="metric-value" id="requested-cells">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Cells Read</div>
                <div class="metric-value" id="actual-cells">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Read Amplification</div>
                <div class="metric-value" id="amplification">1.0<span class="metric-suffix">x</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Read Efficiency</div>
                <div class="metric-value" id="efficiency">100<span class="metric-suffix">%</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Chunks Touched</div>
                <div class="metric-value" id="chunks-touched">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Range Reads</div>
                <div class="metric-value" id="byte-ranges">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Coalescing Factor</div>
                <div class="metric-value" id="coalescing-factor">1.0<span class="metric-suffix">x</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Storage Alignment</div>
                <div class="metric-value" id="storage-alignment">1.0</div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>Simulation Visualizations</h2>
        <div class="spatial-views">
            <div class="viz-panel">
                <div class="viz-title">Array Cells</div>
                <div class="canvas-container">
                    <canvas id="spatial-unchunked"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color gradient-legend"></div>
                        <span>Linearization Order</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color query-legend"></div>
                        <span>Query Region</span>
                    </div>
                </div>
            </div>

            <div class="viz-panel">
                <div class="viz-title">Array Chunks</div>
                <div class="canvas-container">
                    <canvas id="spatial-chunked"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color gradient-legend"></div>
                        <span>Linearization Order</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color query-legend"></div>
                        <span>Chunks to Read</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="linear-views">
            <div class="linear-viz">
                <div class="viz-title">Storage Linearization — Cells</div>
                <div class="canvas-container">
                    <canvas id="linear-unchunked"></canvas>
                </div>
            </div>

            <div class="linear-viz">
                <div class="viz-title">Storage Linearization — Chunks</div>
                <div class="canvas-container">
                    <canvas id="linear-chunked"></canvas>
                </div>
            </div>
        </div>
    </div>
        </div>

    <div class="tooltip" id="tooltip"></div>

    <div class="content-wrapper explanation">
        <h2>How to Interpret the Visualizations</h2>

        <div class="explanation-content">
            <div class="explanation-section">
                <h3>Color Coding</h3>
                <p><span class="color-example gradient-example"></span><strong>Green to Red Gradient:</strong> Shows the linearization order from first (green) to last (red) in memory. This helps you understand how different algorithms arrange data sequentially.</p>

                <p><span class="color-example highlight-blue"></span><strong>Blue Highlights:</strong> Indicate query regions and all cells that need to be read to satisfy the query. This includes both requested cells and extra cells read due to chunking.</p>

                <p><span class="color-example highlight-white"></span><strong>White Overlays:</strong> Show currently hovered elements. Direct hovers have both overlay and outline, while cross-highlighted elements show only the overlay.</p>
            </div>

            <div class="explanation-section">
                <h3>Array Views (Top Row)</h3>
                <p><strong>Left - Logical Array:</strong> Shows how individual cells are organized and linearized within chunks. Each cell's color represents its position in the combined linearization order.</p>

                <p><strong>Right - Chunked Array:</strong> Displays chunk-level organization where all cells in the same chunk share the same color. This shows how chunks are linearized relative to each other.</p>

                <p><strong>Interactive Cross-highlighting:</strong> Hovering in one view highlights corresponding elements in all other views, helping you trace relationships between logical and physical layouts.</p>
            </div>

            <div class="explanation-section">
                <h3>Linear Storage Views (Bottom Row)</h3>
                <p><strong>Top Linear View:</strong> Shows how data is actually stored in linear memory, with the same cell-level coloring as the logical array. Blue regions indicate cells that need to be read.</p>

                <p><strong>Bottom Linear View:</strong> Same linear layout but colored by chunks to show how chunking affects the distribution of read operations. Blue bars below show the byte ranges that need to be fetched.</p>

                <p><strong>Byte Range Indicators:</strong> Lines below each linear view show how many separate read operations are required - fewer ranges mean better I/O performance.</p>
            </div>

            <div class="explanation-section">
                <h3>Performance Metrics</h3>
                <p><strong>Requested Cells:</strong> The number of cells in your query region that you actually want to read.</p>

                <p><strong>Actual Cells Read:</strong> The total number of cells that must be read due to chunking, including both requested and extra cells.</p>

                <p><strong>Read Amplification:</strong> Shows how much extra data you read due to chunking. Values > 1.0 indicate wasted bandwidth. Lower is better.</p>

                <p><strong>Read Efficiency:</strong> Percentage of useful data in each read operation. Higher percentages indicate better performance with less wasted I/O.</p>

                <p><strong>Chunks Touched:</strong> How many chunks intersect with your query region. Fewer chunks generally mean more efficient access patterns.</p>

                <p><strong>Range Reads:</strong> Number of separate read operations needed. Fewer range reads reduce I/O overhead and improve performance.</p>

                <p><strong>Coalescing Factor:</strong> Shows how much read coalescing improves I/O efficiency compared to worst-case (chunks touched ÷ range reads). Values > 1.0 indicate that multiple chunks are being read in fewer operations due to spatial locality.</p>
                <p><strong>Storage Alignment:</strong> Overall measure of how well your query aligns with the storage layout, combining read efficiency and coalescing. Higher values indicate better alignment between your access pattern and chunking strategy.</p>
            </div>

            <div class="explanation-section">
                <h3>Algorithm Comparison</h3>
                <p><strong>Row-Major:</strong> Best for queries that access consecutive rows. Common in C/C++ and most programming languages.</p>

                <p><strong>Column-Major:</strong> Optimal for column-wise access patterns. Used in Fortran, R, and some scientific computing applications.</p>

                <p><strong>Z-Order (Morton):</strong> Space-filling curve that preserves spatial locality well. Good for 2D range queries and spatial databases.</p>

                <p><strong>Hilbert Curve:</strong> Optimal space-filling curve with the best spatial locality preservation. Excellent for 2D spatial queries but more complex to compute.</p>
            </div>

            <div class="explanation-section">
                <h3>Optimization Tips</h3>
                <p><strong>Match Access Patterns:</strong> Choose linearization algorithms that align with how your application accesses data most frequently.</p>

                <p><strong>Chunk Size Balance:</strong> Larger chunks reduce metadata overhead but may increase read amplification. Smaller chunks provide finer granularity but more management overhead.</p>

                <p><strong>Query Shape Matters:</strong> Square queries often work best with space-filling curves, while rectangular queries may favor row/column-major ordering.</p>

                <p><strong>Monitor Metrics:</strong> Use the real-time metrics to compare different configurations and find the optimal balance for your specific use case.</p>
            </div>
        </div>
    </div>

    <script>
        // Configuration constants
        const CONFIG = {
            MAX_CANVAS_SIZE: 400,      // Maximum canvas size in pixels
            MIN_CELL_SIZE: 2,          // Minimum cell size for drawing details
            VIEWPORT_CELL_SIZE: 8,     // Cell size threshold for viewport rendering
            LRU_CONFIG_CACHE_SIZE: 50, // Max number of recent configurations to cache (for chunk/cell mappings)
            LRU_DETAIL_CACHE_SIZE: 20000, // Max number of recent detail items to cache (colors, coordinates)
            RESIZE_DEBOUNCE_MS: 150    // Debounce timeout for resize events
        };

        class LRUCache {
            constructor(maxSize) {
                this.maxSize = maxSize;
                this.cache = new Map();
            }

            get(key) {
                const item = this.cache.get(key);
                if (item) {
                    // Refresh it by deleting and re-setting
                    this.cache.delete(key);
                    this.cache.set(key, item);
                }
                return item;
            }

            set(key, value) {
                // Delete old entry if it exists to refresh its position
                if (this.cache.has(key)) {
                    this.cache.delete(key);
                }
                // If the cache is full, evict the least recently used item
                else if (this.cache.size >= this.maxSize && this.maxSize > 0) {
                    // .keys().next().value gets the first (oldest) key in the Map
                    this.cache.delete(this.cache.keys().next().value);
                }
                this.cache.set(key, value);
            }

            has(key) {
                return this.cache.has(key);
            }

            clear() {
                this.cache.clear();
            }
        }

        const PRESET_CONFIGS = {
            'small-tiles': {
                name: 'Small Tiles vs Large Query',
                cellAlgorithm: 'row-major',
                chunkAlgorithm: 'row-major',
                sizeX: 32, sizeY: 32, sizeZ: 1,
                chunkX: 2, chunkY: 2, chunkZ: 1,
                queryX1: 8, queryX2: 24, queryY1: 8, queryY2: 24,
                queryZ1: 0, queryZ2: 0
            },
            'large-tiles': {
                name: 'Large Tiles vs Small Query',
                cellAlgorithm: 'row-major',
                chunkAlgorithm: 'row-major',
                sizeX: 32, sizeY: 32, sizeZ: 1,
                chunkX: 16, chunkY: 16, chunkZ: 1,
                queryX1: 10, queryX2: 14, queryY1: 10, queryY2: 14,
                queryZ1: 0, queryZ2: 0
            },
            'row-vs-col': {
                name: 'Row-Major vs Column-Major',
                cellAlgorithm: 'col-major',
                chunkAlgorithm: 'row-major',
                sizeX: 16, sizeY: 16, sizeZ: 1,
                chunkX: 4, chunkY: 8, chunkZ: 1,
                queryX1: 2, queryX2: 6, queryY1: 4, queryY2: 12,
                queryZ1: 0, queryZ2: 0
            },
            'spatial-locality': {
                name: 'Spatial Locality Comparison',
                cellAlgorithm: 'hilbert',
                chunkAlgorithm: 'hilbert',
                sizeX: 16, sizeY: 16, sizeZ: 1,
                chunkX: 4, chunkY: 4, chunkZ: 1,
                queryX1: 6, queryX2: 9, queryY1: 6, queryY2: 9,
                queryZ1: 0, queryZ2: 0
            },
            'fragmentation': {
                name: 'High Fragmentation Scenario',
                cellAlgorithm: 'z-order',
                chunkAlgorithm: 'col-major',
                sizeX: 20, sizeY: 20, sizeZ: 1,
                chunkX: 3, chunkY: 3, chunkZ: 1,
                queryX1: 1, queryX2: 18, queryY1: 5, queryY2: 7,
                queryZ1: 0, queryZ2: 0
            },
            'perfect-alignment': {
                name: 'Perfect Chunk Alignment',
                cellAlgorithm: 'row-major',
                chunkAlgorithm: 'row-major',
                sizeX: 16, sizeY: 16, sizeZ: 1,
                chunkX: 4, chunkY: 4, chunkZ: 1,
                queryX1: 4, queryX2: 7, queryY1: 4, queryY2: 7,
                queryZ1: 0, queryZ2: 0
            }
        };

        const DEFAULT_USER_SETTINGS = {
            cellAlgorithm: 'row-major',
            chunkAlgorithm: 'row-major',
            sizeX: 16,
            sizeY: 16,
            sizeZ: 1,
            chunkX: 4,
            chunkY: 4,
            chunkZ: 1,
            queryX1: 3,
            queryX2: 10,
            queryY1: 3,
            queryY2: 10,
            queryZ1: 0,
            queryZ2: 0
        };

        const DEFAULT_APP_STATE = {
            currentPreset: 'user',
            presets: {
                user: DEFAULT_USER_SETTINGS
                // Other preset states get copied here as user modifies them
            }
        };

        class TooltipManager {
            constructor(tooltipElement) {
                this.tooltip = tooltipElement;
            }

            show(e, content) {
                this.tooltip.style.display = 'block';
                this.tooltip.style.position = 'absolute';
                this.tooltip.style.left = `${e.clientX + window.scrollX + 10}px`;
                this.tooltip.style.top = `${e.clientY + window.scrollY - 30}px`;
                this.tooltip.style.transform = 'none';
                this.tooltip.style.margin = '0';
                this.tooltip.textContent = content;
            }

            hide() {
                this.tooltip.style.display = 'none';
            }

            updateContent(content) {
                this.tooltip.textContent = content;
            }

            updatePosition(e) {
                if (this.tooltip.style.display === 'block') {
                    this.tooltip.style.left = `${e.clientX + window.scrollX + 10}px`;
                    this.tooltip.style.top = `${e.clientY + window.scrollY - 30}px`;
                }
            }
        }

        class SelectionState {
            constructor() {
                this.hoveredCell = null;
                this.hoveredChunk = null;
                this.selectedCell = null;
                this.selectedChunk = null;
            }

            setHoveredCell(cell) {
                this.hoveredCell = cell;
            }

            setHoveredChunk(chunk) {
                this.hoveredChunk = chunk;
            }

            setSelectedCell(cell) {
                this.selectedCell = cell;
            }

            setSelectedChunk(chunk) {
                this.selectedChunk = chunk;
            }

            clearHover() {
                this.hoveredCell = null;
                this.hoveredChunk = null;
            }

            clearSelection() {
                this.selectedCell = null;
                this.selectedChunk = null;
            }

            clearAll() {
                this.clearHover();
                this.clearSelection();
            }

            getEffectiveCell() {
                return this.selectedCell || this.hoveredCell;
            }

            getEffectiveChunk() {
                return this.selectedChunk || this.hoveredChunk;
            }

            isSelected(cell, chunk) {
                const sameCell = cell && this.selectedCell &&
                    cell.x === this.selectedCell.x && cell.y === this.selectedCell.y;
                const sameChunk = chunk && this.selectedChunk &&
                    chunk.x === this.selectedChunk.x && chunk.y === this.selectedChunk.y;
                return sameCell || sameChunk;
            }

            hasSelection() {
                return this.selectedCell || this.selectedChunk;
            }
        }

        class CoordinateUtils {
            static getCanvasCoordinates(e, canvas) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

            static getSpatialCellCoordinates(canvasX, canvasY, canvas, params) {
                const [sizeX, sizeY] = params.size;
                const cellSize = Math.min(canvas.width / sizeX, canvas.height / sizeY) * 0.9;
                const offsetX = (canvas.width - sizeX * cellSize) / 2;
                const offsetY = (canvas.height - sizeY * cellSize) / 2;
                
                const cellX = Math.floor((canvasX - offsetX) / cellSize);
                const cellY = Math.floor((canvasY - offsetY) / cellSize);
                
                return {
                    cellX,
                    cellY,
                    isValid: cellX >= 0 && cellX < sizeX && cellY >= 0 && cellY < sizeY
                };
            }

            static getLinearCellCoordinates(canvasX, canvasY, canvas, data) {
                const logicalWidth = canvas.width / (window.devicePixelRatio || 1);
                const logicalHeight = canvas.height / (window.devicePixelRatio || 1);
                const cellWidth = (logicalWidth - 40) / data.totalCells;
                const offsetX = 20;
                const barHeight = 60;
                const offsetY = 20;
                
                const dpr = window.devicePixelRatio || 1;
                const logicalX = canvasX / dpr;
                const logicalY = canvasY / dpr;
                
                const isInBar = logicalY >= offsetY && logicalY <= offsetY + barHeight;
                const cellIndex = Math.floor((logicalX - offsetX) / cellWidth);
                const isValidIndex = cellIndex >= 0 && cellIndex < data.totalCells;
                
                return {
                    cellIndex,
                    isValid: isInBar && isValidIndex
                };
            }

            static getChunkBounds(chunkCX, chunkCY, chunkX, chunkY, sizeX, sizeY) {
                const startX = chunkCX * chunkX;
                const startY = chunkCY * chunkY;
                const endX = Math.min(startX + chunkX, sizeX);
                const endY = Math.min(startY + chunkY, sizeY);
                return { startX, startY, endX, endY };
            }

            static getChunkCoordinatesFromCell(cellX, cellY, chunkX, chunkY) {
                return {
                    x: Math.floor(cellX / chunkX),
                    y: Math.floor(cellY / chunkY)
                };
            }
        }

        class TooltipContentGenerator {
            static generateCellTooltip(cell, params, visualizer) {
                const intraChunkPos = visualizer.getIntraChunkPosition(cell.x, cell.y, 0, params);
                const globalPos = visualizer.getGlobalPosition(cell.x, cell.y, 0, params);
                return `Cell (${cell.x}, ${cell.y}) → Intra-chunk: ${intraChunkPos}, Global: ${globalPos}`;
            }

            static generateChunkTooltip(chunk, params, sizeX, sizeY, chunkX, chunkY, visualizer) {
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunkIdx = chunk.x + chunk.y * chunksX;
                const bounds = CoordinateUtils.getChunkBounds(chunk.x, chunk.y, chunkX, chunkY, sizeX, sizeY);
                const interChunkPos = visualizer.getInterChunkPosition(bounds.startX, bounds.startY, 0, params);
                
                return `Chunk ${chunkIdx}: cells (${bounds.startX},${bounds.startY}) to (${bounds.endX - 1},${bounds.endY - 1}), Linear pos: ${interChunkPos}`;
            }
        }

        class BaseCanvasRenderer {
            constructor(canvas, context) {
                this.canvas = canvas;
                this.ctx = context;
            }

            getLogicalDimensions() {
                return {
                    width: this.canvas.width / (window.devicePixelRatio || 1),
                    height: this.canvas.height / (window.devicePixelRatio || 1)
                };
            }

            clearCanvas() {
                const { width, height } = this.getLogicalDimensions();
                this.ctx.clearRect(0, 0, width, height);
            }

            drawCellHighlight(x, y, cellSize, offsetX, offsetY, fillStyle = 'rgba(255, 255, 255, 0.4)', strokeStyle = '#fff', lineWidth = 3) {
                // Highlight background
                this.ctx.fillStyle = fillStyle;
                this.ctx.fillRect(
                    offsetX + x * cellSize,
                    offsetY + y * cellSize,
                    cellSize - 1,
                    cellSize - 1
                );

                // Highlight outline
                this.ctx.strokeStyle = strokeStyle;
                this.ctx.lineWidth = lineWidth;
                this.ctx.strokeRect(
                    offsetX + x * cellSize,
                    offsetY + y * cellSize,
                    cellSize - 1,
                    cellSize - 1
                );
            }

            drawRectHighlight(startX, startY, endX, endY, cellSize, offsetX, offsetY, fillStyle = 'rgba(255, 255, 255, 0.4)', strokeStyle = '#fff', lineWidth = 3) {
                const width = (endX - startX) * cellSize - 1;
                const height = (endY - startY) * cellSize - 1;

                // Highlight background
                if (fillStyle) {
                    this.ctx.fillStyle = fillStyle;
                    this.ctx.fillRect(offsetX + startX * cellSize, offsetY + startY * cellSize, width, height);
                }

                // Highlight outline
                if (strokeStyle) {
                    this.ctx.strokeStyle = strokeStyle;
                    this.ctx.lineWidth = lineWidth;
                    this.ctx.strokeRect(offsetX + startX * cellSize, offsetY + startY * cellSize, width, height);
                }
            }

            drawQueryRegionOutline(query, sizeX, sizeY, cellSize, offsetX, offsetY) {
                this.ctx.strokeStyle = '#4a9eff';
                this.ctx.lineWidth = 3;
                const x1 = Math.max(0, query.x[0]);
                const y1 = Math.max(0, query.y[0]);
                const x2 = Math.min(sizeX - 1, query.x[1]);
                const y2 = Math.min(sizeY - 1, query.y[1]);

                this.ctx.strokeRect(
                    offsetX + x1 * cellSize,
                    offsetY + y1 * cellSize,
                    (x2 - x1 + 1) * cellSize - 1,
                    (y2 - y1 + 1) * cellSize - 1
                );
            }

            getSpatialCellLayout(sizeX, sizeY) {
                const { width, height } = this.getLogicalDimensions();
                const cellSize = Math.min(width / sizeX, height / sizeY) * 0.9;
                const offsetX = (width - sizeX * cellSize) / 2;
                const offsetY = (height - sizeY * cellSize) / 2;
                return { cellSize, offsetX, offsetY };
            }

            getLinearBarLayout(totalCells) {
                const { width } = this.getLogicalDimensions();
                const cellWidth = (width - 40) / totalCells;
                const barHeight = 60;
                const offsetX = 20;
                const offsetY = 20;
                return { cellWidth, barHeight, offsetX, offsetY };
            }

            drawLinearBar(cellWidth, barHeight, offsetX, offsetY, totalCells, getColorForPosition) {
                if (cellWidth < 1) {
                    this.drawLinearGradientBar(offsetX, offsetY, totalCells * cellWidth, barHeight);
                } else {
                    this.drawLinearCellBar(cellWidth, barHeight, offsetX, offsetY, totalCells, getColorForPosition);
                }
            }

            drawLinearGradientBar(offsetX, offsetY, width, barHeight) {
                const gradient = this.ctx.createLinearGradient(offsetX, offsetY, offsetX + width, offsetY);
                gradient.addColorStop(0, '#00ff00');
                gradient.addColorStop(1, '#ff0000');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(offsetX, offsetY, width, barHeight);
            }

            drawLinearCellBar(cellWidth, barHeight, offsetX, offsetY, totalCells, getColorForPosition) {
                for (let i = 0; i < totalCells; i++) {
                    const color = getColorForPosition(i, totalCells);
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(offsetX + i * cellWidth, offsetY, cellWidth, barHeight);
                }
            }

            drawByteRanges(ranges, cellWidth, barHeight, offsetX, offsetY, label) {
                const { width } = this.getLogicalDimensions();
                
                this.ctx.strokeStyle = '#4a9eff';
                this.ctx.lineWidth = 2;
                
                ranges.forEach(([start, end]) => {
                    const x1 = offsetX + start * cellWidth;
                    const x2 = offsetX + (end + 1) * cellWidth;

                    // Draw range line
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, offsetY + barHeight + 5);
                    this.ctx.lineTo(x2, offsetY + barHeight + 5);
                    this.ctx.stroke();

                    // Draw range markers
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, offsetY + barHeight);
                    this.ctx.lineTo(x1, offsetY + barHeight + 10);
                    this.ctx.moveTo(x2, offsetY + barHeight);
                    this.ctx.lineTo(x2, offsetY + barHeight + 10);
                    this.ctx.stroke();
                });

                // Draw label
                this.ctx.fillStyle = '#aaa';
                this.ctx.font = '11px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`${ranges.length} ${label}`, width / 2, offsetY + barHeight + 25);
            }

            highlightLinearCells(cellPositions, cellWidth, barHeight, offsetX, offsetY, fillStyle = 'rgba(74, 158, 255, 0.5)') {
                this.ctx.fillStyle = fillStyle;
                cellPositions.forEach(pos => {
                    this.ctx.fillRect(offsetX + pos * cellWidth, offsetY, cellWidth, barHeight);
                });
            }

            drawLinearChunkHighlight(chunkRange, cellWidth, barHeight, offsetX, offsetY, showOutline = false) {
                if (!chunkRange) return;

                const chunkCellCount = chunkRange.positions.length;
                const chunkPixelWidth = chunkCellCount * cellWidth;

                // Background highlight
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.fillRect(offsetX + chunkRange.min * cellWidth, offsetY, chunkPixelWidth, barHeight);

                // Outline if requested
                if (showOutline) {
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(offsetX + chunkRange.min * cellWidth, offsetY, chunkPixelWidth, barHeight);
                }
            }
        }

        class InteractionManager {
            constructor(visualizer, canvases, tooltipManager) {
                this.visualizer = visualizer;
                this.canvases = canvases;
                this.tooltipManager = tooltipManager;
                this.mouseThrottle = false;
            }

            handleMouseMove(e, canvasKey) {
                // Don't update anything if there's a selection - keep the selection locked
                if (this.visualizer.selectionState.hasSelection()) {
                    return;
                }

                // Throttle mouse move updates for performance
                if (this.mouseThrottle) return;
                this.mouseThrottle = true;
                requestAnimationFrame(() => {
                    this.mouseThrottle = false;
                });

                const canvas = this.canvases[canvasKey];
                const coords = CoordinateUtils.getCanvasCoordinates(e, canvas);
                const { x, y } = coords;

                const params = this.visualizer.getParameters();
                const [sizeX, sizeY, sizeZ] = params.size;
                const [chunkX, chunkY] = params.chunk;

                if (canvasKey === 'spatialUnchunked') {
                    this.handleSpatialUnchunkedMove(e, canvas, params, x, y, chunkX, chunkY);
                } else if (canvasKey === 'spatialChunked') {
                    this.handleSpatialChunkedMove(e, canvas, params, x, y, sizeX, sizeY, chunkX, chunkY);
                } else if (canvasKey.startsWith('linear')) {
                    this.handleLinearMove(e, canvas, canvasKey, params, x, y, sizeX, sizeY, chunkX, chunkY);
                }

                this.visualizer.update();
            }

            handleSpatialUnchunkedMove(e, canvas, params, x, y, chunkX, chunkY) {
                const spatialCoords = CoordinateUtils.getSpatialCellCoordinates(x, y, canvas, params);
                
                if (spatialCoords.isValid) {
                    const { cellX, cellY } = spatialCoords;
                    this.visualizer.selectionState.setHoveredCell({ x: cellX, y: cellY });
                    const chunkCoords = CoordinateUtils.getChunkCoordinatesFromCell(cellX, cellY, chunkX, chunkY);
                    this.visualizer.selectionState.setHoveredChunk(chunkCoords);
                    this.tooltipManager.show(e, TooltipContentGenerator.generateCellTooltip({ x: cellX, y: cellY }, params, this.visualizer));
                } else {
                    this.visualizer.selectionState.clearHover();
                    this.tooltipManager.hide();
                }
            }

            handleSpatialChunkedMove(e, canvas, params, x, y, sizeX, sizeY, chunkX, chunkY) {
                const spatialCoords = CoordinateUtils.getSpatialCellCoordinates(x, y, canvas, params);
                
                if (spatialCoords.isValid) {
                    const { cellX, cellY } = spatialCoords;
                    const chunkCoords = CoordinateUtils.getChunkCoordinatesFromCell(cellX, cellY, chunkX, chunkY);
                    this.visualizer.selectionState.setHoveredChunk(chunkCoords);
                    this.visualizer.selectionState.setHoveredCell(null);
                    this.tooltipManager.show(e, TooltipContentGenerator.generateChunkTooltip(chunkCoords, params, sizeX, sizeY, chunkX, chunkY, this.visualizer));
                } else {
                    this.visualizer.selectionState.setHoveredChunk(null);
                    this.tooltipManager.hide();
                }
            }

            handleLinearMove(e, canvas, canvasKey, params, x, y, sizeX, sizeY, chunkX, chunkY) {
                const data = this.visualizer.currentData;
                if (!data) return;

                const linearCoords = CoordinateUtils.getLinearCellCoordinates(x, y, canvas, data);
                
                if (linearCoords.isValid) {
                    const { cellIndex } = linearCoords;
                    const foundCell = this.visualizer.getCellFromLinearIndex(cellIndex, params, sizeX, sizeY, chunkX, chunkY);

                    if (foundCell) {
                        if (canvasKey === 'linearUnchunked') {
                            this.visualizer.selectionState.setHoveredCell({ x: foundCell.x, y: foundCell.y });
                            this.visualizer.selectionState.setHoveredChunk({ x: foundCell.chunkX, y: foundCell.chunkY });
                            this.tooltipManager.show(e, TooltipContentGenerator.generateCellTooltip({ x: foundCell.x, y: foundCell.y }, params, this.visualizer));
                        } else {
                            this.visualizer.selectionState.setHoveredCell(null);
                            this.visualizer.selectionState.setHoveredChunk({ x: foundCell.chunkX, y: foundCell.chunkY });
                            this.tooltipManager.show(e, TooltipContentGenerator.generateChunkTooltip({ x: foundCell.chunkX, y: foundCell.chunkY }, params, sizeX, sizeY, chunkX, chunkY, this.visualizer));
                        }
                    } else {
                        this.visualizer.selectionState.clearHover();
                        this.tooltipManager.hide();
                    }
                } else {
                    this.visualizer.selectionState.clearHover();
                    this.tooltipManager.hide();
                }
            }

            handleMouseLeave() {
                this.visualizer.selectionState.clearHover();
                this.tooltipManager.hide();
                // Use requestAnimationFrame for smoother updates
                if (this.visualizer.updatePending) return;
                this.visualizer.updatePending = true;
                requestAnimationFrame(() => {
                    this.visualizer.updatePending = false;
                    this.visualizer.update();
                });
            }

            handleMouseClick(e, canvasKey) {
                const canvas = this.canvases[canvasKey];
                const coords = CoordinateUtils.getCanvasCoordinates(e, canvas);
                const { x, y } = coords;

                const params = this.visualizer.getParameters();
                const [sizeX, sizeY, sizeZ] = params.size;
                const [chunkX, chunkY] = params.chunk;

                const { clickedCell, clickedChunk } = this.getClickTargets(canvasKey, canvas, x, y, params, sizeX, sizeY, chunkX, chunkY);

                this.handleSelectionLogic(e, clickedCell, clickedChunk, params, sizeX, sizeY, chunkX, chunkY);
                this.visualizer.update();
            }

            getClickTargets(canvasKey, canvas, x, y, params, sizeX, sizeY, chunkX, chunkY) {
                let clickedCell = null;
                let clickedChunk = null;

                if (canvasKey === 'spatialUnchunked') {
                    const spatialCoords = CoordinateUtils.getSpatialCellCoordinates(x, y, canvas, params);
                    if (spatialCoords.isValid) {
                        const { cellX, cellY } = spatialCoords;
                        clickedCell = { x: cellX, y: cellY };
                        clickedChunk = CoordinateUtils.getChunkCoordinatesFromCell(cellX, cellY, chunkX, chunkY);
                    }
                } else if (canvasKey === 'spatialChunked') {
                    const spatialCoords = CoordinateUtils.getSpatialCellCoordinates(x, y, canvas, params);
                    if (spatialCoords.isValid) {
                        const { cellX, cellY } = spatialCoords;
                        clickedChunk = CoordinateUtils.getChunkCoordinatesFromCell(cellX, cellY, chunkX, chunkY);
                    }
                } else if (canvasKey.startsWith('linear')) {
                    const data = this.visualizer.currentData;
                    if (data) {
                        const linearCoords = CoordinateUtils.getLinearCellCoordinates(x, y, canvas, data);
                        if (linearCoords.isValid) {
                            const { cellIndex } = linearCoords;
                            const foundCell = this.visualizer.getCellFromLinearIndex(cellIndex, params, sizeX, sizeY, chunkX, chunkY);
                            if (foundCell) {
                                if (canvasKey === 'linearUnchunked') {
                                    clickedCell = { x: foundCell.x, y: foundCell.y };
                                }
                                clickedChunk = { x: foundCell.chunkX, y: foundCell.chunkY };
                            }
                        }
                    }
                }

                return { clickedCell, clickedChunk };
            }

            handleSelectionLogic(e, clickedCell, clickedChunk, params, sizeX, sizeY, chunkX, chunkY) {
                if (clickedCell || clickedChunk) {
                    // Check if clicking on already selected item to deselect
                    if (this.visualizer.selectionState.isSelected(clickedCell, clickedChunk)) {
                        this.visualizer.selectionState.clearSelection();
                        this.tooltipManager.hide();
                    } else {
                        // Select new item
                        this.visualizer.selectionState.setSelectedCell(clickedCell);
                        this.visualizer.selectionState.setSelectedChunk(clickedChunk);

                        // Update tooltip content
                        if (clickedCell) {
                            this.tooltipManager.show(e, TooltipContentGenerator.generateCellTooltip(clickedCell, params, this.visualizer));
                        } else if (clickedChunk) {
                            this.tooltipManager.show(e, TooltipContentGenerator.generateChunkTooltip(clickedChunk, params, sizeX, sizeY, chunkX, chunkY, this.visualizer));
                        }
                    }
                } else {
                    // Clicked outside any item - clear selection
                    this.visualizer.selectionState.clearSelection();
                    this.tooltipManager.hide();
                }
            }
        }

        class DataVisualizer {
            constructor() {
                this.selectionState = new SelectionState();
                this.lastCanvasSize = new Map();

                // Initialize caches with LRU policy
                this.linearizationCache = new LRUCache(CONFIG.LRU_DETAIL_CACHE_SIZE);
                this.positionCache = new LRUCache(CONFIG.LRU_DETAIL_CACHE_SIZE);
                this.chunkPositionCache = new LRUCache(CONFIG.LRU_CONFIG_CACHE_SIZE);
                this.cellPositionCache = new LRUCache(CONFIG.LRU_CONFIG_CACHE_SIZE);
                this.colorCache = new LRUCache(CONFIG.LRU_DETAIL_CACHE_SIZE);

                // Initialize app state after loading from localStorage
                this.loadSettings();
                this.initializeControls();
                this.initializeCanvases();
                this.renderUI();
                this.update();
            }


            getCellFromLinearIndex(cellIndex, params, sizeX, sizeY, chunkX, chunkY) {
                for (let cy = 0; cy < sizeY; cy++) {
                    for (let cx = 0; cx < sizeX; cx++) {
                        const globalPos = this.getGlobalPosition(cx, cy, 0, params);
                        if (globalPos === cellIndex) {
                            return { 
                                x: cx, 
                                y: cy,
                                chunkX: Math.floor(cx / chunkX),
                                chunkY: Math.floor(cy / chunkY)
                            };
                        }
                    }
                }
                return null;
            }

            setState(newState) {
                const oldState = { ...this.state };
                this.state = { ...this.state, ...newState };

                // Caches are now managed by LRU policy.
                // Clearing them on every structural change would prevent the performance benefit
                // of switching back and forth between recent settings.
                const structuralChanges = ['cellAlgorithm', 'chunkAlgorithm', 'sizeX', 'sizeY', 'sizeZ', 'chunkX', 'chunkY', 'chunkZ'];
                const hasStructuralChanges = structuralChanges.some(key =>
                    key in newState && oldState[key] !== newState[key]
                );

                // The clearCaches method is kept in case a full reset is ever needed,
                // but it's no longer called on every settings change.
                // if (hasStructuralChanges) {
                //     this.clearCaches();
                // }
            }

            // Full UI update cycle - call this after setState() when you want to update the display
            updateUI() {
                this.renderUI();
                this.updateDOMConstraints();
                this.updateResetButton();
                this.updatePresetDisplay();
                this.update();
            }

            // Update HTML form constraints based on current state (no state changes)
            updateDOMConstraints() {
                const { sizeX, sizeY, sizeZ } = this.state;

                document.getElementById('chunkX').max = sizeX;
                document.getElementById('chunkY').max = sizeY;
                document.getElementById('chunkZ').max = Math.max(1, sizeZ);

                document.getElementById('queryX1').max = Math.max(0, sizeX - 1);
                document.getElementById('queryX2').max = Math.max(0, sizeX - 1);
                document.getElementById('queryY1').max = Math.max(0, sizeY - 1);
                document.getElementById('queryY2').max = Math.max(0, sizeY - 1);
                document.getElementById('queryZ1').max = Math.max(0, sizeZ - 1);
                document.getElementById('queryZ2').max = Math.max(0, sizeZ - 1);
            }

            // Sync UI elements to match current state
            renderUI() {
                Object.keys(this.state).forEach(key => {
                    if (key === 'currentPreset') {
                        const presetsEl = document.getElementById('presets');
                        if (presetsEl) presetsEl.value = this.state[key];
                    } else {
                        const element = document.getElementById(key);
                        if (element) element.value = this.state[key];
                    }
                });
            }

            // Clear all caches when structural changes occur
            clearCaches() {
                this.linearizationCache.clear();
                this.positionCache.clear();
                if (this.chunkPositionCache) this.chunkPositionCache.clear();
                if (this.cellPositionCache) this.cellPositionCache.clear();
                if (this.colorCache) this.colorCache.clear();
            }

            populatePresetOptions() {
                const presetsSelect = document.getElementById('presets');

                // Add preset options dynamically
                Object.keys(PRESET_CONFIGS).forEach(presetKey => {
                    const option = document.createElement('option');
                    option.value = presetKey;
                    option.textContent = this.getPresetDisplayName(presetKey, true);
                    presetsSelect.appendChild(option);
                });
            }

            initializeControls() {
                // Populate preset options
                this.populatePresetOptions();

                const controls = ['cellAlgorithm', 'chunkAlgorithm', 'sizeX', 'sizeY', 'sizeZ',
                                 'chunkX', 'chunkY', 'chunkZ',
                                 'queryX1', 'queryX2', 'queryY1', 'queryY2',
                                 'queryZ1', 'queryZ2'];

                controls.forEach(id => {
                    const element = document.getElementById(id);
                    element.addEventListener('change', (e) => {
                        let value = e.target.type === 'number' ?
                            parseInt(e.target.value) :
                            e.target.value;

                        // Validate numeric inputs
                        if (e.target.type === 'number') {
                            if (isNaN(value)) {
                                console.warn(`Invalid input value: ${e.target.value}, resetting to 1`);
                                value = 1;
                            } else {
                                // Apply proper constraints based on field type
                                if (id.startsWith('size') || id.startsWith('chunk')) {
                                    value = Math.max(1, value); // Dimensions and chunk sizes must be >= 1
                                } else {
                                    value = Math.max(0, value); // Query ranges can start at 0
                                }

                                // Apply upper limits
                                if (id.startsWith('size')) value = Math.min(value, 64); // Cap array sizes
                                if (id === 'sizeZ') value = Math.min(value, 16); // Cap Z dimension
                            }
                        }

                        this.setState({ [id]: value });
                        this.updateUI();
                        this.saveSettings(); // Explicit save for user input
                    });
                });

                // Add preset handler
                document.getElementById('presets').addEventListener('change', (e) => {
                    this.loadPreset(e.target.value);
                    this.saveSettings(); // Save when user explicitly changes preset
                });

                // Add reset button handler
                document.getElementById('resetButton').addEventListener('click', () => {
                    this.resetSettings();
                });

                this.updateConstraints();
                this.updateResetButton();
            }

            saveSettings() {
                // Save current preset settings (excluding currentPreset from the preset data)
                const currentSettings = { ...this.state };
                delete currentSettings.currentPreset;

                // Only save preset if it differs from canonical version
                const canonicalSettings = this.getCanonicalPreset(this.state.currentPreset);
                const hasChanges = canonicalSettings && Object.keys(canonicalSettings).some(key =>
                    currentSettings[key] !== canonicalSettings[key]
                );

                if (hasChanges) {
                    // Preset is modified - save it
                    this.appState.presets[this.state.currentPreset] = currentSettings;
                } else {
                    // Preset matches canonical - remove any saved version
                    delete this.appState.presets[this.state.currentPreset];
                }

                // Always save the current preset selection
                this.appState.currentPreset = this.state.currentPreset;

                // Save entire app state
                localStorage.setItem('vischunk-app-state', JSON.stringify(this.appState));
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('vischunk-app-state');
                    if (saved) {
                        this.appState = JSON.parse(saved);
                    } else {
                        this.appState = DEFAULT_APP_STATE;
                    }
                } catch (error) {
                    console.warn('Failed to load settings from localStorage:', error);
                    this.appState = DEFAULT_APP_STATE;
                }

                // Initialize current visualization state from the selected preset
                const currentPreset = this.appState.currentPreset;
                const presetSettings = this.appState.presets[currentPreset] ||
                                     this.getCanonicalPreset(currentPreset);

                this.state = {
                    ...presetSettings,
                    currentPreset: currentPreset
                };
            }

            resetSettings() {
                const presetName = this.state.currentPreset;

                // Remove user modifications for this preset
                if (this.appState.presets[presetName]) {
                    delete this.appState.presets[presetName];
                }

                // Load canonical preset
                const canonicalSettings = this.getCanonicalPreset(presetName);
                if (canonicalSettings) {
                    this.setState({ ...canonicalSettings, currentPreset: presetName });
                    this.updateUI();
                }

                // Save the reset (removal of modifications)
                this.saveSettings();
            }

            updateResetButton() {
                const resetButton = document.getElementById('resetButton');
                const canonical = this.getCanonicalPreset(this.state.currentPreset);

                // Check if current state differs from canonical preset
                const isChanged = canonical && Object.keys(canonical).some(key =>
                    this.state[key] !== canonical[key]
                );

                resetButton.disabled = !isChanged;
                resetButton.style.opacity = isChanged ? '1' : '0.5';
            }

            // Get canonical preset settings (without user modifications)
            getCanonicalPreset(presetName) {
                if (presetName === 'user') {
                    return DEFAULT_USER_SETTINGS;
                } else if (PRESET_CONFIGS[presetName]) {
                    const { name, ...settings } = PRESET_CONFIGS[presetName];
                    return settings;
                }
                return null;
            }

            // Get current preset settings (with user modifications if they exist)
            getCurrentPresetSettings(presetName) {
                return this.appState.presets[presetName] || this.getCanonicalPreset(presetName);
            }

            // Get display name for a preset
            getPresetDisplayName(presetName, includeModificationIndicator = false) {
                let baseName = presetName === 'user' ? 'User Settings' :
                              PRESET_CONFIGS[presetName]?.name || presetName;

                if (includeModificationIndicator && this.isPresetModified(presetName)) {
                    baseName += ' *';
                }

                return baseName;
            }

            isPresetModified(presetName) {
                if (presetName === 'user') {
                    // User preset is never shown as "modified" since it's inherently custom
                    return false;
                } else if (PRESET_CONFIGS[presetName]) {
                    // Named presets are modified if they exist in appState.presets
                    return !!(this.appState && this.appState.presets && this.appState.presets[presetName]);
                }

                return false;
            }

            updatePresetDisplay() {
                const presetsSelect = document.getElementById('presets');

                // Update all preset option text to show/hide asterisks
                presetsSelect.querySelectorAll('option').forEach(option => {
                    option.textContent = this.getPresetDisplayName(option.value, true);
                });
            }

            loadPreset(presetName) {
                // Update app state to track current preset selection
                this.appState.currentPreset = presetName;

                const presetSettings = this.getCurrentPresetSettings(presetName);
                if (presetSettings) {
                    this.setState({ ...presetSettings, currentPreset: presetName });
                    this.updateUI();
                }

                // Only save when this is a user-initiated preset change, not during initialization
                // The preset selection is already tracked in this.appState.currentPreset
                // and will be saved when the user makes actual changes
            }

            updateConstraints() {

                // Validate and clamp state values to reasonable limits
                let updates = {};
                let { sizeX, sizeY, sizeZ, chunkX, chunkY, chunkZ, queryX1, queryX2, queryY1, queryY2, queryZ1, queryZ2 } = this.state;

                // Cap dimensions to prevent browser lockup
                if (sizeX > 64) { updates.sizeX = 64; sizeX = 64; }
                if (sizeY > 64) { updates.sizeY = 64; sizeY = 64; }
                if (sizeZ > 16) { updates.sizeZ = 16; sizeZ = 16; }

                // Also prevent total cells from being too large
                const totalCells = sizeX * sizeY * Math.max(1, sizeZ);
                if (totalCells > 4096) {
                    // Reset to safer defaults if total is too large
                    updates.sizeX = 32; sizeX = 32;
                    updates.sizeY = 32; sizeY = 32;
                    updates.sizeZ = 1; sizeZ = 1;
                }

                // Clamp chunk sizes to valid ranges
                if (chunkX > sizeX) { updates.chunkX = sizeX; chunkX = sizeX; }
                if (chunkY > sizeY) { updates.chunkY = sizeY; chunkY = sizeY; }
                if (chunkZ > sizeZ) { updates.chunkZ = Math.max(1, sizeZ); chunkZ = Math.max(1, sizeZ); }

                // Clamp query values to valid ranges
                const maxX = sizeX - 1;
                const maxY = sizeY - 1;
                const maxZ = sizeZ - 1;

                if (queryX1 > maxX) { updates.queryX1 = Math.max(0, maxX); }
                if (queryX2 > maxX) { updates.queryX2 = Math.max(0, maxX); }
                if (queryY1 > maxY) { updates.queryY1 = Math.max(0, maxY); }
                if (queryY2 > maxY) { updates.queryY2 = Math.max(0, maxY); }
                if (queryZ1 > maxZ) { updates.queryZ1 = Math.max(0, maxZ); }
                if (queryZ2 > maxZ) { updates.queryZ2 = Math.max(0, maxZ); }

                // Handle edge cases: if array dimension is 1, set sensible defaults
                if (sizeX === 1) {
                    updates.chunkX = 1;
                    updates.queryX1 = 0;
                    updates.queryX2 = 0;
                }
                if (sizeY === 1) {
                    updates.chunkY = 1;
                    updates.queryY1 = 0;
                    updates.queryY2 = 0;
                }
                if (sizeZ === 1) {
                    updates.chunkZ = 1;
                    updates.queryZ1 = 0;
                    updates.queryZ2 = 0;
                }

                // Update DOM constraints for HTML validation
                const finalSizeX = updates.sizeX || sizeX;
                const finalSizeY = updates.sizeY || sizeY;
                const finalSizeZ = updates.sizeZ || sizeZ;

                document.getElementById('chunkX').max = finalSizeX;
                document.getElementById('chunkY').max = finalSizeY;
                document.getElementById('chunkZ').max = Math.max(1, finalSizeZ);

                document.getElementById('queryX1').max = Math.max(0, finalSizeX - 1);
                document.getElementById('queryX2').max = Math.max(0, finalSizeX - 1);
                document.getElementById('queryY1').max = Math.max(0, finalSizeY - 1);
                document.getElementById('queryY2').max = Math.max(0, finalSizeY - 1);
                document.getElementById('queryZ1').max = Math.max(0, finalSizeZ - 1);
                document.getElementById('queryZ2').max = Math.max(0, finalSizeZ - 1);

                // Apply any needed state updates
                if (Object.keys(updates).length > 0) {
                    this.setState(updates);
                    this.renderUI(); // Only update form values, don't trigger full UI cycle
                }
            }

            initializeCanvases() {
                this.canvases = {
                    spatialUnchunked: document.getElementById('spatial-unchunked'),
                    spatialChunked: document.getElementById('spatial-chunked'),
                    linearUnchunked: document.getElementById('linear-unchunked'),
                    linearChunked: document.getElementById('linear-chunked')
                };

                this.tooltipManager = new TooltipManager(document.getElementById('tooltip'));
                this.interactionManager = new InteractionManager(this, this.canvases, this.tooltipManager);

                this.contexts = {};
                for (const [key, canvas] of Object.entries(this.canvases)) {
                    this.contexts[key] = canvas.getContext('2d');

                    // Add mouse interaction for spatial and linear views
                    if (key.startsWith('spatial') || key.startsWith('linear')) {
                        canvas.addEventListener('mousemove', (e) => this.interactionManager.handleMouseMove(e, key));
                        canvas.addEventListener('mouseleave', () => this.interactionManager.handleMouseLeave());
                        canvas.addEventListener('click', (e) => this.interactionManager.handleMouseClick(e, key));
                    }
                }

                // Force initial resize after DOM is ready
                setTimeout(() => {
                    this.resizeCanvases();
                    this.update();
                }, 0);

                this.resizeCanvases();

                // Simple, efficient resize handling
                let resizeRAF = null;

                const handleResize = () => {
                    if (resizeRAF) return; // Prevent multiple concurrent updates

                    resizeRAF = requestAnimationFrame(() => {
                        const needsUpdate = this.resizeCanvases();
                        if (needsUpdate) {
                            this.update();
                        }
                        resizeRAF = null;
                    });
                };

                // Only use window resize - simpler and more reliable
                window.addEventListener('resize', handleResize);

                // Clear selection when clicking outside visualizations
                document.addEventListener('click', (e) => {
                    // Check if click was inside any canvas
                    let clickedCanvas = false;
                    for (const canvas of Object.values(this.canvases)) {
                        const rect = canvas.getBoundingClientRect();
                        if (e.clientX >= rect.left && e.clientX <= rect.right &&
                            e.clientY >= rect.top && e.clientY <= rect.bottom) {
                            clickedCanvas = true;
                            break;
                        }
                    }

                    // If clicked outside all canvases, clear selection
                    if (!clickedCanvas && this.selectionState.hasSelection()) {
                        this.selectionState.clearSelection();
                        this.tooltipManager.hide();
                        this.update();
                    }
                });
            }

            setCanvasSize(key, width, height) {
                const canvas = this.canvases[key];
                const ctx = this.contexts[key];
                const dpr = window.devicePixelRatio || 1;

                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';

                // Reset transform before scaling to prevent accumulation
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dpr, dpr);
            }

            resizeCanvases() {
                let needsUpdate = false;

                // Spatial canvases - square aspect
                ['spatialUnchunked', 'spatialChunked'].forEach(key => {
                    const canvas = this.canvases[key];
                    const canvasContainer = canvas.parentElement; // .canvas-container
                    const vizPanel = canvasContainer.parentElement; // .viz-panel
                    const containerRect = vizPanel.getBoundingClientRect();

                    // Account for viz-panel padding (15px) and canvas-container padding (10px)
                    const vizPanelPadding = 15;
                    const canvasContainerPadding = 20; // 10px on each side
                    const totalPadding = vizPanelPadding * 2 + canvasContainerPadding;

                    const availableWidth = containerRect.width - totalPadding;
                    const size = Math.min(availableWidth, CONFIG.MAX_CANVAS_SIZE);
                    const lastSize = this.lastCanvasSize.get(key);

                    if (size > 0 && (!lastSize || lastSize.width !== size || lastSize.height !== size)) {
                        this.setCanvasSize(key, size, size);
                        this.lastCanvasSize.set(key, { width: size, height: size });
                        needsUpdate = true;
                    }
                });

                // Linear canvases - full width
                ['linearUnchunked', 'linearChunked'].forEach(key => {
                    const canvas = this.canvases[key];
                    const canvasContainer = canvas.parentElement; // .canvas-container
                    const linearViz = canvasContainer.parentElement; // .linear-viz
                    const containerRect = linearViz.getBoundingClientRect();

                    // Account for linear-viz padding (15px) and canvas-container padding (10px)
                    const linearVizPadding = 15;
                    const canvasContainerPadding = 20; // 10px on each side
                    const totalPadding = linearVizPadding * 2 + canvasContainerPadding;

                    const width = containerRect.width - totalPadding;
                    const height = 120;
                    const lastSize = this.lastCanvasSize.get(key);

                    if (width > 0 && (!lastSize || lastSize.width !== width || lastSize.height !== height)) {
                        this.setCanvasSize(key, width, height);
                        this.lastCanvasSize.set(key, { width, height });
                        needsUpdate = true;
                    }
                });

                return needsUpdate;
            }

            getParameters() {
                return {
                    cellAlgorithm: this.state.cellAlgorithm,
                    chunkAlgorithm: this.state.chunkAlgorithm,
                    size: [
                        this.state.sizeX,
                        this.state.sizeY,
                        this.state.sizeZ
                    ],
                    chunk: [
                        this.state.chunkX,
                        this.state.chunkY,
                        this.state.chunkZ
                    ],
                    query: {
                        x: [this.state.queryX1, this.state.queryX2],
                        y: [this.state.queryY1, this.state.queryY2],
                        z: [this.state.queryZ1, this.state.queryZ2]
                    }
                };
            }

            linearizeCoordinate(x, y, z, sizeX, sizeY, sizeZ, algorithm) {
                const key = `${x},${y},${z},${sizeX},${sizeY},${sizeZ},${algorithm}`;
                if (this.linearizationCache.has(key)) {
                    return this.linearizationCache.get(key);
                }

                let result;

                switch(algorithm) {
                    case 'row-major':
                        result = x + y * sizeX + z * sizeX * sizeY;
                        break;

                    case 'col-major':
                        result = y + x * sizeY + z * sizeX * sizeY;
                        break;

                    case 'z-order':
                        if (sizeZ > 0) {
                            result = this.mortonEncode3D(x, y, z);
                        } else {
                            result = this.mortonEncode2D(x, y);
                        }
                        break;

                    case 'hilbert':
                        if (sizeZ > 0) {
                            // For 3D, use simple layer-based approach
                            result = z * sizeX * sizeY + this.hilbertEncode2D(x, y, Math.max(sizeX, sizeY));
                        } else {
                            result = this.hilbertEncode2D(x, y, Math.max(sizeX, sizeY));
                        }
                        break;

                    default:
                        result = x + y * sizeX + z * sizeX * sizeY;
                }

                this.linearizationCache.set(key, result);
                return result;
            }

            // Get the linearization position of a cell within its chunk
            getIntraChunkPosition(x, y, z, params) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const localX = x % chunkX;
                const localY = y % chunkY;
                const localZ = z % chunkZ;
                const rawPos = this.linearizeCoordinate(localX, localY, localZ, chunkX, chunkY, chunkZ, params.cellAlgorithm);

                // For non-sequential cell algorithms, normalize to ensure contiguous chunk ranges
                if (params.cellAlgorithm === 'z-order' || params.cellAlgorithm === 'hilbert') {
                    const cacheKey = `cell-${params.cellAlgorithm}-${chunkX}-${chunkY}-${chunkZ}`;

                    if (!this.cellPositionCache.has(cacheKey)) {
                        const allCellPositions = [];
                        for (let cz = 0; cz < Math.max(1, chunkZ); cz++) {
                            for (let cy = 0; cy < chunkY; cy++) {
                                for (let cx = 0; cx < chunkX; cx++) {
                                    const pos = this.linearizeCoordinate(cx, cy, cz, chunkX, chunkY, chunkZ, params.cellAlgorithm);
                                    allCellPositions.push(pos);
                                }
                            }
                        }
                        allCellPositions.sort((a, b) => a - b);

                        const positionMap = new Map();
                        allCellPositions.forEach((pos, seqIndex) => {
                            positionMap.set(pos, seqIndex);
                        });
                        this.cellPositionCache.set(cacheKey, positionMap);
                    }

                    const positionMap = this.cellPositionCache.get(cacheKey);
                    if (!positionMap || !positionMap.has(rawPos)) {
                        throw new Error(`Cell position ${rawPos} not found in cache for algorithm ${params.cellAlgorithm}`);
                    }
                    return positionMap.get(rawPos);
                }

                return rawPos;
            }

            // Get the linearization position of a chunk
            getInterChunkPosition(x, y, z, params) {
                const [sizeX, sizeY, sizeZ] = params.size;
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const chunksZ = Math.ceil(sizeZ / chunkZ);
                const chunkCX = Math.floor(x / chunkX);
                const chunkCY = Math.floor(y / chunkY);
                const chunkCZ = Math.floor(z / chunkZ);
                return this.linearizeCoordinate(chunkCX, chunkCY, chunkCZ, chunksX, chunksY, chunksZ, params.chunkAlgorithm);
            }

            // Get the normalized chunk position (sequential order 0,1,2,3... regardless of algorithm)
            getNormalizedChunkPosition(x, y, z, params) {
                const rawChunkPos = this.getInterChunkPosition(x, y, z, params);

                if (params.chunkAlgorithm === 'z-order' || params.chunkAlgorithm === 'hilbert') {
                    // For non-sequential algorithms, normalize to get proper sequential positions
                    const [sizeX, sizeY] = params.size;
                    const [chunkX, chunkY] = params.chunk;
                    const chunksX = Math.ceil(sizeX / chunkX);
                    const chunksY = Math.ceil(sizeY / chunkY);

                    // Create mapping once and cache it
                    const cacheKey = `${params.chunkAlgorithm}-${chunksX}-${chunksY}`;

                    if (!this.chunkPositionCache.has(cacheKey)) {
                        const allChunkPositions = [];
                        for (let cy = 0; cy < chunksY; cy++) {
                            for (let cx = 0; cx < chunksX; cx++) {
                                const tempX = cx * chunkX;
                                const tempY = cy * chunkY;
                                const pos = this.getInterChunkPosition(tempX, tempY, 0, params);
                                allChunkPositions.push({pos, index: cy * chunksX + cx, cx, cy});
                            }
                        }
                        allChunkPositions.sort((a, b) => a.pos - b.pos);

                        const positionMap = new Map();
                        const coordMap = new Map();
                        allChunkPositions.forEach((item, seqIndex) => {
                            positionMap.set(item.pos, seqIndex);
                            coordMap.set(seqIndex, {cx: item.cx, cy: item.cy});
                        });
                        this.chunkPositionCache.set(cacheKey, positionMap);
                        this.chunkPositionCache.set(cacheKey + '-coords', coordMap);
                    }

                    const positionMap = this.chunkPositionCache.get(cacheKey);
                    if (!positionMap || !positionMap.has(rawChunkPos)) {
                        throw new Error(`Chunk position ${rawChunkPos} not found in cache for algorithm ${params.chunkAlgorithm}`);
                    }
                    return positionMap.get(rawChunkPos);
                }

                return rawChunkPos;
            }

            // Get the global linearization position combining both levels
            getGlobalPosition(x, y, z, params) {
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY, chunkZ] = params.chunk;

                // Calculate which chunk this cell belongs to
                const chunkCX = Math.floor(x / chunkX);
                const chunkCY = Math.floor(y / chunkY);
                const chunkCZ = Math.floor(z / Math.max(1, chunkZ));

                // Get linearization position of chunks
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const normalizedChunkPos = this.getNormalizedChunkPosition(x, y, z, params);

                // Calculate how many actual cells are in chunks before this one
                let cellsBeforeThisChunk = 0;
                for (let i = 0; i < normalizedChunkPos; i++) {
                    // Convert sequential chunk index back to chunk coordinates
                    const chunksX = Math.ceil(sizeX / chunkX);
                    const chunksY = Math.ceil(sizeY / chunkY);

                    let tempCX, tempCY;

                    // Use the same algorithm as chunk linearization to get proper coordinates
                    if (params.chunkAlgorithm === 'z-order' || params.chunkAlgorithm === 'hilbert') {
                        // For non-sequential algorithms, use the cached coordinate mapping
                        const cacheKey = `${params.chunkAlgorithm}-${chunksX}-${chunksY}`;
                        const coordCacheKey = cacheKey + '-coords';

                        // The coordinate cache must exist from getNormalizedChunkPosition call
                        const coordMap = this.chunkPositionCache.get(coordCacheKey);
                        if (!coordMap || !coordMap.has(i)) {
                            throw new Error(`Coordinate mapping not found for sequential position ${i} in algorithm ${params.chunkAlgorithm}`);
                        }
                        const coords = coordMap.get(i);
                        tempCX = coords.cx;
                        tempCY = coords.cy;
                    } else if (params.chunkAlgorithm === 'col-major') {
                        // Column-major: increment Y first, then X
                        tempCX = Math.floor(i / chunksY);
                        tempCY = i % chunksY;
                    } else {
                        // Row-major (default): increment X first, then Y
                        tempCY = Math.floor(i / chunksX);
                        tempCX = i % chunksX;
                    }

                    // Calculate actual cells in this chunk
                    const startX = tempCX * chunkX;
                    const startY = tempCY * chunkY;
                    const endX = Math.min(startX + chunkX, sizeX);
                    const endY = Math.min(startY + chunkY, sizeY);
                    const actualCellsInChunk = (endX - startX) * (endY - startY);
                    cellsBeforeThisChunk += actualCellsInChunk;
                }

                // Add position within current chunk
                const intraChunkPos = this.getIntraChunkPosition(x, y, z, params);
                return cellsBeforeThisChunk + intraChunkPos;
            }

            // Get the range of global positions for a chunk
            getChunkGlobalRange(chunkCX, chunkCY, params) {
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY] = params.chunk;
                const cellsPerChunk = chunkX * chunkY;

                const positions = [];
                for (let dy = 0; dy < chunkY; dy++) {
                    for (let dx = 0; dx < chunkX; dx++) {
                        const x = chunkCX * chunkX + dx;
                        const y = chunkCY * chunkY + dy;
                        if (x < sizeX && y < sizeY) {
                            positions.push(this.getGlobalPosition(x, y, 0, params));
                        }
                    }
                }

                if (positions.length === 0) return null;
                return {
                    min: Math.min(...positions),
                    max: Math.max(...positions),
                    positions: positions
                };
            }

            mortonEncode2D(x, y) {
                let result = 0;
                for (let i = 0; i < 16; i++) {
                    result |= ((x & (1 << i)) << i) | ((y & (1 << i)) << (i + 1));
                }
                return result;
            }

            mortonEncode3D(x, y, z) {
                let result = 0;
                for (let i = 0; i < 10; i++) {
                    result |= ((x & (1 << i)) << (2 * i)) |
                              ((y & (1 << i)) << (2 * i + 1)) |
                              ((z & (1 << i)) << (2 * i + 2));
                }
                return result;
            }

            // Calculate the next power of 2 that is >= n
            nextPowerOfTwo(n) {
                if (n <= 1) return 1;
                return Math.pow(2, Math.ceil(Math.log2(n)));
            }

            hilbertEncode2D(x, y, maxDim) {
                // Hilbert curves require power-of-2 dimensions for correctness
                const n = this.nextPowerOfTwo(maxDim);

                let d = 0;
                for (let s = n / 2; s > 0; s /= 2) {
                    let rx = (x & s) > 0 ? 1 : 0;
                    let ry = (y & s) > 0 ? 1 : 0;
                    d += s * s * ((3 * rx) ^ ry);
                    [x, y] = this.hilbertRotate(s, x, y, rx, ry);
                }
                return d;
            }

            hilbertRotate(n, x, y, rx, ry) {
                if (ry === 0) {
                    if (rx === 1) {
                        x = n - 1 - x;
                        y = n - 1 - y;
                    }
                    [x, y] = [y, x];
                }
                return [x, y];
            }

            getChunkIndex(x, y, z, params) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const cx = Math.floor(x / chunkX);
                const cy = Math.floor(y / chunkY);
                const cz = Math.floor(z / chunkZ);
                const [sizeX, sizeY] = params.size;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                return cx + cy * chunksX + cz * chunksX * chunksY;
            }

            getColorForLinearPosition(position, maxPosition) {
                // Cache color calculations for performance
                const key = `${position}-${maxPosition}`;

                const cachedColor = this.colorCache.get(key);
                if (cachedColor) {
                    return cachedColor;
                }

                const hue = 120 - (position / maxPosition) * 120; // Green to red (120° to 0°)
                const color = `hsl(${hue}, 70%, 50%)`;

                // The LRUCache handles eviction automatically.
                this.colorCache.set(key, color);
                return color;
            }

            // Helper methods to get the effective cell/chunk for highlighting (selected takes precedence over hovered)
            getEffectiveCell() {
                return this.selectionState.getEffectiveCell();
            }

            getEffectiveChunk() {
                return this.selectionState.getEffectiveChunk();
            }



            update() {
                const params = this.getParameters();

                // Update Z range visibility
                document.getElementById('zRange').style.display =
                    params.size[2] > 0 ? 'flex' : 'none';

                // Calculate data
                const data = this.calculateData(params);
                this.currentData = data; // Store for mouse interactions

                // Draw all views
                this.drawSpatialUnchunked(params, data);
                this.drawSpatialChunked(params, data);
                this.drawLinearUnchunked(params, data);
                this.drawLinearChunked(params, data);

                // Update metrics
                this.updateMetrics(data);

                // Align grid headers after everything is rendered
            }

            calculateData(params) {
                const [sizeX, sizeY, sizeZ] = params.size;
                const totalCells = sizeX * sizeY * Math.max(1, sizeZ);

                // Calculate requested cells
                const requestedCells = new Set();
                const touchedChunks = new Set();

                for (let x = params.query.x[0]; x <= Math.min(params.query.x[1], sizeX - 1); x++) {
                    for (let y = params.query.y[0]; y <= Math.min(params.query.y[1], sizeY - 1); y++) {
                        if (sizeZ > 0) {
                            for (let z = params.query.z[0]; z <= Math.min(params.query.z[1], sizeZ - 1); z++) {
                                requestedCells.add(`${x},${y},${z}`);
                                touchedChunks.add(this.getChunkIndex(x, y, z, params));
                            }
                        } else {
                            requestedCells.add(`${x},${y},0`);
                            touchedChunks.add(this.getChunkIndex(x, y, 0, params));
                        }
                    }
                }

                // Calculate actual cells read (all cells in touched chunks)
                const actualCells = new Set();
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);

                touchedChunks.forEach(chunkIdx => {
                    const cz = Math.floor(chunkIdx / (chunksX * chunksY));
                    const cy = Math.floor((chunkIdx % (chunksX * chunksY)) / chunksX);
                    const cx = chunkIdx % chunksX;

                    for (let dx = 0; dx < chunkX; dx++) {
                        for (let dy = 0; dy < chunkY; dy++) {
                            for (let dz = 0; dz < (sizeZ > 0 ? chunkZ : 1); dz++) {
                                const x = cx * chunkX + dx;
                                const y = cy * chunkY + dy;
                                const z = cz * chunkZ + dz;

                                if (x < sizeX && y < sizeY && (sizeZ === 0 || z < sizeZ)) {
                                    actualCells.add(`${x},${y},${z}`);
                                }
                            }
                        }
                    }
                });

                // Calculate byte ranges for chunked reads
                const chunkedRanges = this.calculateByteRanges(
                    [...actualCells].map(key => {
                        const [x, y, z] = key.split(',').map(Number);
                        return this.getGlobalPosition(x, y, z, params);
                    })
                );

                // Calculate byte ranges for unchunked reads
                const unchunkedRanges = this.calculateByteRanges(
                    [...requestedCells].map(key => {
                        const [x, y, z] = key.split(',').map(Number);
                        return this.getGlobalPosition(x, y, z, params);
                    })
                );

                return {
                    requestedCells,
                    actualCells,
                    touchedChunks,
                    chunkedRanges,
                    unchunkedRanges,
                    totalCells
                };
            }

            calculateByteRanges(positions) {
                if (positions.length === 0) return [];

                const sorted = [...positions].sort((a, b) => a - b);
                const ranges = [];
                let start = sorted[0];
                let end = sorted[0];

                for (let i = 1; i < sorted.length; i++) {
                    if (sorted[i] === end + 1) {
                        end = sorted[i];
                    } else {
                        ranges.push([start, end]);
                        start = end = sorted[i];
                    }
                }
                ranges.push([start, end]);
                return ranges;
            }

            drawSpatialUnchunked(params, data) {
                const renderer = new BaseCanvasRenderer(this.canvases.spatialUnchunked, this.contexts.spatialUnchunked);
                renderer.clearCanvas();

                const [sizeX, sizeY, sizeZ] = params.size;
                const { cellSize, offsetX, offsetY } = renderer.getSpatialCellLayout(sizeX, sizeY);

                this.drawCellGrid(renderer, params, data, sizeX, sizeY, cellSize, offsetX, offsetY);
                this.drawSpatialHighlights(renderer, params, sizeX, sizeY, cellSize, offsetX, offsetY);
                renderer.drawQueryRegionOutline(params.query, sizeX, sizeY, cellSize, offsetX, offsetY);
            }

            drawCellGrid(renderer, params, data, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const { ctx } = renderer;
                
                // Skip rendering individual cells if they're too small to see
                if (cellSize > CONFIG.MIN_CELL_SIZE) {
                    this.drawDetailedCellGrid(renderer, params, data, sizeX, sizeY, cellSize, offsetX, offsetY);
                } else {
                    // For very small cells, draw as a single gradient rectangle
                    const gradient = ctx.createLinearGradient(offsetX, offsetY, offsetX + sizeX * cellSize, offsetY + sizeY * cellSize);
                    gradient.addColorStop(0, '#00ff00');
                    gradient.addColorStop(1, '#ff0000');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(offsetX, offsetY, sizeX * cellSize, sizeY * cellSize);
                }
            }

            drawDetailedCellGrid(renderer, params, data, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const { ctx } = renderer;
                const { width: logicalWidth } = renderer.getLogicalDimensions();

                // Use viewport-based rendering for medium-sized cells to improve performance
                if (cellSize < CONFIG.VIEWPORT_CELL_SIZE && data.totalCells > 1000) {
                    // Calculate visible cell range for viewport optimization
                    const startX = Math.max(0, Math.floor(-offsetX / cellSize));
                    const endX = Math.min(sizeX, Math.ceil((logicalWidth - offsetX) / cellSize));
                    const startY = Math.max(0, Math.floor(-offsetY / cellSize));
                    const endY = Math.min(sizeY, Math.ceil((logicalWidth - offsetY) / cellSize));

                    this.drawCellRange(ctx, params, data, startX, endX, startY, endY, cellSize, offsetX, offsetY);
                } else {
                    // Full rendering for larger cells or smaller datasets
                    this.drawCellRange(ctx, params, data, 0, sizeX, 0, sizeY, cellSize, offsetX, offsetY);
                }
            }

            drawCellRange(ctx, params, data, startX, endX, startY, endY, cellSize, offsetX, offsetY) {
                for (let y = startY; y < endY; y++) {
                    for (let x = startX; x < endX; x++) {
                        const globalPos = this.getGlobalPosition(x, y, 0, params);
                        const color = this.getColorForLinearPosition(globalPos, data.totalCells - 1);

                        ctx.fillStyle = color;
                        ctx.fillRect(
                            offsetX + x * cellSize,
                            offsetY + y * cellSize,
                            cellSize - 1,
                            cellSize - 1
                        );
                    }
                }
            }

            drawSpatialHighlights(renderer, params, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const effectiveCell = this.getEffectiveCell();
                const effectiveChunk = this.getEffectiveChunk();

                // Handle individual cell highlighting
                if (cellSize > CONFIG.MIN_CELL_SIZE && effectiveCell) {
                    renderer.drawCellHighlight(effectiveCell.x, effectiveCell.y, cellSize, offsetX, offsetY);
                }

                // Highlight all cells in effective chunk (when no individual cell is highlighted)
                if (effectiveChunk && !effectiveCell) {
                    this.drawChunkCellHighlights(renderer, params, effectiveChunk, sizeX, sizeY, cellSize, offsetX, offsetY);
                }
            }

            drawChunkCellHighlights(renderer, params, effectiveChunk, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const { ctx } = renderer;
                const [chunkSizeX, chunkSizeY] = params.chunk;

                for (let y = 0; y < sizeY; y++) {
                    for (let x = 0; x < sizeX; x++) {
                        const chunkCoords = CoordinateUtils.getChunkCoordinatesFromCell(x, y, chunkSizeX, chunkSizeY);

                        if (chunkCoords.x === effectiveChunk.x && chunkCoords.y === effectiveChunk.y) {
                            // Draw semi-transparent white overlay
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                            ctx.fillRect(
                                offsetX + x * cellSize,
                                offsetY + y * cellSize,
                                cellSize - 1,
                                cellSize - 1
                            );
                        }
                    }
                }
            }

            drawSpatialChunked(params, data) {
                const renderer = new BaseCanvasRenderer(this.canvases.spatialChunked, this.contexts.spatialChunked);
                renderer.clearCanvas();

                const [sizeX, sizeY, sizeZ] = params.size;
                const [chunkX, chunkY] = params.chunk;
                const { cellSize, offsetX, offsetY } = renderer.getSpatialCellLayout(sizeX, sizeY);

                const chunkColorMap = this.getOrCreateChunkColorMap(params, sizeX, sizeY, sizeZ);
                this.drawChunkGrid(renderer, params, chunkColorMap, sizeX, sizeY, sizeZ, cellSize, offsetX, offsetY);
                this.drawChunkedViewHighlights(renderer, params, data, sizeX, sizeY, cellSize, offsetX, offsetY);
            }

            getOrCreateChunkColorMap(params, sizeX, sizeY, sizeZ) {
                const [chunkX, chunkY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const chunksZ = Math.ceil(Math.max(1, sizeZ) / Math.max(1, params.chunk[2]));
                const cacheKey = `${chunksX},${chunksY},${chunksZ},${params.chunkAlgorithm}`;

                let chunkColorMap = this.positionCache.get(cacheKey);
                if (!chunkColorMap) {
                    chunkColorMap = this.createChunkColorMap(params, chunksX, chunksY, chunksZ);
                    this.positionCache.set(cacheKey, chunkColorMap);
                }
                return chunkColorMap;
            }

            createChunkColorMap(params, chunksX, chunksY, chunksZ) {
                const chunkPositions = [];
                for (let chunkCZ = 0; chunkCZ < chunksZ; chunkCZ++) {
                    for (let chunkCY = 0; chunkCY < chunksY; chunkCY++) {
                        for (let chunkCX = 0; chunkCX < chunksX; chunkCX++) {
                            const linearPos = this.linearizeCoordinate(chunkCX, chunkCY, chunkCZ, chunksX, chunksY, chunksZ, params.chunkAlgorithm);
                            chunkPositions.push({ chunkCX, chunkCY, chunkCZ, linearPos });
                        }
                    }
                }

                chunkPositions.sort((a, b) => a.linearPos - b.linearPos);

                const chunkColorMap = new Map();
                chunkPositions.forEach((chunk, index) => {
                    const key = `${chunk.chunkCX},${chunk.chunkCY},${chunk.chunkCZ}`;
                    chunkColorMap.set(key, index);
                });
                return chunkColorMap;
            }

            drawChunkGrid(renderer, params, chunkColorMap, sizeX, sizeY, sizeZ, cellSize, offsetX, offsetY) {
                const { ctx } = renderer;
                const { width: logicalWidth, height: logicalHeight } = renderer.getLogicalDimensions();
                const [chunkX, chunkY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const chunksZ = Math.ceil(Math.max(1, sizeZ) / Math.max(1, params.chunk[2]));

                // Apply viewport optimization for large chunk arrays
                const { startChunkX, endChunkX, startChunkY, endChunkY } = this.getChunkViewport(
                    chunksX, chunksY, cellSize, chunkX, chunkY, offsetX, offsetY, logicalWidth, logicalHeight
                );

                const totalChunks = chunksX * chunksY * chunksZ;

                for (let chunkCY = startChunkY; chunkCY < endChunkY; chunkCY++) {
                    for (let chunkCX = startChunkX; chunkCX < endChunkX; chunkCX++) {
                        this.drawSingleChunk(ctx, chunkColorMap, chunkCX, chunkCY, totalChunks, 
                                           params, sizeX, sizeY, cellSize, offsetX, offsetY);
                    }
                }
            }

            getChunkViewport(chunksX, chunksY, cellSize, chunkX, chunkY, offsetX, offsetY, logicalWidth, logicalHeight) {
                if (cellSize < CONFIG.VIEWPORT_CELL_SIZE && chunksX * chunksY > 100) {
                    return {
                        startChunkX: Math.max(0, Math.floor(-offsetX / (chunkX * cellSize))),
                        endChunkX: Math.min(chunksX, Math.ceil((logicalWidth - offsetX) / (chunkX * cellSize))),
                        startChunkY: Math.max(0, Math.floor(-offsetY / (chunkY * cellSize))),
                        endChunkY: Math.min(chunksY, Math.ceil((logicalHeight - offsetY) / (chunkY * cellSize)))
                    };
                }
                return { startChunkX: 0, endChunkX: chunksX, startChunkY: 0, endChunkY: chunksY };
            }

            drawSingleChunk(ctx, chunkColorMap, chunkCX, chunkCY, totalChunks, params, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const [chunkX, chunkY] = params.chunk;
                const chunkCZ = 0; // For 2D spatial view, we show Z=0 slice
                const chunkKey = `${chunkCX},${chunkCY},${chunkCZ}`;
                const colorIndex = chunkColorMap.get(chunkKey);
                const color = this.getColorForLinearPosition(colorIndex, totalChunks - 1);

                const bounds = CoordinateUtils.getChunkBounds(chunkCX, chunkCY, chunkX, chunkY, sizeX, sizeY);
                const chunkPixelWidth = (bounds.endX - bounds.startX) * cellSize;
                const chunkPixelHeight = (bounds.endY - bounds.startY) * cellSize;

                // Draw chunk fill
                ctx.fillStyle = color;
                ctx.fillRect(
                    offsetX + bounds.startX * cellSize,
                    offsetY + bounds.startY * cellSize,
                    chunkPixelWidth,
                    chunkPixelHeight
                );

                // Draw chunk border
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(
                    offsetX + bounds.startX * cellSize,
                    offsetY + bounds.startY * cellSize,
                    chunkPixelWidth,
                    chunkPixelHeight
                );
            }

            drawChunkedViewHighlights(renderer, params, data, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const effectiveCell = this.getEffectiveCell();
                const effectiveChunk = this.getEffectiveChunk();
                const [chunkX, chunkY] = params.chunk;

                // Highlight chunk when there's an effective cell
                if (effectiveCell) {
                    const chunkCoords = CoordinateUtils.getChunkCoordinatesFromCell(effectiveCell.x, effectiveCell.y, chunkX, chunkY);
                    const bounds = CoordinateUtils.getChunkBounds(chunkCoords.x, chunkCoords.y, chunkX, chunkY, sizeX, sizeY);
                    renderer.drawRectHighlight(bounds.startX, bounds.startY, bounds.endX, bounds.endY, cellSize, offsetX, offsetY, 'rgba(255, 255, 255, 0.4)', null);
                }

                // Draw query region outline around touched chunks
                this.drawTouchedChunksOutline(renderer, data, params, sizeX, sizeY, cellSize, offsetX, offsetY);

                // Highlight effective chunk
                if (effectiveChunk && !effectiveCell) {
                    const bounds = CoordinateUtils.getChunkBounds(effectiveChunk.x, effectiveChunk.y, chunkX, chunkY, sizeX, sizeY);
                    renderer.drawRectHighlight(bounds.startX, bounds.startY, bounds.endX, bounds.endY, cellSize, offsetX, offsetY);
                }
            }

            drawTouchedChunksOutline(renderer, data, params, sizeX, sizeY, cellSize, offsetX, offsetY) {
                if (data.touchedChunks.size === 0) return;

                const { ctx } = renderer;
                const [chunkX, chunkY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);

                // Find bounding box of all touched chunks
                let minChunkX = Infinity, minChunkY = Infinity;
                let maxChunkX = -Infinity, maxChunkY = -Infinity;

                data.touchedChunks.forEach(chunkIdx => {
                    const chunkCY = Math.floor(chunkIdx / chunksX);
                    const chunkCX = chunkIdx % chunksX;
                    minChunkX = Math.min(minChunkX, chunkCX);
                    minChunkY = Math.min(minChunkY, chunkCY);
                    maxChunkX = Math.max(maxChunkX, chunkCX);
                    maxChunkY = Math.max(maxChunkY, chunkCY);
                });

                // Draw single rectangle around all touched chunks
                const startX = minChunkX * chunkX;
                const startY = minChunkY * chunkY;
                const endX = Math.min((maxChunkX + 1) * chunkX, sizeX);
                const endY = Math.min((maxChunkY + 1) * chunkY, sizeY);

                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 3;
                ctx.strokeRect(
                    offsetX + startX * cellSize,
                    offsetY + startY * cellSize,
                    (endX - startX) * cellSize - 1,
                    (endY - startY) * cellSize - 1
                );
            }

            drawLinearUnchunked(params, data) {
                const renderer = new BaseCanvasRenderer(this.canvases.linearUnchunked, this.contexts.linearUnchunked);
                renderer.clearCanvas();

                const { cellWidth, barHeight, offsetX, offsetY } = renderer.getLinearBarLayout(data.totalCells);
                
                // Draw main cell bar
                renderer.drawLinearBar(cellWidth, barHeight, offsetX, offsetY, data.totalCells, 
                                    (i, total) => this.getColorForLinearPosition(i, total));

                // Highlight requested cells
                const requestedPositions = this.getRequestedCellPositions(data, params);
                renderer.highlightLinearCells(requestedPositions, cellWidth, barHeight, offsetX, offsetY);

                // Draw highlights
                this.drawLinearUnchunkedHighlights(renderer, params, cellWidth, barHeight, offsetX, offsetY);

                // Draw byte ranges
                renderer.drawByteRanges(data.unchunkedRanges, cellWidth, barHeight, offsetX, offsetY, 'byte range(s)');
            }

            getRequestedCellPositions(data, params) {
                return [...data.requestedCells].map(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    return this.getGlobalPosition(x, y, z, params);
                });
            }

            drawLinearUnchunkedHighlights(renderer, params, cellWidth, barHeight, offsetX, offsetY) {
                const effectiveCell = this.getEffectiveCell();
                const effectiveChunk = this.getEffectiveChunk();

                // Highlight effective chunk range
                if (effectiveChunk) {
                    const chunkRange = this.getChunkGlobalRange(effectiveChunk.x, effectiveChunk.y, params);
                    renderer.drawLinearChunkHighlight(chunkRange, cellWidth, barHeight, offsetX, offsetY, !effectiveCell);
                }

                // Highlight effective cell (should be drawn last to be on top)
                if (effectiveCell) {
                    const pos = this.getGlobalPosition(effectiveCell.x, effectiveCell.y, 0, params);
                    renderer.ctx.strokeStyle = '#fff';
                    renderer.ctx.lineWidth = 3;
                    renderer.ctx.strokeRect(offsetX + pos * cellWidth, offsetY, cellWidth, barHeight);
                }
            }

            drawLinearChunked(params, data) {
                const renderer = new BaseCanvasRenderer(this.canvases.linearChunked, this.contexts.linearChunked);
                renderer.clearCanvas();

                const { cellWidth, barHeight, offsetX, offsetY } = renderer.getLinearBarLayout(data.totalCells);
                const [sizeX, sizeY, sizeZ] = params.size;

                // Get position-to-cell mapping and chunk color map
                const positionToCell = this.getOrCreatePositionToCellMap(params, sizeX, sizeY, sizeZ);
                const spatialChunkColorMap = this.getOrCreateChunkColorMap(params, sizeX, sizeY, sizeZ);

                // Draw cells colored by chunk
                this.drawLinearChunkedCells(renderer, params, data, positionToCell, spatialChunkColorMap, 
                                          cellWidth, barHeight, offsetX, offsetY, sizeX, sizeY, sizeZ);

                // Highlight actual cells read (amplification)
                const actualCellPositions = this.getActualCellPositions(data, params);
                renderer.highlightLinearCells(actualCellPositions, cellWidth, barHeight, offsetX, offsetY);

                // Draw chunk highlights
                this.drawLinearChunkedHighlights(renderer, params, cellWidth, barHeight, offsetX, offsetY);

                // Draw byte ranges
                renderer.drawByteRanges(data.chunkedRanges, cellWidth, barHeight, offsetX, offsetY, 'byte range(s) with chunking');
            }

            getOrCreatePositionToCellMap(params, sizeX, sizeY, sizeZ) {
                const [chunkSizeX, chunkSizeY] = params.chunk;
                const cacheKey = `${sizeX},${sizeY},${params.cellAlgorithm},${params.chunkAlgorithm},${chunkSizeX},${chunkSizeY}`;
                
                let positionToCell = this.positionCache.get(cacheKey);
                if (!positionToCell) {
                    positionToCell = new Map();
                    for (let z = 0; z < Math.max(1, sizeZ); z++) {
                        for (let y = 0; y < sizeY; y++) {
                            for (let x = 0; x < sizeX; x++) {
                                const globalPos = this.getGlobalPosition(x, y, z, params);
                                positionToCell.set(globalPos, {x, y, z});
                            }
                        }
                    }
                    this.positionCache.set(cacheKey, positionToCell);
                }
                return positionToCell;
            }

            getActualCellPositions(data, params) {
                return [...data.actualCells].map(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    return this.getGlobalPosition(x, y, z, params);
                });
            }

            drawLinearChunkedCells(renderer, params, data, positionToCell, spatialChunkColorMap, 
                                 cellWidth, barHeight, offsetX, offsetY, sizeX, sizeY, sizeZ) {
                const { ctx } = renderer;
                const [chunkSizeX, chunkSizeY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkSizeX);
                const chunksY = Math.ceil(sizeY / chunkSizeY);
                const chunksZ3D = Math.ceil(Math.max(1, sizeZ) / Math.max(1, params.chunk[2]));
                const totalChunks3D = chunksX * chunksY * chunksZ3D;

                for (let i = 0; i < data.totalCells; i++) {
                    const color = this.getChunkedCellColor(i, positionToCell, spatialChunkColorMap, 
                                                        params, chunkSizeX, chunkSizeY, totalChunks3D, data.totalCells);
                    ctx.fillStyle = color;
                    // Remove gaps between cells by adding a small overlap
                    ctx.fillRect(offsetX + i * cellWidth, offsetY, cellWidth + 0.5, barHeight);
                }
            }

            getChunkedCellColor(cellIndex, positionToCell, spatialChunkColorMap, params, chunkSizeX, chunkSizeY, totalChunks3D, totalCells) {
                const cell = positionToCell.get(cellIndex);
                if (cell && spatialChunkColorMap) {
                    const chunkCX = Math.floor(cell.x / chunkSizeX);
                    const chunkCY = Math.floor(cell.y / chunkSizeY);
                    const chunkCZ = Math.floor(cell.z / Math.max(1, params.chunk[2]));
                    const chunkKey = `${chunkCX},${chunkCY},${chunkCZ}`;
                    const colorIndex = spatialChunkColorMap.get(chunkKey);

                    if (colorIndex !== undefined) {
                        return this.getColorForLinearPosition(colorIndex, totalChunks3D - 1);
                    } else {
                        return '#333'; // Fallback for invalid chunks
                    }
                } else {
                    // Fallback to gradient if position mapping fails
                    return this.getColorForLinearPosition(cellIndex, totalCells);
                }
            }

            drawLinearChunkedHighlights(renderer, params, cellWidth, barHeight, offsetX, offsetY) {
                const effectiveChunk = this.getEffectiveChunk();

                if (effectiveChunk) {
                    const chunkRange = this.getChunkGlobalRange(effectiveChunk.x, effectiveChunk.y, params);
                    const showOutline = !this.selectionState.hoveredCell;
                    renderer.drawLinearChunkHighlight(chunkRange, cellWidth, barHeight, offsetX, offsetY, showOutline);
                }
            }

            updateMetrics(data) {
                const params = this.getParameters();
                const [sizeX, sizeY] = params.size;
                const queryWidth = Math.abs(params.query.x[1] - params.query.x[0]) + 1;
                const queryHeight = Math.abs(params.query.y[1] - params.query.y[0]) + 1;
                const amplification = data.actualCells.size / Math.max(1, data.requestedCells.size);
                const coalescingFactor = data.touchedChunks.size / Math.max(1, data.chunkedRanges.length);
                const storageAlignment = 2 / (amplification + coalescingFactor);

                document.getElementById('requested-cells').textContent = data.requestedCells.size;
                document.getElementById('actual-cells').textContent = data.actualCells.size;
                document.getElementById('amplification').innerHTML =
                    amplification.toFixed(2) + '<span class="metric-suffix">x</span>';
                document.getElementById('chunks-touched').textContent = data.touchedChunks.size;
                document.getElementById('byte-ranges').textContent = data.chunkedRanges.length;
                document.getElementById('efficiency').innerHTML =
                    (100 / amplification).toFixed(1) + '<span class="metric-suffix">%</span>';
                document.getElementById('coalescing-factor').innerHTML =
                    coalescingFactor.toFixed(1) + '<span class="metric-suffix">x</span>';
                document.getElementById('storage-alignment').textContent = storageAlignment.toFixed(2);
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            new DataVisualizer();
        });
    </script>
</body>
</html>
