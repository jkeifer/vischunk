<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multidimensional Data Linearization</title>
    <style>
        /* ========================================
           CSS CUSTOM PROPERTIES
           ======================================== */
        :root {
            /* Colors - Primary Palette */
            --color-primary: #4a9eff;
            --color-primary-hover: #7cb3ff;
            --color-secondary: #667eea;
            --color-tertiary: #764ba2;
            --color-warning: #ffc107;
            --color-success: #00ff00;
            --color-danger: #ff0000;

            /* Colors - Backgrounds */
            --bg-primary: #1a1a2e;
            --bg-secondary: #2a2a3e;
            --bg-panel: rgba(255, 255, 255, 0.03);
            --bg-panel-hover: rgba(255, 255, 255, 0.05);
            --bg-input: rgba(255, 255, 255, 0.1);
            --bg-input-focus: rgba(255, 255, 255, 0.15);
            --bg-dark: rgba(0, 0, 0, 0.3);
            --bg-tooltip: rgba(0, 0, 0, 0.9);
            --bg-highlight: rgba(255, 255, 255, 0.4);
            --bg-warning: rgba(255, 200, 0, 0.1);

            /* Colors - Text */
            --text-primary: #fff;
            --text-secondary: #eee;
            --text-muted: #aaa;
            --text-light: #bbb;
            --text-dark: #333;
            --text-very-light: #ccc;
            --text-extra-light: #ddd;

            /* Colors - Borders */
            --border-primary: rgba(255, 255, 255, 0.1);
            --border-secondary: rgba(255, 255, 255, 0.2);
            --border-input: rgba(255, 255, 255, 0.2);
            --border-input-focus: #4a9eff;
            --border-warning: rgba(255, 200, 0, 0.3);
            --border-light: rgba(255, 255, 255, 0.3);

            /* Spacing Scale */
            --space-xs: 3px;
            --space-sm: 5px;
            --space-md: 8px;
            --space-lg: 10px;
            --space-xl: 15px;
            --space-2xl: 20px;
            --space-3xl: 25px;
            --space-4xl: 30px;
            --space-5xl: 40px;

            /* Border Radius */
            --radius-sm: 3px;
            --radius-md: 5px;
            --radius-lg: 8px;
            --radius-xl: 10px;
            --radius-2xl: 15px;

            /* Typography */
            --font-family: -apple-system, BlinkMacSystemFont, 'Segue UI', Roboto, sans-serif;
            --font-size-xs: 0.85em;
            --font-size-sm: 0.9em;
            --font-size-base: 1em;
            --font-size-lg: 1.1em;
            --font-size-xl: 1.3em;
            --font-size-2xl: 1.8em;
            --font-size-3xl: 2em;
            --font-size-4xl: 2.5em;
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --font-weight-bold: 700;

            /* Effects */
            --blur-sm: blur(5px);
            --blur-md: blur(10px);
            --transition-fast: 0.3s;

            /* Layout */
            --max-width-content: 1600px;
            --max-width-text: 850px;
            --min-width-content: 320px;

            /* Z-index Scale */
            --z-tooltip: 1000;
            --z-modal: 900;
            --z-overlay: 800;

            /* Canvas */
            --canvas-max-size: 400px;
            --canvas-min-cell-size: 2px;
            --canvas-viewport-cell-size: 8px;

            /* Gradients */
            --gradient-primary: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            --gradient-metrics: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-color-scale: linear-gradient(90deg, #00ff00, #ff0000);
        }

        /* ========================================
           BASE STYLES & RESET
           ======================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background: var(--bg-primary);
            min-height: 100vh;
            min-width: var(--min-width-content);
            padding: var(--space-xl);
            color: var(--text-secondary);
        }

        a {
            color: var(--color-primary);
            text-decoration: none;
            font-weight: var(--font-weight-medium);
            transition: color var(--transition-fast);
        }

        a:hover {
            color: var(--color-primary-hover);
            text-decoration: underline;
        }

        .container {
            margin: 0 auto;
        }

        .content-wrapper {
            max-width: var(--max-width-content);
            min-width: var(--min-width-content);
            margin: 0 auto;
        }

        /* Typography - Base styles */
        h1 {
            color: var(--text-primary);
            margin-bottom: var(--space-lg);
            font-size: var(--font-size-4xl);
            text-align: center;
        }

        h2 {
            color: var(--text-primary);
            margin-bottom: var(--space-lg);
            font-size: var(--font-size-3xl);
            text-align: center;
        }

        /* ========================================
           UTILITY CLASSES
           ======================================== */
        .panel {
            background: var(--bg-panel-hover);
            border-radius: var(--radius-xl);
            padding: var(--space-xl);
            backdrop-filter: var(--blur-md);
        }

        .panel-primary {
            background: var(--gradient-primary);
            border-radius: var(--radius-2xl);
            padding: var(--space-xl);
            backdrop-filter: var(--blur-md);
            border: 1px solid var(--border-primary);
        }

        .blur-effect {
            backdrop-filter: var(--blur-md);
        }

        .blur-effect-sm {
            backdrop-filter: var(--blur-sm);
        }

        /* ========================================
           LAYOUT COMPONENTS
           ======================================== */
        .subtitle {
            color: var(--text-muted);
            margin-bottom: var(--space-xl);
            text-align: center;
        }

        .section-container {
            background: var(--bg-panel);
            border-radius: var(--radius-2xl);
            padding: var(--space-xl);
            margin-bottom: var(--space-xl);
            border: 1px solid var(--border-primary);
        }


        .section-container h2 {
            color: var(--text-primary);
            font-size: var(--font-size-xl);
            margin: 0 0 var(--space-xl) 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .simulation-wrapper {
            padding: var(--space-xl);
            background: var(--gradient-primary);
            border-radius: var(--radius-2xl);
            backdrop-filter: var(--blur-md);
            border: 1px solid var(--border-primary);
        }

        .simulation-wrapper > h2 {
            color: var(--text-primary);
            font-size: var(--font-size-2xl);
            margin-bottom: var(--space-xl);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* ========================================
           FORM CONTROLS & INPUTS
           ======================================== */
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            grid-template-rows: auto 1fr;
            gap: var(--space-xl);
            margin-bottom: var(--space-xl);
        }

        .control-section {
            padding: var(--space-xl);
            background: var(--bg-panel-hover);
            border-radius: var(--radius-xl);
            backdrop-filter: var(--blur-md);
            display: flex;
            flex-direction: column;
            gap: var(--space-xl);
        }

        .section-title {
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
            font-size: var(--font-size-sm);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: var(--font-weight-medium);
            color: var(--text-light);
            margin-bottom: var(--space-sm);
            font-size: var(--font-size-xs);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="number"], select {
            padding: var(--space-md);
            border: 1px solid var(--border-input);
            border-radius: var(--radius-md);
            font-size: 14px;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: all var(--transition-fast);
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--border-input-focus);
            background: var(--bg-input-focus);
        }

        select option {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .query-controls {
            background: var(--bg-warning);
            padding: var(--space-xl);
            border-radius: var(--radius-xl);
            margin-bottom: var(--space-xl);
            border: 1px solid var(--border-warning);
        }

        .query-title {
            font-weight: var(--font-weight-semibold);
            color: var(--color-warning);
            margin-bottom: var(--space-lg);
            text-transform: uppercase;
            font-size: var(--font-size-sm);
        }

        .range-inputs {
            display: flex;
            gap: var(--space-xl);
            flex-wrap: wrap;
        }

        .range-group {
            display: flex;
            gap: var(--space-xl);
            align-items: center;
            color: var(--text-extra-light);
        }

        .range-group input {
            width: 60px;
        }

        /* ========================================
           VISUALIZATION COMPONENTS
           ======================================== */
        .spatial-views {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-xl);
            margin-bottom: var(--space-xl);
        }

        .viz-panel {
            background: var(--bg-panel-hover);
            border-radius: var(--radius-xl);
            padding: var(--space-xl);
            backdrop-filter: var(--blur-md);
        }

        .viz-title {
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            margin-bottom: var(--space-xl);
            font-size: var(--font-size-lg);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            background: var(--bg-dark);
            border-radius: var(--radius-md);
            padding: var(--space-lg);
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            max-width: 100%;
            cursor: crosshair;
            margin: 0 auto;
        }

        .linear-views {
            margin-bottom: var(--space-xl);
        }

        .linear-viz {
            background: var(--bg-panel-hover);
            border-radius: var(--radius-xl);
            padding: var(--space-xl);
            margin-bottom: var(--space-xl);
            backdrop-filter: var(--blur-md);
        }

        /* ========================================
           METRICS & DATA DISPLAY
           ======================================== */
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            grid-template-rows: auto auto;
            gap: var(--space-sm) var(--space-xl);
            padding: var(--space-xl);
            background: var(--gradient-metrics);
            border-radius: var(--radius-xl);
        }

        .metric {
            background: var(--bg-input);
            padding: var(--space-xl);
            border-radius: var(--radius-lg);
            text-align: center;
            backdrop-filter: var(--blur-md);
            display: grid;
            grid-template-rows: subgrid;
            grid-row: span 2;
        }

        /* Fallback for browsers without subgrid support */
        @supports not (grid-template-rows: subgrid) {
            .metric {
                display: block;
                grid-row: auto;
            }
        }

        /* Performance optimization: disable blur for low-end devices */
        @media (prefers-reduced-motion: reduce) {
            .blur-effect,
            .blur-effect-sm {
                backdrop-filter: none;
            }
        }

        .metric-label {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
            text-transform: uppercase;
            opacity: 0.8;
        }

        .metric-value {
            font-size: 2em;
            font-weight: var(--font-weight-bold);
            color: var(--text-primary);
        }

        .metric-suffix {
            font-size: 0.5em;
            color: var(--text-secondary);
            opacity: 0.7;
        }

        /* ========================================
           INTERACTIVE ELEMENTS
           ======================================== */
        .tooltip {
            position: fixed;
            background: var(--bg-tooltip);
            color: var(--text-primary);
            padding: var(--space-md) var(--space-lg);
            border-radius: var(--radius-md);
            font-size: 12px;
            pointer-events: none;
            z-index: var(--z-tooltip);
            display: none;
            border: 1px solid var(--border-secondary);
        }

        /* ========================================
           DOCUMENTATION & HELP SECTIONS
           ======================================== */
        .explanation {
            margin: var(--space-5xl) auto 0 auto;
            padding: var(--space-xl);
            background: var(--gradient-primary);
            border-radius: var(--radius-2xl);
            backdrop-filter: var(--blur-md);
            border: 1px solid var(--border-primary);
        }

        .explanation h2 {
            color: var(--text-primary);
            font-size: var(--font-size-2xl);
            margin-bottom: var(--space-xl);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .explanation-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: var(--space-xl);
            margin-top: var(--space-xl);
        }

        .explanation-section {
            background: var(--bg-panel-hover);
            padding: var(--space-xl);
            border-radius: var(--radius-xl);
            backdrop-filter: var(--blur-sm);
            border: 1px solid var(--border-primary);
        }

        .explanation-section h3 {
            color: var(--color-primary);
            font-size: 1.2em;
            margin-bottom: var(--space-xl);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .explanation-section p {
            color: var(--text-very-light);
            line-height: 1.6;
            margin-bottom: var(--space-xl);
        }

        .explanation-section ul {
            color: var(--text-very-light);
            margin-left: var(--space-xl);
            line-height: 1.6;
        }

        .explanation-section li {
            margin-bottom: var(--space-md);
        }

        .color-example {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: var(--radius-sm);
            margin-right: var(--space-md);
            vertical-align: middle;
        }

        /* Hide Z dimension controls for now */
        .z-control {
            display: none;
            /* Enable when 3D support is added: display: flex; */
        }

        .legend {
            display: flex;
            gap: var(--space-xl);
            margin-top: var(--space-lg);
            flex-wrap: wrap;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            color: var(--text-muted);
            font-size: var(--font-size-sm);
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-light);
        }

        .query-legend {
            border: 3px solid var(--color-primary);
            background: transparent;
        }

        .gradient-legend {
            background: var(--gradient-color-scale);
            border: none;
        }

        .highlight-legend {
            border: 3px solid var(--text-primary);
            background: transparent;
        }

        .reset-button {
            display: block;
            margin: 0 auto;
            padding: var(--space-md) var(--space-2xl);
            background: var(--bg-input);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-decoration: none;
            width: fit-content;
        }

        .reset-button:hover {
            background: var(--bg-input-focus);
            border-color: var(--border-input-focus);
            transform: translateY(-1px);
        }

        .github-link-container {
            text-align: center;
            margin: 20px auto;
        }

        .github-link {
            color: var(--color-primary);
            text-decoration: none;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .github-link:hover {
            color: var(--color-primary-hover);
        }

        .overview-container {
            margin: auto auto var(--space-4xl) auto;
            padding: var(--space-lg);
            max-width: var(--max-width-content);
            border-radius: var(--radius-xl);
            border: 1px solid var(--border-primary);
        }

        .overview-content {
            margin: var(--space-2xl) auto;
            padding: var(--space-2xl);
            max-width: var(--max-width-text);
            border-top: 1px solid var(--border-primary);
            border-bottom: 1px solid var(--border-primary);
        }

        .overview-content h2 {
            color: var(--text-primary);
            font-size: 1.7em;
            margin-bottom: var(--space-2xl);
            text-align: center;
        }

        .overview-content p {
            color: var(--text-extra-light);
            line-height: 1.7;
            margin-bottom: 18px;
            font-size: 1.05em;
        }

        .overview-content p:last-child {
            margin-bottom: 0;
        }

        .overview-content strong {
            color: var(--text-primary);
            font-weight: var(--font-weight-semibold);
            font-style: italic;
        }

        .preset-controls {
            display: flex;
            align-items: flex-end;
            gap: var(--space-xl);
            margin-bottom: var(--space-2xl);
            flex-wrap: wrap;
        }

        .preset-controls .control-group {
            flex: 1;
            min-width: 180px;
        }

        .preset-controls .reset-button {
            margin: 0;
            white-space: nowrap;
            flex-shrink: 0;
        }

        /* ========================================
           MEDIA QUERIES
           ======================================== */
        @media (min-width: 1200px) {
            .metrics {
                grid-template-columns: repeat(8, 1fr);
            }

            .explanation-content {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 1199px) and (min-width: 800px) {
            .metrics {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 799px) and (min-width: 400px) {
            .metrics {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .spatial-views {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 399px) {
            .metrics {
                grid-template-columns: 1fr;
            }
        }

    </style>
</head>
<body>
    <div class="content-wrapper container">
        <div class="overview-container">
            <h1>vischunk</h1>
            <h2>An nd-Array Chunking and Linearization Analyzer</h2>
            <p class="subtitle">
                Explore how chunking and linearization strategies affect the
                efficiency of various read patterns
            </p>

            <div class="overview-content">
                <h2>What is chunking and linearization?</h2>
                <p>

                    When working with n-dimensional datasets in cloud storage,
                    we face a fundamental challenge: n-dimensional data must be
                    <strong>linearized</strong> into one dimension for storage
                    and transfer. Linearization creates an inconsistency
                    between how we conceptualize our data and how it's
                    physically stored.

                </p>
                <p>

                    <strong>Chunking</strong> divides large datasets into
                    smaller blocks that serve as both the unit of compression
                    and the minimum unit for reading. Especially in systems
                    where data is read over a network, such as when
                    cloud-native data is hosted in an object store like S3,
                    chunk design critically impacts performance. Too small, and
                    you may have to wait because of the latency assoicated with
                    the overhead of excessive reads requests. Too large, and
                    you may have to wait to download excessive amounts of
                    unwanted data.

                </p>
                <p>

                    This tool demonstrates how different chunking and
                    linearization strategies affect read efficiency. Watch how
                    query patterns interact with chunk boundaries to create
                    <strong>read amplification</strong> (the ratio of data
                    requested to how much data is actually read and
                    transmitted). Notice that smaller chunks decrease read
                    amplification, but can increase request count. See how
                    different linearization algorithms (row-major,
                    column-major, Z-order, Hilbert) change the preservation of
                    spatial locality after linearization, and what effects that
                    may have on read coalescing.

                </p>
                <p>To learn more about the complexities of chunking and how it has
                   come to be such a concern, checkout these blog posts:
                    <a href="https://teotl.dev/posts/2025/07/09/chunks-and-chunkability-tyranny-of-the-chunk/" target="_blank">The Tyranny of the Chunk</a> |
                    <a href="https://teotl.dev/posts/2025/07/09/chunks-and-chunkability-an-origin-story/" target="_blank">An Origin Story</a>
                </p>
            </div>
            <div class="github-link-container">
                <a href="https://github.com/jkeifer/vischunk" target="_blank" class="github-link">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    view or contribute to this project on github
                </a>
            </div>
        </div>

        <div class="content-wrapper simulation-wrapper">
            <h2>Interactive Simulation</h2>

            <div class="section-container">
                <h2>Simulation Controls</h2>

                <div class="preset-controls">
                    <div class="control-group">
                        <label for="presets">Scenario Presets</label>
                        <select id="presets">
                            <option value="user">User Settings</option>
                        </select>
                    </div>
                    <button class="reset-button" id="resetButton">reset to default</button>
                </div>

            <div class="controls">
                <div class="control-section">
                <div class="section-title">Array Settings</div>
                <div class="control-group">
                    <label for="sizeX">Array Size X</label>
                    <input type="number" id="sizeX" min="1" max="64" value="16">
                </div>

                <div class="control-group">
                    <label for="sizeY">Array Size Y</label>
                    <input type="number" id="sizeY" min="1" max="64" value="16">
                </div>

                <div class="control-group z-control" id="arraySizeZGroup">
                    <label for="sizeZ">Array Size Z</label>
                    <input type="number" id="sizeZ" min="1" max="16" value="1">
                </div>


                <div class="control-group">
                    <label for="cellAlgorithm">Cell Linearization (within chunk)</label>
                    <select id="cellAlgorithm">
                        <option value="row-major">Row-Major</option>
                        <option value="col-major">Column-Major</option>
                        <option value="z-order">Z-Order (Morton)</option>
                        <option value="hilbert">Hilbert Curve</option>
                    </select>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Chunk Settings</div>
                <div class="control-group">
                    <label for="chunkX">Chunk Size X</label>
                    <input type="number" id="chunkX" min="1" max="64" value="4">
                </div>

                <div class="control-group">
                    <label for="chunkY">Chunk Size Y</label>
                    <input type="number" id="chunkY" min="1" max="64" value="4">
                </div>

                <div class="control-group z-control" id="chunkZGroup">
                    <label for="chunkZ">Chunk Size Z</label>
                    <input type="number" id="chunkZ" min="1" max="16" value="1">
                </div>

                <div class="control-group">
                    <label for="chunkAlgorithm">Chunk Linearization</label>
                    <select id="chunkAlgorithm">
                        <option value="row-major">Row-Major</option>
                        <option value="col-major">Column-Major</option>
                        <option value="z-order">Z-Order (Morton)</option>
                        <option value="hilbert">Hilbert Curve</option>
                    </select>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Query Region</div>
                <div class="range-group">
                    <label for="queryX1">X:</label>
                    <input type="number" id="queryX1" min="0" value="3">
                    <span>to</span>
                    <input type="number" id="queryX2" min="0" value="10">
                </div>
                <div class="range-group">
                    <label for="queryY1">Y:</label>
                    <input type="number" id="queryY1" min="0" value="3">
                    <span>to</span>
                    <input type="number" id="queryY2" min="0" value="10">
                </div>
                <div class="range-group z-control" id="zRange">
                    <label for="queryZ1">Z:</label>
                    <input type="number" id="queryZ1" min="0" value="0">
                    <span>to</span>
                    <input type="number" id="queryZ2" min="0" value="0">
                </div>
            </div>
        </div>

    </div>

    <div class="section-container">
        <h2>Performance Metrics</h2>
        <div class="metrics">
            <div class="metric">
                <div class="metric-label">Requested Cells</div>
                <div class="metric-value" id="requested-cells">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Cells Read</div>
                <div class="metric-value" id="actual-cells">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Read Amplification</div>
                <div class="metric-value" id="amplification">1.0<span class="metric-suffix">x</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Read Efficiency</div>
                <div class="metric-value" id="efficiency">100<span class="metric-suffix">%</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Chunks Touched</div>
                <div class="metric-value" id="chunks-touched">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Range Reads</div>
                <div class="metric-value" id="byte-ranges">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Coalescing Factor</div>
                <div class="metric-value" id="coalescing-factor">1.0<span class="metric-suffix">x</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Storage Alignment</div>
                <div class="metric-value" id="storage-alignment">1.0</div>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h2>Simulation Visualizations</h2>
        <div class="spatial-views">
            <div class="viz-panel">
                <div class="viz-title">Array Cells</div>
                <div class="canvas-container">
                    <canvas id="spatial-unchunked"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color gradient-legend"></div>
                        <span>Linearization Order</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color query-legend"></div>
                        <span>Query Region</span>
                    </div>
                </div>
            </div>

            <div class="viz-panel">
                <div class="viz-title">Array Chunks</div>
                <div class="canvas-container">
                    <canvas id="spatial-chunked"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color gradient-legend"></div>
                        <span>Linearization Order</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color query-legend"></div>
                        <span>Chunks to Read</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="linear-views">
            <div class="linear-viz">
                <div class="viz-title">Storage Linearization — Cells</div>
                <div class="canvas-container">
                    <canvas id="linear-unchunked"></canvas>
                </div>
            </div>

            <div class="linear-viz">
                <div class="viz-title">Storage Linearization — Chunks</div>
                <div class="canvas-container">
                    <canvas id="linear-chunked"></canvas>
                </div>
            </div>
        </div>
    </div>
        </div>

    <div class="tooltip" id="tooltip"></div>

    <div class="content-wrapper explanation">
        <h2>How to Interpret the Visualizations</h2>

        <div class="explanation-content">
            <div class="explanation-section">
                <h3>Color Coding</h3>
                <p><span class="color-example gradient-legend"></span><strong>Green to Red Gradient:</strong> Shows the linearization order from first (green) to last (red) in memory. This helps you understand how different algorithms arrange data sequentially.</p>

                <p><span class="color-example query-legend"></span><strong>Blue Outlines:</strong> Indicate query regions and all cells that need to be read to satisfy the query. This includes both requested cells and extra cells read due to chunking.</p>

                <p><span class="color-example highlight-legend"></span><strong>White Overlays:</strong> Show currently hovered elements. Direct hovers have both overlay and outline, while cross-highlighted elements show only the overlay.</p>
            </div>

            <div class="explanation-section">
                <h3>Array Views</h3>
                <p><strong>Array Cells:</strong> Shows how individual cells are organized and linearized within chunks. Each cell's color represents its position in the combined linearization order.</p>

                <p><strong>Array Chunks:</strong> Displays chunk-level organization where all cells in the same chunk share the same color. This shows how chunks are linearized relative to each other.</p>

                <p><strong>Interactive Cross-highlighting:</strong> Hovering in one view highlights corresponding elements in all other views, helping you trace relationships between logical and physical layouts.</p>
            </div>

            <div class="explanation-section">
                <h3>Linear Storage Views</h3>
                <p><strong>Storage Linearization — Cells</strong> Shows how data is actually stored in linear memory, with the same cell-level coloring as the logical array. Blue regions indicate cells that need to be read.</p>

                <p><strong>Storage Linearization — Chunks</strong> Same linear layout but colored by chunks to show how chunking affects the distribution of read operations. Blue bars below show the byte ranges that need to be fetched.</p>

                <p><strong>Byte Range Indicators:</strong> Lines below each linear view show how many separate read operations are required - fewer ranges mean better I/O performance.</p>
            </div>

            <div class="explanation-section">
                <h3>Performance Metrics</h3>
                <p><strong>Requested Cells:</strong> The number of cells in your query region that you actually want to read.</p>

                <p><strong>Actual Cells Read:</strong> The total number of cells that must be read due to chunking, including both requested and extra cells.</p>

                <p><strong>Read Amplification:</strong> Shows how much extra data you read due to chunking. Values > 1.0 indicate wasted bandwidth. Lower is better.</p>

                <p><strong>Read Efficiency:</strong> Percentage of useful data in each read operation. Higher percentages indicate better performance with less wasted I/O.</p>

                <p><strong>Chunks Touched:</strong> How many chunks intersect with your query region. Fewer chunks generally mean more efficient access patterns.</p>

                <p><strong>Range Reads:</strong> Number of separate read operations needed. Fewer range reads reduce I/O overhead and improve performance.</p>

                <p><strong>Coalescing Factor:</strong> Shows how much read coalescing improves I/O efficiency compared to worst-case (chunks touched ÷ range reads). Values > 1.0 indicate that multiple chunks are being read in fewer operations due to spatial locality. Note that this does not apply to formats that split chunks into individual files, like unsharded Zarr, where each chunk has to be read via a separate read request.</p>

                <p><strong>Storage Alignment:</strong> Overall measure of how well your query aligns with the storage layout, combining read ampliciation and coalescing in a weighted normalized average in the range 0 - 1. Higher values indicate better alignment between your access pattern and chunking strategy.</p>
            </div>

            <div class="explanation-section">
                <h3>Algorithm Comparison</h3>
                <p><strong>Row-Major:</strong> Best for queries that access consecutive rows. Common in C/C++ and most programming languages.</p>

                <p><strong>Column-Major:</strong> Optimal for column-wise access patterns. Used in Fortran, R, and some scientific computing applications.</p>

                <p><strong>Z-Order (Morton):</strong> Space-filling curve that preserves spatial locality well. Good for 2D range queries and spatial databases.</p>

                <p><strong>Hilbert Curve:</strong> Optimal space-filling curve with the best spatial locality preservation. Excellent for 2D spatial queries but more complex to compute.</p>
            </div>

            <div class="explanation-section">
                <h3>Optimization Tips</h3>
                <p><strong>Match Access Patterns:</strong> Choose linearization algorithms that align with how your application accesses data most frequently.</p>

                <p><strong>Chunk Size Balance:</strong> Larger chunks reduce metadata overhead and number of reads, but increase read amplification. Smaller chunks decrease read ampliciation but increase read count and can have a management overhead penalty.</p>

                <p><strong>Query Shape Matters:</strong> Square queries often work best with space-filling curves, while rectangular queries favor row- or column-major ordering, per the rectangle orientation.</p>

                <p><strong>Monitor Metrics:</strong> Use the metrics to compare different configurations and find the optimal balance for your specific use cases and data geometries.</p>
            </div>
        </div>
    </div>

    <script>
        // Configuration constants
        const CONFIG = {
            MAX_CANVAS_SIZE: 400,      // Maximum canvas size in pixels
            MIN_CELL_SIZE: 2,          // Minimum cell size for drawing details
            VIEWPORT_CELL_SIZE: 8,     // Cell size threshold for viewport rendering
            LRU_CONFIG_CACHE_SIZE: 50, // Max number of recent configurations to cache (for chunk/cell mappings)
            LRU_DETAIL_CACHE_SIZE: 20000, // Max number of recent detail items to cache (colors, coordinates)
            RESIZE_DEBOUNCE_MS: 150    // Debounce timeout for resize events
        };

        class LRUCache {
            constructor(maxSize) {
                this.maxSize = maxSize;
                this.cache = new Map();
            }

            get(key) {
                const item = this.cache.get(key);
                if (item) {
                    // Refresh it by deleting and re-setting
                    this.cache.delete(key);
                    this.cache.set(key, item);
                }
                return item;
            }

            set(key, value) {
                // Delete old entry if it exists to refresh its position
                if (this.cache.has(key)) {
                    this.cache.delete(key);
                }
                // If the cache is full, evict the least recently used item
                else if (this.cache.size >= this.maxSize && this.maxSize > 0) {
                    // .keys().next().value gets the first (oldest) key in the Map
                    this.cache.delete(this.cache.keys().next().value);
                }
                this.cache.set(key, value);
            }

            has(key) {
                return this.cache.has(key);
            }

            clear() {
                this.cache.clear();
            }
        }


        class GridCoordinate {
            constructor(sizeX, sizeY, sizeZ, algorithm, cache) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.sizeZ = Math.max(1, sizeZ || 1);
                this.algorithm = algorithm || 'row-major';
                this.cache = cache;
            }

            linearize(x, y, z = 0) {
                const cacheKey = JSON.stringify([x, y, z, this.sizeX, this.sizeY, this.sizeZ, this.algorithm]);
                if (this.cache && this.cache.has(cacheKey)) {
                    return this.cache.get(cacheKey);
                }

                const result = this.calculateLinearPosition(x, y, z);
                if (this.cache) {
                    this.cache.set(cacheKey, result);
                }
                return result;
            }

            calculateLinearPosition(x, y, z) {
                switch(this.algorithm) {
                    case 'row-major':
                        return x + y * this.sizeX + z * this.sizeX * this.sizeY;
                    case 'col-major':
                        return y + x * this.sizeY + z * this.sizeX * this.sizeY;
                    case 'z-order':
                        return this.sizeZ > 1 ? this.mortonEncode3D(x, y, z) : this.mortonEncode2D(x, y);
                    case 'hilbert':
                        if (this.sizeZ > 1) {
                            return z * this.sizeX * this.sizeY + this.hilbertEncode2D(x, y, Math.max(this.sizeX, this.sizeY));
                        } else {
                            return this.hilbertEncode2D(x, y, Math.max(this.sizeX, this.sizeY));
                        }
                    default:
                        return x + y * this.sizeX + z * this.sizeX * this.sizeY;
                }
            }

            getBounds(gridX, gridY, gridZ = 0, nominalSizeX, nominalSizeY, nominalSizeZ = 1) {
                const startX = gridX * nominalSizeX;
                const startY = gridY * nominalSizeY;
                const startZ = gridZ * nominalSizeZ;
                const endX = Math.min(startX + nominalSizeX, this.sizeX);
                const endY = Math.min(startY + nominalSizeY, this.sizeY);
                const endZ = Math.min(startZ + nominalSizeZ, this.sizeZ);
                return { startX, startY, startZ, endX, endY, endZ };
            }

            getDimensions(gridX, gridY, gridZ = 0, nominalSizeX, nominalSizeY, nominalSizeZ = 1) {
                const bounds = this.getBounds(gridX, gridY, gridZ, nominalSizeX, nominalSizeY, nominalSizeZ);
                return {
                    actualX: bounds.endX - bounds.startX,
                    actualY: bounds.endY - bounds.startY,
                    actualZ: bounds.endZ - bounds.startZ
                };
            }

            getTotalCells() {
                return this.sizeX * this.sizeY * this.sizeZ;
            }

            mortonEncode2D(x, y) {
                let result = 0;
                for (let i = 0; i < 16; i++) {
                    result |= ((x & (1 << i)) << i) | ((y & (1 << i)) << (i + 1));
                }
                return result;
            }

            mortonEncode3D(x, y, z) {
                let result = 0;
                for (let i = 0; i < 10; i++) {
                    result |= ((x & (1 << i)) << (2 * i)) |
                              ((y & (1 << i)) << (2 * i + 1)) |
                              ((z & (1 << i)) << (2 * i + 2));
                }
                return result;
            }

            nextPowerOfTwo(n) {
                if (n <= 1) return 1;
                return Math.pow(2, Math.ceil(Math.log2(n)));
            }

            hilbertEncode2D(x, y, maxDim) {
                const n = this.nextPowerOfTwo(maxDim);

                let d = 0;
                for (let s = n / 2; s > 0; s /= 2) {
                    let rx = (x & s) > 0 ? 1 : 0;
                    let ry = (y & s) > 0 ? 1 : 0;
                    d += s * s * ((3 * rx) ^ ry);
                    [x, y] = this.hilbertRotate(s, x, y, rx, ry);
                }
                return d;
            }

            hilbertRotate(n, x, y, rx, ry) {
                if (ry === 0) {
                    if (rx === 1) {
                        x = n - 1 - x;
                        y = n - 1 - y;
                    }
                    [x, y] = [y, x];
                }
                return [x, y];
            }
        }

        class CellCoordinate extends GridCoordinate {
            constructor(cellSizeX, cellSizeY, cellSizeZ, cellAlgorithm, chunkGrid, chunkSizeX, chunkSizeY, chunkSizeZ, cache) {
                super(cellSizeX, cellSizeY, cellSizeZ, cellAlgorithm, cache);
                this.chunkGrid = chunkGrid;
                this.chunkSizeX = chunkSizeX;
                this.chunkSizeY = chunkSizeY;
                this.chunkSizeZ = chunkSizeZ;
            }

            getParentChunk(cellX, cellY, cellZ = 0) {
                return {
                    x: Math.floor(cellX / this.chunkSizeX),
                    y: Math.floor(cellY / this.chunkSizeY),
                    z: Math.floor(cellZ / this.chunkSizeZ)
                };
            }

            getGlobalIndex(cellX, cellY, cellZ = 0) {
                const chunk = this.getParentChunk(cellX, cellY, cellZ);

                // Get the linearized chunk position from the chunk grid
                let chunkIndex = this.chunkGrid.linearize(chunk.x, chunk.y, chunk.z);

                // For space-filling curves, we need to normalize the chunk index like the original code
                if (this.chunkGrid.algorithm === 'z-order' || this.chunkGrid.algorithm === 'hilbert') {
                    chunkIndex = this.getNormalizedChunkIndex(chunkIndex, chunk);
                }

                // Calculate cells before this chunk
                const cellsBeforeThisChunk = this.calculateCellsBeforeChunk(chunkIndex);

                // Get local cell position within this chunk
                const localCellIndex = this.getLocalCellIndex(cellX, cellY, cellZ, chunk);

                return cellsBeforeThisChunk + localCellIndex;
            }

            getLocalCellIndex(cellX, cellY, cellZ, chunk) {
                // Calculate the bounds of this chunk in cell coordinates
                const chunkStartX = chunk.x * this.chunkSizeX;
                const chunkStartY = chunk.y * this.chunkSizeY;
                const chunkStartZ = chunk.z * this.chunkSizeZ;
                const chunkEndX = Math.min(chunkStartX + this.chunkSizeX, this.sizeX);
                const chunkEndY = Math.min(chunkStartY + this.chunkSizeY, this.sizeY);
                const chunkEndZ = Math.min(chunkStartZ + this.chunkSizeZ, this.sizeZ);

                // Calculate local coordinates within this specific chunk
                const localX = cellX - chunkStartX;
                const localY = cellY - chunkStartY;
                const localZ = cellZ - chunkStartZ;

                // Calculate actual chunk dimensions (handles partial chunks) - THE KEY FIX
                const actualChunkX = chunkEndX - chunkStartX;
                const actualChunkY = chunkEndY - chunkStartY;
                const actualChunkZ = chunkEndZ - chunkStartZ;

                // Get raw linearization position using actual dimensions
                const rawPos = this.calculateLinearPosition(localX, localY, localZ, actualChunkX, actualChunkY, actualChunkZ);

                // For space-filling curves, we need normalization like the original code
                if (this.algorithm === 'z-order' || this.algorithm === 'hilbert') {
                    return this.getNormalizedLocalPosition(rawPos, chunk, actualChunkX, actualChunkY, actualChunkZ);
                }

                return rawPos;
            }

            calculateLinearPosition(x, y, z, sizeX, sizeY, sizeZ) {
                // This replicates the original calculateLinearPosition logic exactly
                switch(this.algorithm) {
                    case 'row-major':
                        return x + y * sizeX + z * sizeX * sizeY;
                    case 'col-major':
                        return y + x * sizeY + z * sizeX * sizeY;
                    case 'z-order':
                        return sizeZ > 1 ? this.mortonEncode3D(x, y, z) : this.mortonEncode2D(x, y);
                    case 'hilbert':
                        if (sizeZ > 1) {
                            return z * sizeX * sizeY + this.hilbertEncode2D(x, y, Math.max(sizeX, sizeY));
                        } else {
                            return this.hilbertEncode2D(x, y, Math.max(sizeX, sizeY));
                        }
                    default:
                        return x + y * sizeX + z * sizeX * sizeY;
                }
            }

            getNormalizedLocalPosition(rawPos, chunk, actualChunkX, actualChunkY, actualChunkZ) {
                // Build the position mapping for this specific chunk (like original getNormalizedCellPosition)
                const cacheKey = JSON.stringify([chunk.x, chunk.y, chunk.z, actualChunkX, actualChunkY, actualChunkZ, this.algorithm]);

                if (!this.localPositionCache) {
                    this.localPositionCache = new Map();
                }

                if (!this.localPositionCache.has(cacheKey)) {
                    // Build all positions for this chunk and sort them
                    const positions = [];
                    for (let lz = 0; lz < actualChunkZ; lz++) {
                        for (let ly = 0; ly < actualChunkY; ly++) {
                            for (let lx = 0; lx < actualChunkX; lx++) {
                                const pos = this.calculateLinearPosition(lx, ly, lz, actualChunkX, actualChunkY, actualChunkZ);
                                positions.push(pos);
                            }
                        }
                    }
                    positions.sort((a, b) => a - b);

                    const positionMap = new Map();
                    positions.forEach((pos, seqIndex) => {
                        positionMap.set(pos, seqIndex);
                    });
                    this.localPositionCache.set(cacheKey, positionMap);
                }

                const positionMap = this.localPositionCache.get(cacheKey);
                const result = positionMap.get(rawPos);
                if (result === undefined) {
                    throw new Error(`Invalid rawPos ${rawPos} not found in position map for chunk`);
                }
                return result;
            }

            getNormalizedChunkIndex(rawChunkIndex, chunk) {
                // Build the normalization map for the chunk grid (like original code)
                const chunksX = this.chunkGrid.sizeX;
                const chunksY = this.chunkGrid.sizeY;
                const chunksZ = this.chunkGrid.sizeZ;
                const cacheKey = JSON.stringify([chunksX, chunksY, chunksZ, this.chunkGrid.algorithm]);

                if (!this.chunkNormalizationCache) {
                    this.chunkNormalizationCache = new Map();
                }

                if (!this.chunkNormalizationCache.has(cacheKey)) {
                    // Build all chunk positions and sort them like the original code
                    const positions = [];
                    for (let cz = 0; cz < chunksZ; cz++) {
                        for (let cy = 0; cy < chunksY; cy++) {
                            for (let cx = 0; cx < chunksX; cx++) {
                                const rawPos = this.chunkGrid.calculateLinearPosition(cx, cy, cz);
                                positions.push({ rawPos, cx, cy, cz });
                            }
                        }
                    }
                    positions.sort((a, b) => a.rawPos - b.rawPos);

                    const normalizationMap = new Map();
                    const reverseMap = new Map();
                    positions.forEach((item, seqIndex) => {
                        normalizationMap.set(item.rawPos, seqIndex);
                        reverseMap.set(seqIndex, { x: item.cx, y: item.cy, z: item.cz });
                    });
                    this.chunkNormalizationCache.set(cacheKey, normalizationMap);
                    this.chunkNormalizationCache.set(cacheKey + '-reverse', reverseMap);
                }

                const normalizationMap = this.chunkNormalizationCache.get(cacheKey);
                const result = normalizationMap.get(rawChunkIndex);
                if (result === undefined) {
                    throw new Error(`Invalid rawChunkIndex ${rawChunkIndex} not found in normalization map`);
                }
                return result;
            }

            calculateCellsBeforeChunk(chunkIndex) {
                let cellsBeforeThisChunk = 0;

                // Iterate through all chunks before this one in linearization order
                for (let i = 0; i < chunkIndex; i++) {
                    // Get chunk coordinates from sequential index
                    const chunkCoords = this.delinearizeChunkIndex(i);

                    // Calculate actual cells in that chunk using direct bounds calculation
                    const chunkStartX = chunkCoords.x * this.chunkSizeX;
                    const chunkStartY = chunkCoords.y * this.chunkSizeY;
                    const chunkStartZ = chunkCoords.z * this.chunkSizeZ;
                    const chunkEndX = Math.min(chunkStartX + this.chunkSizeX, this.sizeX);
                    const chunkEndY = Math.min(chunkStartY + this.chunkSizeY, this.sizeY);
                    const chunkEndZ = Math.min(chunkStartZ + this.chunkSizeZ, this.sizeZ);

                    const actualCellsInChunk = (chunkEndX - chunkStartX) * (chunkEndY - chunkStartY) * (chunkEndZ - chunkStartZ);
                    cellsBeforeThisChunk += actualCellsInChunk;
                }

                return cellsBeforeThisChunk;
            }

            delinearizeChunkIndex(chunkIndex) {
                // Use the chunk grid dimensions, not the cell grid dimensions
                const chunksX = this.chunkGrid.sizeX;
                const chunksY = this.chunkGrid.sizeY;
                const chunksZ = this.chunkGrid.sizeZ;

                // For space-filling curves, use the reverse map from normalization
                if (this.chunkGrid.algorithm === 'z-order' || this.chunkGrid.algorithm === 'hilbert') {
                    const cacheKey = JSON.stringify([chunksX, chunksY, chunksZ, this.chunkGrid.algorithm]);
                    if (this.chunkNormalizationCache && this.chunkNormalizationCache.has(cacheKey + '-reverse')) {
                        const reverseMap = this.chunkNormalizationCache.get(cacheKey + '-reverse');
                        const result = reverseMap.get(chunkIndex);
                        if (result === undefined) {
                            throw new Error(`Invalid chunkIndex ${chunkIndex} not found in reverse map`);
                        }
                        return result;
                    }
                }

                // For row-major and col-major, use direct calculation
                switch(this.chunkGrid.algorithm) {
                    case 'row-major':
                        const z_rm = Math.floor(chunkIndex / (chunksX * chunksY));
                        const xyIndex_rm = chunkIndex % (chunksX * chunksY);
                        return {
                            x: xyIndex_rm % chunksX,
                            y: Math.floor(xyIndex_rm / chunksX),
                            z: z_rm
                        };
                    case 'col-major':
                        const z_cm = Math.floor(chunkIndex / (chunksX * chunksY));
                        const xyIndex_cm = chunkIndex % (chunksX * chunksY);
                        return {
                            x: Math.floor(xyIndex_cm / chunksY),
                            y: xyIndex_cm % chunksY,
                            z: z_cm
                        };
                    default:
                        // Fallback to row-major
                        const z_default = Math.floor(chunkIndex / (chunksX * chunksY));
                        const xyIndex_default = chunkIndex % (chunksX * chunksY);
                        return {
                            x: xyIndex_default % chunksX,
                            y: Math.floor(xyIndex_default / chunksX),
                            z: z_default
                        };
                }
            }
        }

        const PRESET_CONFIGS = {
            'small-tiles': {
                name: 'Small Tiles vs Large Query',
                cellAlgorithm: 'row-major',
                chunkAlgorithm: 'row-major',
                sizeX: 32, sizeY: 32, sizeZ: 1,
                chunkX: 2, chunkY: 2, chunkZ: 1,
                queryX1: 8, queryX2: 24, queryY1: 8, queryY2: 24,
                queryZ1: 0, queryZ2: 0
            },
            'large-tiles': {
                name: 'Large Tiles vs Small Query',
                cellAlgorithm: 'row-major',
                chunkAlgorithm: 'row-major',
                sizeX: 32, sizeY: 32, sizeZ: 1,
                chunkX: 16, chunkY: 16, chunkZ: 1,
                queryX1: 10, queryX2: 14, queryY1: 10, queryY2: 14,
                queryZ1: 0, queryZ2: 0
            },
            'row-vs-col': {
                name: 'Row-Major vs Column-Major',
                cellAlgorithm: 'col-major',
                chunkAlgorithm: 'row-major',
                sizeX: 16, sizeY: 16, sizeZ: 1,
                chunkX: 4, chunkY: 8, chunkZ: 1,
                queryX1: 2, queryX2: 6, queryY1: 4, queryY2: 12,
                queryZ1: 0, queryZ2: 0
            },
            'spatial-locality': {
                name: 'Spatial Locality Comparison',
                cellAlgorithm: 'hilbert',
                chunkAlgorithm: 'hilbert',
                sizeX: 16, sizeY: 16, sizeZ: 1,
                chunkX: 4, chunkY: 4, chunkZ: 1,
                queryX1: 6, queryX2: 9, queryY1: 6, queryY2: 9,
                queryZ1: 0, queryZ2: 0
            },
            'fragmentation': {
                name: 'High Fragmentation Scenario',
                cellAlgorithm: 'z-order',
                chunkAlgorithm: 'col-major',
                sizeX: 20, sizeY: 20, sizeZ: 1,
                chunkX: 3, chunkY: 3, chunkZ: 1,
                queryX1: 1, queryX2: 18, queryY1: 5, queryY2: 7,
                queryZ1: 0, queryZ2: 0
            },
            'perfect-alignment': {
                name: 'Perfect Chunk Alignment',
                cellAlgorithm: 'row-major',
                chunkAlgorithm: 'row-major',
                sizeX: 16, sizeY: 16, sizeZ: 1,
                chunkX: 4, chunkY: 4, chunkZ: 1,
                queryX1: 4, queryX2: 7, queryY1: 4, queryY2: 7,
                queryZ1: 0, queryZ2: 0
            }
        };

        const DEFAULT_USER_SETTINGS = {
            cellAlgorithm: 'row-major',
            chunkAlgorithm: 'row-major',
            sizeX: 16,
            sizeY: 16,
            sizeZ: 1,
            chunkX: 4,
            chunkY: 4,
            chunkZ: 1,
            queryX1: 3,
            queryX2: 10,
            queryY1: 3,
            queryY2: 10,
            queryZ1: 0,
            queryZ2: 0
        };

        const DEFAULT_APP_STATE = {
            currentPreset: 'user',
            presets: {
                user: DEFAULT_USER_SETTINGS
                // Other preset states get copied here as user modifies them
            }
        };

        class TooltipManager {
            constructor(tooltipElement) {
                this.tooltip = tooltipElement;
                this.isSticky = false;
            }

            show(e, content, sticky = false) {
                this.tooltip.style.display = 'block';
                this.tooltip.style.position = 'absolute';
                this.tooltip.style.left = `${e.clientX + window.scrollX + 10}px`;
                this.tooltip.style.top = `${e.clientY + window.scrollY - 30}px`;
                this.tooltip.style.transform = 'none';
                this.tooltip.style.margin = '0';
                this.tooltip.textContent = content;
                this.isSticky = sticky;
            }

            hide() {
                this.tooltip.style.display = 'none';
                this.isSticky = false;
            }

            updateContent(content) {
                this.tooltip.textContent = content;
            }

            updatePosition(e) {
                if (this.tooltip.style.display === 'block') {
                    this.tooltip.style.left = `${e.clientX + window.scrollX + 10}px`;
                    this.tooltip.style.top = `${e.clientY + window.scrollY - 30}px`;
                }
            }

            hideIfNotSticky() {
                if (!this.isSticky) {
                    this.hide();
                }
            }
        }

        class SelectionState {
            constructor() {
                this.hoveredCell = null;
                this.hoveredChunk = null;
                this.selectedCell = null;
                this.selectedChunk = null;
            }

            setHoveredCell(cell) {
                this.hoveredCell = cell;
            }

            setHoveredChunk(chunk) {
                this.hoveredChunk = chunk;
            }

            setSelectedCell(cell) {
                this.selectedCell = cell;
            }

            setSelectedChunk(chunk) {
                this.selectedChunk = chunk;
            }

            clearHover() {
                this.hoveredCell = null;
                this.hoveredChunk = null;
            }

            clearSelection() {
                this.selectedCell = null;
                this.selectedChunk = null;
            }

            clearAll() {
                this.clearHover();
                this.clearSelection();
            }

            getEffectiveCell() {
                return this.selectedCell || this.hoveredCell;
            }

            getEffectiveChunk() {
                return this.selectedChunk || this.hoveredChunk;
            }

            isSelected(cell, chunk) {
                const sameCell = cell && this.selectedCell &&
                    cell.x === this.selectedCell.x && cell.y === this.selectedCell.y;
                const sameChunk = chunk && this.selectedChunk &&
                    chunk.x === this.selectedChunk.x && chunk.y === this.selectedChunk.y;
                return sameCell || sameChunk;
            }

            hasSelection() {
                return this.selectedCell || this.selectedChunk;
            }
        }

        class CoordinateService {
            constructor() {
                this.cellLayoutCache = new LRUCache(CONFIG.LRU_CONFIG_CACHE_SIZE);
                this.linearLayoutCache = new LRUCache(CONFIG.LRU_CONFIG_CACHE_SIZE);
            }

            getCanvasCoordinates(e, canvas) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

            getSpatialCellLayout(canvas, sizeX, sizeY) {
                const dpr = window.devicePixelRatio || 1;
                const cacheKey = JSON.stringify([canvas.width, canvas.height, sizeX, sizeY, dpr]);
                if (this.cellLayoutCache.has(cacheKey)) {
                    return this.cellLayoutCache.get(cacheKey);
                }

                const logicalWidth = canvas.width / dpr;
                const logicalHeight = canvas.height / dpr;
                const cellSize = Math.min(logicalWidth / sizeX, logicalHeight / sizeY) * 0.9;
                const offsetX = (logicalWidth - sizeX * cellSize) / 2;
                const offsetY = (logicalHeight - sizeY * cellSize) / 2;

                const layout = { cellSize, offsetX, offsetY };
                this.cellLayoutCache.set(cacheKey, layout);
                return layout;
            }

            getSpatialCellCoordinates(canvasX, canvasY, canvas, params) {
                const [sizeX, sizeY] = params.size;

                // Convert canvas coordinates to logical coordinates
                const dpr = window.devicePixelRatio || 1;
                const logicalX = canvasX / dpr;
                const logicalY = canvasY / dpr;

                const { cellSize, offsetX, offsetY } = this.getSpatialCellLayout(canvas, sizeX, sizeY);

                const cellX = Math.floor((logicalX - offsetX) / cellSize);
                const cellY = Math.floor((logicalY - offsetY) / cellSize);

                return {
                    cellX,
                    cellY,
                    isValid: cellX >= 0 && cellX < sizeX && cellY >= 0 && cellY < sizeY,
                    layout: { cellSize, offsetX, offsetY }
                };
            }

            getLinearBarLayout(canvas, totalCells) {
                const dpr = window.devicePixelRatio || 1;
                const cacheKey = JSON.stringify([canvas.width, canvas.height, totalCells, dpr]);
                if (this.linearLayoutCache.has(cacheKey)) {
                    return this.linearLayoutCache.get(cacheKey);
                }

                const logicalWidth = canvas.width / dpr;
                const cellWidth = (logicalWidth - 40) / totalCells;
                const barHeight = 60;
                const offsetX = 20;
                const offsetY = 20;

                const layout = { cellWidth, barHeight, offsetX, offsetY };
                this.linearLayoutCache.set(cacheKey, layout);
                return layout;
            }

            getLinearCellCoordinates(canvasX, canvasY, canvas, data) {
                const { cellWidth, barHeight, offsetX, offsetY } = this.getLinearBarLayout(canvas, data.totalCells);

                const dpr = window.devicePixelRatio || 1;
                const logicalX = canvasX / dpr;
                const logicalY = canvasY / dpr;

                const isInBar = logicalY >= offsetY && logicalY <= offsetY + barHeight;
                const cellIndex = Math.floor((logicalX - offsetX) / cellWidth);
                const isValidIndex = cellIndex >= 0 && cellIndex < data.totalCells;

                return {
                    cellIndex,
                    isValid: isInBar && isValidIndex,
                    layout: { cellWidth, barHeight, offsetX, offsetY }
                };
            }


            getChunkCoordinatesFromCell(cellX, cellY, chunkX, chunkY) {
                return {
                    x: Math.floor(cellX / chunkX),
                    y: Math.floor(cellY / chunkY)
                };
            }

            clearCache() {
                this.cellLayoutCache.clear();
                this.linearLayoutCache.clear();
            }
        }


        class TooltipContentGenerator {
            static generateCellTooltip(cell, params, visualizer) {
                const intraChunkPos = visualizer.simulationModel.getIntraChunkPosition(cell.x, cell.y, 0, params);
                const globalPos = visualizer.simulationModel.getGlobalPosition(cell.x, cell.y, 0, params);
                return `Cell (${cell.x}, ${cell.y}) → Intra-chunk: ${intraChunkPos}, Global: ${globalPos}`;
            }

            static generateChunkTooltip(chunk, params, sizeX, sizeY, chunkX, chunkY, visualizer) {
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunkIdx = chunk.x + chunk.y * chunksX;
                const bounds = visualizer.simulationModel.getChunkBounds(chunk.x, chunk.y, chunkX, chunkY, sizeX, sizeY);
                const interChunkPos = visualizer.simulationModel.getInterChunkPosition(bounds.startX, bounds.startY, 0, params);

                return `Chunk ${chunkIdx}: cells (${bounds.startX},${bounds.startY}) to (${bounds.endX - 1},${bounds.endY - 1}), Linear pos: ${interChunkPos}`;
            }
        }

        class BaseCanvasRenderer {
            constructor(canvas, context, visualizer, coordinateService) {
                this.canvas = canvas;
                this.ctx = context;
                this.visualizer = visualizer;
                this.coordinateService = coordinateService;
            }

            getLogicalDimensions() {
                return {
                    width: this.canvas.width / (window.devicePixelRatio || 1),
                    height: this.canvas.height / (window.devicePixelRatio || 1)
                };
            }

            clearCanvas() {
                const { width, height } = this.getLogicalDimensions();
                this.ctx.clearRect(0, 0, width, height);
            }

            drawCellHighlight(x, y, cellSize, offsetX, offsetY, fillStyle = 'rgba(255, 255, 255, 0.4)', strokeStyle = '#fff', lineWidth = 3) {
                this.ctx.fillStyle = fillStyle;
                this.ctx.fillRect(
                    offsetX + x * cellSize,
                    offsetY + y * cellSize,
                    cellSize - 1,
                    cellSize - 1
                );

                this.ctx.strokeStyle = strokeStyle;
                this.ctx.lineWidth = lineWidth;
                this.ctx.strokeRect(
                    offsetX + x * cellSize,
                    offsetY + y * cellSize,
                    cellSize - 1,
                    cellSize - 1
                );
            }

            drawRectHighlight(startX, startY, endX, endY, cellSize, offsetX, offsetY, fillStyle = 'rgba(255, 255, 255, 0.4)', strokeStyle = '#fff', lineWidth = 3) {
                const width = (endX - startX) * cellSize - 1;
                const height = (endY - startY) * cellSize - 1;

                if (fillStyle) {
                    this.ctx.fillStyle = fillStyle;
                    this.ctx.fillRect(offsetX + startX * cellSize, offsetY + startY * cellSize, width, height);
                }

                if (strokeStyle) {
                    this.ctx.strokeStyle = strokeStyle;
                    this.ctx.lineWidth = lineWidth;
                    this.ctx.strokeRect(offsetX + startX * cellSize, offsetY + startY * cellSize, width, height);
                }
            }

            drawQueryRegionOutline(query, sizeX, sizeY, cellSize, offsetX, offsetY) {
                this.ctx.strokeStyle = '#4a9eff';
                this.ctx.lineWidth = 3;
                const x1 = Math.max(0, query.x[0]);
                const y1 = Math.max(0, query.y[0]);
                const x2 = Math.min(sizeX - 1, query.x[1]);
                const y2 = Math.min(sizeY - 1, query.y[1]);

                this.ctx.strokeRect(
                    offsetX + x1 * cellSize,
                    offsetY + y1 * cellSize,
                    (x2 - x1 + 1) * cellSize - 1,
                    (y2 - y1 + 1) * cellSize - 1
                );
            }

            drawLinearBar(cellWidth, barHeight, offsetX, offsetY, totalCells, getColorForPosition) {
                if (cellWidth < 1) {
                    this.drawLinearGradientBar(offsetX, offsetY, totalCells * cellWidth, barHeight);
                } else {
                    this.drawLinearCellBar(cellWidth, barHeight, offsetX, offsetY, totalCells, getColorForPosition);
                }
            }

            drawLinearGradientBar(offsetX, offsetY, width, barHeight) {
                const gradient = this.ctx.createLinearGradient(offsetX, offsetY, offsetX + width, offsetY);
                gradient.addColorStop(0, '#00ff00');
                gradient.addColorStop(1, '#ff0000');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(offsetX, offsetY, width, barHeight);
            }

            drawLinearCellBar(cellWidth, barHeight, offsetX, offsetY, totalCells, getColorForPosition) {
                for (let i = 0; i < totalCells; i++) {
                    const color = getColorForPosition(i, totalCells);
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(offsetX + i * cellWidth, offsetY, cellWidth, barHeight);
                }
            }

            drawByteRanges(ranges, cellWidth, barHeight, offsetX, offsetY, label) {
                const { width } = this.getLogicalDimensions();
                const gap = 3

                this.ctx.strokeStyle = '#4a9eff';
                this.ctx.lineWidth = 2;

                ranges.forEach(([start, end]) => {
                    const x1 = offsetX + start * cellWidth;
                    const x2 = offsetX + (end + 1) * cellWidth;

                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, offsetY + barHeight + 5 + gap);
                    this.ctx.lineTo(x2, offsetY + barHeight + 5 + gap);
                    this.ctx.stroke();

                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, offsetY + barHeight + gap);
                    this.ctx.lineTo(x1, offsetY + barHeight + 10 + gap);
                    this.ctx.moveTo(x2, offsetY + barHeight + gap);
                    this.ctx.lineTo(x2, offsetY + barHeight + 10 + gap);
                    this.ctx.stroke();
                });

                this.ctx.fillStyle = '#aaa';
                this.ctx.font = '11px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`${ranges.length} ${label}`, width / 2, offsetY + barHeight + 25 + gap);
            }

            highlightCoalescedRanges(positions, cellWidth, barHeight, offsetX, offsetY) {
                if (positions.length === 0) return;

                // Sort positions
                const sortedPositions = [...positions].sort((a, b) => a - b);

                // Coalesce contiguous ranges
                const coalescedRanges = [];
                let currentRange = { min: sortedPositions[0], max: sortedPositions[0] };

                for (let i = 1; i < sortedPositions.length; i++) {
                    const pos = sortedPositions[i];
                    // If this position is contiguous with the current range, extend it
                    if (pos <= currentRange.max + 1) {
                        currentRange.max = pos;
                    } else {
                        // Start a new range
                        coalescedRanges.push(currentRange);
                        currentRange = { min: pos, max: pos };
                    }
                }
                // Don't forget the last range
                coalescedRanges.push(currentRange);

                // Draw outline around each coalesced range
                this.ctx.strokeStyle = '#4a9eff';
                this.ctx.lineWidth = 2;
                coalescedRanges.forEach(range => {
                    const rangeWidth = (range.max - range.min + 1) * cellWidth;
                    this.ctx.strokeRect(offsetX + range.min * cellWidth, offsetY, rangeWidth, barHeight);
                });
            }

            drawLinearChunkHighlight(chunkRange, cellWidth, barHeight, offsetX, offsetY, showOutline = false) {
                if (!chunkRange) return;

                const chunkCellCount = chunkRange.positions.length;
                const chunkPixelWidth = chunkCellCount * cellWidth;

                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.fillRect(offsetX + chunkRange.min * cellWidth, offsetY, chunkPixelWidth, barHeight);

                if (showOutline) {
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(offsetX + chunkRange.min * cellWidth, offsetY, chunkPixelWidth, barHeight);
                }
            }

            // Template method for rendering - to be implemented by subclasses
            render(params, data) {
                throw new Error('render() must be implemented by subclass');
            }
        }

        class SpatialUnchunkedRenderer extends BaseCanvasRenderer {
            render(params, data) {
                this.clearCanvas();

                const [sizeX, sizeY] = params.size;
                const { cellSize, offsetX, offsetY } = this.coordinateService.getSpatialCellLayout(this.canvas, sizeX, sizeY);

                this.drawCellGrid(params, data, sizeX, sizeY, cellSize, offsetX, offsetY);
                this.drawSpatialHighlights(params, sizeX, sizeY, cellSize, offsetX, offsetY);
                this.drawQueryRegionOutline(params.query, sizeX, sizeY, cellSize, offsetX, offsetY);
            }

            drawCellGrid(params, data, sizeX, sizeY, cellSize, offsetX, offsetY) {
                if (cellSize > CONFIG.MIN_CELL_SIZE) {
                    this.drawDetailedCellGrid(params, data, sizeX, sizeY, cellSize, offsetX, offsetY);
                } else {
                    const gradient = this.ctx.createLinearGradient(offsetX, offsetY, offsetX + sizeX * cellSize, offsetY + sizeY * cellSize);
                    gradient.addColorStop(0, '#00ff00');
                    gradient.addColorStop(1, '#ff0000');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(offsetX, offsetY, sizeX * cellSize, sizeY * cellSize);
                }
            }

            drawDetailedCellGrid(params, data, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const { width: logicalWidth } = this.getLogicalDimensions();

                if (cellSize < CONFIG.VIEWPORT_CELL_SIZE && data.totalCells > 1000) {
                    const startX = Math.max(0, Math.floor(-offsetX / cellSize));
                    const endX = Math.min(sizeX, Math.ceil((logicalWidth - offsetX) / cellSize));
                    const startY = Math.max(0, Math.floor(-offsetY / cellSize));
                    const endY = Math.min(sizeY, Math.ceil((logicalWidth - offsetY) / cellSize));
                    this.drawCellRange(params, data, startX, endX, startY, endY, cellSize, offsetX, offsetY);
                } else {
                    this.drawCellRange(params, data, 0, sizeX, 0, sizeY, cellSize, offsetX, offsetY);
                }
            }

            drawCellRange(params, data, startX, endX, startY, endY, cellSize, offsetX, offsetY) {
                for (let y = startY; y < endY; y++) {
                    for (let x = startX; x < endX; x++) {
                        const globalPos = this.visualizer.simulationModel.getGlobalPosition(x, y, 0, params);
                        const color = this.visualizer.getColorForLinearPosition(globalPos, data.totalCells - 1);

                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(
                            offsetX + x * cellSize,
                            offsetY + y * cellSize,
                            cellSize - 1,
                            cellSize - 1
                        );
                    }
                }
            }

            drawSpatialHighlights(params, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const effectiveCell = this.visualizer.getEffectiveCell();
                const effectiveChunk = this.visualizer.getEffectiveChunk();

                if (cellSize > CONFIG.MIN_CELL_SIZE && effectiveCell) {
                    this.drawCellHighlight(effectiveCell.x, effectiveCell.y, cellSize, offsetX, offsetY);
                }

                if (effectiveChunk && !effectiveCell) {
                    this.drawChunkCellHighlights(params, effectiveChunk, sizeX, sizeY, cellSize, offsetX, offsetY);
                }
            }

            drawChunkCellHighlights(params, effectiveChunk, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const [chunkSizeX, chunkSizeY] = params.chunk;
                const bounds = this.visualizer.simulationModel.getChunkBounds(effectiveChunk.x, effectiveChunk.y, chunkSizeX, chunkSizeY, sizeX, sizeY);
                this.drawRectHighlight(bounds.startX, bounds.startY, bounds.endX, bounds.endY, cellSize, offsetX, offsetY);
            }
        }

        class SpatialChunkedRenderer extends BaseCanvasRenderer {
            render(params, data) {
                this.clearCanvas();

                const [sizeX, sizeY, sizeZ] = params.size;
                const { cellSize, offsetX, offsetY } = this.coordinateService.getSpatialCellLayout(this.canvas, sizeX, sizeY);

                const chunkColorMap = this.visualizer.simulationModel.getOrCreateChunkColorMap(params, sizeX, sizeY, sizeZ);
                this.drawChunkGrid(params, chunkColorMap, sizeX, sizeY, sizeZ, cellSize, offsetX, offsetY);
                this.drawChunkedViewHighlights(params, data, sizeX, sizeY, cellSize, offsetX, offsetY);
            }

            drawChunkGrid(params, chunkColorMap, sizeX, sizeY, sizeZ, cellSize, offsetX, offsetY) {
                const chunkGridInfo = this.calculateChunkGridInfo(params, sizeX, sizeY, sizeZ, cellSize, offsetX, offsetY);

                for (let chunkCY = chunkGridInfo.startChunkY; chunkCY < chunkGridInfo.endChunkY; chunkCY++) {
                    for (let chunkCX = chunkGridInfo.startChunkX; chunkCX < chunkGridInfo.endChunkX; chunkCX++) {
                        this.drawSingleChunk(chunkColorMap, chunkCX, chunkCY, chunkGridInfo.totalChunks,
                                           params, sizeX, sizeY, cellSize, offsetX, offsetY);
                    }
                }
            }

            calculateChunkGridInfo(params, sizeX, sizeY, sizeZ, cellSize, offsetX, offsetY) {
                const [chunkX, chunkY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const chunksZ = Math.ceil(Math.max(1, sizeZ) / Math.max(1, params.chunk[2]));

                const { width: logicalWidth, height: logicalHeight } = this.getLogicalDimensions();
                const viewport = this.getChunkViewport(
                    chunksX, chunksY, cellSize, chunkX, chunkY, offsetX, offsetY, logicalWidth, logicalHeight
                );

                return {
                    chunksX,
                    chunksY,
                    chunksZ,
                    totalChunks: chunksX * chunksY * chunksZ,
                    ...viewport
                };
            }

            getChunkViewport(chunksX, chunksY, cellSize, chunkX, chunkY, offsetX, offsetY, logicalWidth, logicalHeight) {
                if (cellSize < CONFIG.VIEWPORT_CELL_SIZE && chunksX * chunksY > 100) {
                    return {
                        startChunkX: Math.max(0, Math.floor(-offsetX / (chunkX * cellSize))),
                        endChunkX: Math.min(chunksX, Math.ceil((logicalWidth - offsetX) / (chunkX * cellSize))),
                        startChunkY: Math.max(0, Math.floor(-offsetY / (chunkY * cellSize))),
                        endChunkY: Math.min(chunksY, Math.ceil((logicalHeight - offsetY) / (chunkY * cellSize)))
                    };
                }
                return { startChunkX: 0, endChunkX: chunksX, startChunkY: 0, endChunkY: chunksY };
            }

            drawSingleChunk(chunkColorMap, chunkCX, chunkCY, totalChunks, params, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const [chunkX, chunkY] = params.chunk;
                const chunkCZ = 0;
                const chunkKey = `${chunkCX},${chunkCY},${chunkCZ}`;
                const colorIndex = chunkColorMap.get(chunkKey);
                const color = this.visualizer.getColorForLinearPosition(colorIndex, totalChunks - 1);

                const bounds = this.visualizer.simulationModel.getChunkBounds(chunkCX, chunkCY, chunkX, chunkY, sizeX, sizeY);
                const chunkPixelWidth = (bounds.endX - bounds.startX) * cellSize;
                const chunkPixelHeight = (bounds.endY - bounds.startY) * cellSize;

                this.ctx.fillStyle = color;
                this.ctx.fillRect(
                    offsetX + bounds.startX * cellSize,
                    offsetY + bounds.startY * cellSize,
                    chunkPixelWidth,
                    chunkPixelHeight
                );

                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(
                    offsetX + bounds.startX * cellSize,
                    offsetY + bounds.startY * cellSize,
                    chunkPixelWidth,
                    chunkPixelHeight
                );
            }

            drawChunkedViewHighlights(params, data, sizeX, sizeY, cellSize, offsetX, offsetY) {
                const effectiveCell = this.visualizer.getEffectiveCell();
                const effectiveChunk = this.visualizer.getEffectiveChunk();
                const [chunkX, chunkY] = params.chunk;

                if (effectiveCell) {
                    const chunkCoords = this.coordinateService.getChunkCoordinatesFromCell(effectiveCell.x, effectiveCell.y, chunkX, chunkY);
                    const bounds = this.visualizer.simulationModel.getChunkBounds(chunkCoords.x, chunkCoords.y, chunkX, chunkY, sizeX, sizeY);
                    this.drawRectHighlight(bounds.startX, bounds.startY, bounds.endX, bounds.endY, cellSize, offsetX, offsetY, 'rgba(255, 255, 255, 0.4)', '#fff');
                }

                this.drawTouchedChunksOutline(data, params, sizeX, sizeY, cellSize, offsetX, offsetY);

                if (effectiveChunk && !effectiveCell) {
                    const bounds = this.visualizer.simulationModel.getChunkBounds(effectiveChunk.x, effectiveChunk.y, chunkX, chunkY, sizeX, sizeY);
                    this.drawRectHighlight(bounds.startX, bounds.startY, bounds.endX, bounds.endY, cellSize, offsetX, offsetY);
                }
            }

            drawTouchedChunksOutline(data, params, sizeX, sizeY, cellSize, offsetX, offsetY) {
                if (data.touchedChunks.size === 0) return;

                const [chunkX, chunkY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);

                let minChunkX = Infinity, minChunkY = Infinity;
                let maxChunkX = -Infinity, maxChunkY = -Infinity;

                data.touchedChunks.forEach(chunkIdx => {
                    const chunkCY = Math.floor(chunkIdx / chunksX);
                    const chunkCX = chunkIdx % chunksX;
                    minChunkX = Math.min(minChunkX, chunkCX);
                    minChunkY = Math.min(minChunkY, chunkCY);
                    maxChunkX = Math.max(maxChunkX, chunkCX);
                    maxChunkY = Math.max(maxChunkY, chunkCY);
                });

                const startX = minChunkX * chunkX;
                const startY = minChunkY * chunkY;
                const endX = Math.min((maxChunkX + 1) * chunkX, sizeX);
                const endY = Math.min((maxChunkY + 1) * chunkY, sizeY);

                this.ctx.strokeStyle = '#4a9eff';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(
                    offsetX + startX * cellSize,
                    offsetY + startY * cellSize,
                    (endX - startX) * cellSize - 1,
                    (endY - startY) * cellSize - 1
                );
            }
        }

        class LinearUnchunkedRenderer extends BaseCanvasRenderer {
            render(params, data) {
                this.clearCanvas();

                const { cellWidth, barHeight, offsetX, offsetY } = this.coordinateService.getLinearBarLayout(this.canvas, data.totalCells);

                this.drawLinearBar(cellWidth, barHeight, offsetX, offsetY, data.totalCells,
                                (i, total) => this.visualizer.getColorForLinearPosition(i, total));

                const requestedPositions = this.getRequestedCellPositions(data, params);
                this.highlightCoalescedRanges(requestedPositions, cellWidth, barHeight, offsetX, offsetY);

                this.drawLinearUnchunkedHighlights(params, cellWidth, barHeight, offsetX, offsetY);
                this.drawByteRanges(data.unchunkedRanges, cellWidth, barHeight, offsetX, offsetY, 'byte range(s)');
            }

            getRequestedCellPositions(data, params) {
                return [...data.requestedCells].map(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    return this.visualizer.simulationModel.getGlobalPosition(x, y, z, params);
                });
            }


            drawLinearUnchunkedHighlights(params, cellWidth, barHeight, offsetX, offsetY) {
                const effectiveCell = this.visualizer.getEffectiveCell();
                const effectiveChunk = this.visualizer.getEffectiveChunk();

                if (effectiveChunk) {
                    const chunkRange = this.visualizer.simulationModel.getChunkGlobalRange(effectiveChunk.x, effectiveChunk.y, params);
                    this.drawLinearChunkHighlight(chunkRange, cellWidth, barHeight, offsetX, offsetY, !effectiveCell);
                }

                if (effectiveCell) {
                    const pos = this.visualizer.simulationModel.getGlobalPosition(effectiveCell.x, effectiveCell.y, 0, params);
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(offsetX + pos * cellWidth, offsetY, cellWidth, barHeight);
                }
            }
        }

        class LinearChunkedRenderer extends BaseCanvasRenderer {
            render(params, data) {
                this.clearCanvas();

                const { cellWidth, barHeight, offsetX, offsetY } = this.coordinateService.getLinearBarLayout(this.canvas, data.totalCells);
                const [sizeX, sizeY, sizeZ] = params.size;

                const spatialChunkColorMap = this.visualizer.simulationModel.getOrCreateChunkColorMap(params, sizeX, sizeY, sizeZ);

                this.drawLinearChunks(params, data, spatialChunkColorMap,
                                    cellWidth, barHeight, offsetX, offsetY, sizeX, sizeY, sizeZ);

                this.highlightLinearChunks(params, data, cellWidth, barHeight, offsetX, offsetY);

                this.drawLinearChunkedHighlights(params, cellWidth, barHeight, offsetX, offsetY);
                this.drawByteRanges(data.chunkedRanges, cellWidth, barHeight, offsetX, offsetY, 'byte range(s) with chunking');
            }


            drawLinearChunks(params, data, spatialChunkColorMap, cellWidth, barHeight, offsetX, offsetY, sizeX, sizeY, sizeZ) {
                const [chunkSizeX, chunkSizeY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkSizeX);
                const chunksY = Math.ceil(sizeY / chunkSizeY);
                const chunksZ3D = Math.ceil(Math.max(1, sizeZ) / Math.max(1, params.chunk[2]));
                const totalChunks3D = chunksX * chunksY * chunksZ3D;

                // Create a map of chunks to their global position ranges
                const chunkRanges = new Map();

                for (let cy = 0; cy < chunksY; cy++) {
                    for (let cx = 0; cx < chunksX; cx++) {
                        for (let cz = 0; cz < chunksZ3D; cz++) {
                            const chunkKey = `${cx},${cy},${cz}`;
                            const colorIndex = spatialChunkColorMap.get(chunkKey);

                            if (colorIndex !== undefined) {
                                const chunkRange = this.visualizer.simulationModel.getChunkGlobalRange(cx, cy, params);
                                if (chunkRange && chunkRange.positions.length > 0) {
                                    chunkRanges.set(chunkKey, {
                                        range: chunkRange,
                                        color: this.visualizer.getColorForLinearPosition(colorIndex, totalChunks3D - 1)
                                    });
                                }
                            }
                        }
                    }
                }

                // Draw each chunk as a single rectangle
                chunkRanges.forEach(({ range, color }) => {
                    const chunkPixelWidth = range.positions.length * cellWidth;
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(offsetX + range.min * cellWidth, offsetY, chunkPixelWidth, barHeight);
                });
            }

            highlightLinearChunks(params, data, cellWidth, barHeight, offsetX, offsetY) {
                const [chunkSizeX, chunkSizeY] = params.chunk;
                const chunksX = Math.ceil(params.size[0] / chunkSizeX);

                const allPositions = [];

                // Get all positions from all touched chunks
                data.touchedChunks.forEach(chunkIdx => {
                    const chunkCY = Math.floor(chunkIdx / chunksX);
                    const chunkCX = chunkIdx % chunksX;
                    const chunkRange = this.visualizer.simulationModel.getChunkGlobalRange(chunkCX, chunkCY, params);

                    if (chunkRange && chunkRange.positions.length > 0) {
                        allPositions.push(...chunkRange.positions);
                    }
                });

                // Use the shared coalescing function
                this.highlightCoalescedRanges(allPositions, cellWidth, barHeight, offsetX, offsetY);
            }

            drawLinearChunkedHighlights(params, cellWidth, barHeight, offsetX, offsetY) {
                const effectiveChunk = this.visualizer.getEffectiveChunk();

                if (effectiveChunk) {
                    const chunkRange = this.visualizer.simulationModel.getChunkGlobalRange(effectiveChunk.x, effectiveChunk.y, params);
                    const showOutline = true;
                    this.drawLinearChunkHighlight(chunkRange, cellWidth, barHeight, offsetX, offsetY, showOutline);
                }
            }
        }

        class InteractionStrategy {
            constructor(visualizer, tooltipManager) {
                this.visualizer = visualizer;
                this.tooltipManager = tooltipManager;
            }

            // Template method for handling mouse moves
            handleMove(e, canvas, canvasKey) {
                const coords = this.visualizer.coordinateService.getCanvasCoordinates(e, canvas);
                const targetInfo = this.getTargetInfo(coords, canvas, canvasKey);

                if (targetInfo) {
                    this.updateHoverState(targetInfo);
                    this.showTooltip(e, targetInfo);
                } else {
                    this.clearHover();
                }
            }

            // Template method for handling clicks
            handleClick(e, canvas, canvasKey) {
                const coords = this.visualizer.coordinateService.getCanvasCoordinates(e, canvas);
                const targetInfo = this.getTargetInfo(coords, canvas, canvasKey);

                this.handleSelectionLogic(e, targetInfo);
            }

            // Abstract methods to be implemented by subclasses
            getTargetInfo(coords, canvas, canvasKey) {
                throw new Error('getTargetInfo must be implemented by subclass');
            }

            updateHoverState(targetInfo) {
                if (targetInfo.cell) {
                    this.visualizer.selectionState.setHoveredCell(targetInfo.cell);
                }
                if (targetInfo.chunk) {
                    this.visualizer.selectionState.setHoveredChunk(targetInfo.chunk);
                }
            }

            showTooltip(e, targetInfo, sticky = false) {
                const params = this.visualizer.getParameters();
                if (targetInfo.cell && targetInfo.usesCellTooltip) {
                    this.tooltipManager.show(e, TooltipContentGenerator.generateCellTooltip(targetInfo.cell, params, this.visualizer), sticky);
                } else if (targetInfo.chunk) {
                    const [sizeX, sizeY] = params.size;
                    const [chunkX, chunkY] = params.chunk;
                    this.tooltipManager.show(e, TooltipContentGenerator.generateChunkTooltip(targetInfo.chunk, params, sizeX, sizeY, chunkX, chunkY, this.visualizer), sticky);
                }
            }

            clearHover() {
                this.visualizer.selectionState.clearHover();
                this.tooltipManager.hideIfNotSticky();
            }

            handleSelectionLogic(e, targetInfo) {
                const clickedCell = targetInfo?.cell;
                const clickedChunk = targetInfo?.chunk;

                if (clickedCell || clickedChunk) {
                    // Check if clicking on already selected item to deselect
                    if (this.visualizer.selectionState.isSelected(clickedCell, clickedChunk)) {
                        this.visualizer.selectionState.clearSelection();
                        this.tooltipManager.hide();
                    } else {
                        // Select new item
                        this.visualizer.selectionState.setSelectedCell(clickedCell);
                        this.visualizer.selectionState.setSelectedChunk(clickedChunk);
                        this.showTooltip(e, targetInfo, true); // Make tooltip sticky
                    }
                } else {
                    // Clicked outside any item - clear selection
                    this.visualizer.selectionState.clearSelection();
                    this.tooltipManager.hide();
                }
            }
        }

        class SpatialUnchunkedStrategy extends InteractionStrategy {
            getTargetInfo(coords, canvas, canvasKey) {
                const params = this.visualizer.getParameters();
                const { cellX, cellY, isValid } = this.visualizer.coordinateService.getSpatialCellCoordinates(coords.x, coords.y, canvas, params);

                if (!isValid) return null;

                const [chunkX, chunkY] = params.chunk;
                const cell = { x: cellX, y: cellY };
                const chunk = this.visualizer.coordinateService.getChunkCoordinatesFromCell(cellX, cellY, chunkX, chunkY);

                return { cell, chunk, usesCellTooltip: true };
            }
        }

        class SpatialChunkedStrategy extends InteractionStrategy {
            getTargetInfo(coords, canvas, canvasKey) {
                const params = this.visualizer.getParameters();
                const { cellX, cellY, isValid } = this.visualizer.coordinateService.getSpatialCellCoordinates(coords.x, coords.y, canvas, params);

                if (!isValid) return null;

                const [chunkX, chunkY] = params.chunk;
                const chunk = this.visualizer.coordinateService.getChunkCoordinatesFromCell(cellX, cellY, chunkX, chunkY);

                return { chunk, usesCellTooltip: false };
            }

            updateHoverState(targetInfo) {
                this.visualizer.selectionState.setHoveredChunk(targetInfo.chunk);
                this.visualizer.selectionState.setHoveredCell(null);
            }
        }

        class LinearStrategy extends InteractionStrategy {
            getTargetInfo(coords, canvas, canvasKey) {
                const data = this.visualizer.currentData;
                if (!data) return null;

                const { cellIndex, isValid } = this.visualizer.coordinateService.getLinearCellCoordinates(coords.x, coords.y, canvas, data);
                if (!isValid) return null;

                const params = this.visualizer.getParameters();
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY] = params.chunk;
                const foundCell = this.visualizer.simulationModel.getCellFromLinearIndex(cellIndex, params, sizeX, sizeY, chunkX, chunkY);

                if (!foundCell) return null;

                const cell = { x: foundCell.x, y: foundCell.y };
                const chunk = { x: foundCell.chunkX, y: foundCell.chunkY };
                const usesCellTooltip = canvasKey === 'linearUnchunked';

                return { cell, chunk, usesCellTooltip };
            }

            updateHoverState(targetInfo) {
                const usesCell = targetInfo.usesCellTooltip;
                this.visualizer.selectionState.setHoveredCell(usesCell ? targetInfo.cell : null);
                this.visualizer.selectionState.setHoveredChunk(targetInfo.chunk);
            }
        }

        class InteractionManager {
            constructor(visualizer, canvases, tooltipManager) {
                this.visualizer = visualizer;
                this.canvases = canvases;
                this.tooltipManager = tooltipManager;
                this.mouseThrottle = false;

                // Initialize strategies
                const linearStrategy = new LinearStrategy(visualizer, tooltipManager);
                this.strategies = {
                    spatialUnchunked: new SpatialUnchunkedStrategy(visualizer, tooltipManager),
                    spatialChunked: new SpatialChunkedStrategy(visualizer, tooltipManager),
                    linearUnchunked: linearStrategy,
                    linearChunked: linearStrategy
                };
            }

            handleMouseMove(e, canvasKey) {
                // Don't update anything if there's a selection - keep the selection locked
                if (this.visualizer.selectionState.hasSelection()) {
                    return;
                }

                // Throttle mouse move updates for performance
                if (this.mouseThrottle) return;
                this.mouseThrottle = true;
                requestAnimationFrame(() => {
                    this.mouseThrottle = false;
                });

                const canvas = this.canvases[canvasKey];
                const strategy = this.strategies[canvasKey];

                if (strategy) {
                    strategy.handleMove(e, canvas, canvasKey);
                    this.visualizer.update();
                }
            }


            handleMouseLeave() {
                this.visualizer.selectionState.clearHover();
                this.tooltipManager.hideIfNotSticky();
                // Use requestAnimationFrame for smoother updates
                if (this.visualizer.updatePending) return;
                this.visualizer.updatePending = true;
                requestAnimationFrame(() => {
                    this.visualizer.updatePending = false;
                    this.visualizer.update();
                });
            }

            handleMouseClick(e, canvasKey) {
                const canvas = this.canvases[canvasKey];
                const strategy = this.strategies[canvasKey];

                if (strategy) {
                    strategy.handleClick(e, canvas, canvasKey);
                    this.visualizer.update();
                }
            }

        }

        // Global coordinate service instance
        let coordinateService;

        class CanvasManager {
            constructor(visualizer) {
                this.visualizer = visualizer;
                this.canvases = {};
                this.contexts = {};
                this.renderers = {};
                this.lastCanvasSize = new Map();
            }

            initializeCanvases() {
                this.canvases = {
                    spatialUnchunked: document.getElementById('spatial-unchunked'),
                    spatialChunked: document.getElementById('spatial-chunked'),
                    linearUnchunked: document.getElementById('linear-unchunked'),
                    linearChunked: document.getElementById('linear-chunked')
                };

                this.tooltipManager = new TooltipManager(document.getElementById('tooltip'));
                this.interactionManager = new InteractionManager(this.visualizer, this.canvases, this.tooltipManager);

                this.contexts = {};
                this.renderers = {};

                for (const [key, canvas] of Object.entries(this.canvases)) {
                    this.contexts[key] = canvas.getContext('2d');

                    // Create specialized renderers
                    switch(key) {
                        case 'spatialUnchunked':
                            this.renderers[key] = new SpatialUnchunkedRenderer(canvas, this.contexts[key], this.visualizer, this.visualizer.coordinateService);
                            break;
                        case 'spatialChunked':
                            this.renderers[key] = new SpatialChunkedRenderer(canvas, this.contexts[key], this.visualizer, this.visualizer.coordinateService);
                            break;
                        case 'linearUnchunked':
                            this.renderers[key] = new LinearUnchunkedRenderer(canvas, this.contexts[key], this.visualizer, this.visualizer.coordinateService);
                            break;
                        case 'linearChunked':
                            this.renderers[key] = new LinearChunkedRenderer(canvas, this.contexts[key], this.visualizer, this.visualizer.coordinateService);
                            break;
                    }

                    // Add mouse interaction for spatial and linear views
                    if (key.startsWith('spatial') || key.startsWith('linear')) {
                        canvas.addEventListener('mousemove', (e) => this.interactionManager.handleMouseMove(e, key));
                        canvas.addEventListener('mouseleave', () => this.interactionManager.handleMouseLeave());
                        canvas.addEventListener('click', (e) => this.interactionManager.handleMouseClick(e, key));
                    }
                }

                this.setupResizeHandling();
                this.setupGlobalClickHandler();

                // Force initial resize after DOM is ready
                setTimeout(() => {
                    this.resizeCanvases();
                    this.visualizer.update();
                }, 0);

                this.resizeCanvases();
            }

            setupResizeHandling() {
                let resizeRAF = null;

                const handleResize = () => {
                    if (resizeRAF) return; // Prevent multiple concurrent updates

                    resizeRAF = requestAnimationFrame(() => {
                        const needsUpdate = this.resizeCanvases();
                        if (needsUpdate) {
                            this.visualizer.update();
                        }
                        resizeRAF = null;
                    });
                };

                // Only use window resize - simpler and more reliable
                window.addEventListener('resize', handleResize);
            }

            setupGlobalClickHandler() {
                // Clear selection when clicking outside visualizations
                document.addEventListener('click', (e) => {
                    // Check if click was inside any canvas
                    let clickedCanvas = false;
                    for (const canvas of Object.values(this.canvases)) {
                        const rect = canvas.getBoundingClientRect();
                        if (e.clientX >= rect.left && e.clientX <= rect.right &&
                            e.clientY >= rect.top && e.clientY <= rect.bottom) {
                            clickedCanvas = true;
                            break;
                        }
                    }

                    // If clicked outside all canvases, clear selection
                    if (!clickedCanvas && this.visualizer.selectionState.hasSelection()) {
                        this.visualizer.selectionState.clearSelection();
                        this.tooltipManager.hide();
                        this.visualizer.update();
                    }
                });
            }

            setCanvasSize(key, width, height) {
                const canvas = this.canvases[key];
                const ctx = this.contexts[key];
                const dpr = window.devicePixelRatio || 1;

                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';

                // Reset transform before scaling to prevent accumulation
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dpr, dpr);
            }

            resizeCanvases() {
                let needsUpdate = false;

                // Spatial canvases - square aspect
                ['spatialUnchunked', 'spatialChunked'].forEach(key => {
                    const canvas = this.canvases[key];
                    const canvasContainer = canvas.parentElement; // .canvas-container
                    const vizPanel = canvasContainer.parentElement; // .viz-panel
                    const containerRect = vizPanel.getBoundingClientRect();

                    // Account for viz-panel padding (15px) and canvas-container padding (10px)
                    const vizPanelPadding = 15;
                    const canvasContainerPadding = 20; // 10px on each side
                    const totalPadding = vizPanelPadding * 2 + canvasContainerPadding;

                    const availableWidth = containerRect.width - totalPadding;
                    const size = Math.min(availableWidth, CONFIG.MAX_CANVAS_SIZE);
                    const lastSize = this.lastCanvasSize.get(key);

                    if (size > 0 && (!lastSize || lastSize.width !== size || lastSize.height !== size)) {
                        this.setCanvasSize(key, size, size);
                        this.lastCanvasSize.set(key, { width: size, height: size });
                        needsUpdate = true;
                    }
                });

                // Linear canvases - full width
                ['linearUnchunked', 'linearChunked'].forEach(key => {
                    const canvas = this.canvases[key];
                    const canvasContainer = canvas.parentElement; // .canvas-container
                    const linearViz = canvasContainer.parentElement; // .linear-viz
                    const containerRect = linearViz.getBoundingClientRect();

                    // Account for linear-viz padding (15px) and canvas-container padding (10px)
                    const linearVizPadding = 15;
                    const canvasContainerPadding = 20; // 10px on each side
                    const totalPadding = linearVizPadding * 2 + canvasContainerPadding;

                    const width = containerRect.width - totalPadding;
                    const height = 120;
                    const lastSize = this.lastCanvasSize.get(key);

                    if (width > 0 && (!lastSize || lastSize.width !== width || lastSize.height !== height)) {
                        this.setCanvasSize(key, width, height);
                        this.lastCanvasSize.set(key, { width, height });
                        needsUpdate = true;
                    }
                });

                return needsUpdate;
            }

            renderAll(params, data) {
                // Draw all views using specialized renderers
                this.renderers.spatialUnchunked.render(params, data);
                this.renderers.spatialChunked.render(params, data);
                this.renderers.linearUnchunked.render(params, data);
                this.renderers.linearChunked.render(params, data);
            }
        }

        class SettingsManager {
            constructor() {
                this.loadSettings();
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('vischunk-app-state');
                    if (saved) {
                        this.appState = JSON.parse(saved);
                    } else {
                        this.appState = DEFAULT_APP_STATE;
                    }
                } catch (error) {
                    console.warn('Failed to load settings from localStorage:', error);
                    this.appState = DEFAULT_APP_STATE;
                }

                // Initialize current visualization state from the selected preset
                const currentPreset = this.appState.currentPreset;
                const presetSettings = this.appState.presets[currentPreset] ||
                                     this.getCanonicalPreset(currentPreset);

                this.state = {
                    ...presetSettings,
                    currentPreset: currentPreset
                };
            }

            saveSettings() {
                // Save current preset settings (excluding currentPreset from the preset data)
                const currentSettings = { ...this.state };
                delete currentSettings.currentPreset;

                // Only save preset if it differs from canonical version
                const canonicalSettings = this.getCanonicalPreset(this.state.currentPreset);
                const hasChanges = canonicalSettings && Object.keys(canonicalSettings).some(key =>
                    currentSettings[key] !== canonicalSettings[key]
                );

                if (hasChanges) {
                    // Preset is modified - save it
                    this.appState.presets[this.state.currentPreset] = currentSettings;
                } else {
                    // Preset matches canonical - remove any saved version
                    delete this.appState.presets[this.state.currentPreset];
                }

                // Always save the current preset selection
                this.appState.currentPreset = this.state.currentPreset;

                // Save entire app state
                localStorage.setItem('vischunk-app-state', JSON.stringify(this.appState));
            }

            setState(newState) {
                const oldState = { ...this.state };
                this.state = { ...this.state, ...newState };
                return { oldState, hasStructuralChanges: this.checkStructuralChanges(oldState, newState) };
            }

            checkStructuralChanges(oldState, newState) {
                const structuralChanges = ['cellAlgorithm', 'chunkAlgorithm', 'sizeX', 'sizeY', 'sizeZ', 'chunkX', 'chunkY', 'chunkZ'];
                return structuralChanges.some(key =>
                    key in newState && oldState[key] !== newState[key]
                );
            }

            validateAndClampState() {
                let updates = {};
                let { sizeX, sizeY, sizeZ, chunkX, chunkY, chunkZ, queryX1, queryX2, queryY1, queryY2, queryZ1, queryZ2 } = this.state;

                // Cap dimensions to prevent browser lockup
                if (sizeX > 64) { updates.sizeX = 64; sizeX = 64; }
                if (sizeY > 64) { updates.sizeY = 64; sizeY = 64; }
                if (sizeZ > 16) { updates.sizeZ = 16; sizeZ = 16; }

                // Also prevent total cells from being too large
                const totalCells = sizeX * sizeY * Math.max(1, sizeZ);
                if (totalCells > 4096) {
                    updates.sizeX = 32; sizeX = 32;
                    updates.sizeY = 32; sizeY = 32;
                    updates.sizeZ = 1; sizeZ = 1;
                }

                // Clamp chunk sizes to valid ranges
                if (chunkX > sizeX) { updates.chunkX = sizeX; chunkX = sizeX; }
                if (chunkY > sizeY) { updates.chunkY = sizeY; chunkY = sizeY; }
                if (chunkZ > sizeZ) { updates.chunkZ = Math.max(1, sizeZ); chunkZ = Math.max(1, sizeZ); }

                // Clamp query values to valid ranges
                const maxX = sizeX - 1;
                const maxY = sizeY - 1;
                const maxZ = sizeZ - 1;

                if (queryX1 > maxX) { updates.queryX1 = Math.max(0, maxX); }
                if (queryX2 > maxX) { updates.queryX2 = Math.max(0, maxX); }
                if (queryY1 > maxY) { updates.queryY1 = Math.max(0, maxY); }
                if (queryY2 > maxY) { updates.queryY2 = Math.max(0, maxY); }
                if (queryZ1 > maxZ) { updates.queryZ1 = Math.max(0, maxZ); }
                if (queryZ2 > maxZ) { updates.queryZ2 = Math.max(0, maxZ); }

                // Handle edge cases: if array dimension is 1, set sensible defaults
                if (sizeX === 1) {
                    updates.chunkX = 1;
                    updates.queryX1 = 0;
                    updates.queryX2 = 0;
                }
                if (sizeY === 1) {
                    updates.chunkY = 1;
                    updates.queryY1 = 0;
                    updates.queryY2 = 0;
                }
                if (sizeZ === 1) {
                    updates.chunkZ = 1;
                    updates.queryZ1 = 0;
                    updates.queryZ2 = 0;
                }

                return updates;
            }

            updateDOMConstraints() {
                const { sizeX, sizeY, sizeZ } = this.state;

                document.getElementById('chunkX').max = sizeX;
                document.getElementById('chunkY').max = sizeY;
                document.getElementById('chunkZ').max = Math.max(1, sizeZ);

                document.getElementById('queryX1').max = Math.max(0, sizeX - 1);
                document.getElementById('queryX2').max = Math.max(0, sizeX - 1);
                document.getElementById('queryY1').max = Math.max(0, sizeY - 1);
                document.getElementById('queryY2').max = Math.max(0, sizeY - 1);
                document.getElementById('queryZ1').max = Math.max(0, sizeZ - 1);
                document.getElementById('queryZ2').max = Math.max(0, sizeZ - 1);
            }

            renderUI() {
                Object.keys(this.state).forEach(key => {
                    if (key === 'currentPreset') {
                        const presetsEl = document.getElementById('presets');
                        if (presetsEl) presetsEl.value = this.state[key];
                    } else {
                        const element = document.getElementById(key);
                        if (element) element.value = this.state[key];
                    }
                });
            }

            getCanonicalPreset(presetName) {
                if (presetName === 'user') {
                    return DEFAULT_USER_SETTINGS;
                } else if (PRESET_CONFIGS[presetName]) {
                    const { name, ...settings } = PRESET_CONFIGS[presetName];
                    return settings;
                }
                return null;
            }

            getCurrentPresetSettings(presetName) {
                return this.appState.presets[presetName] || this.getCanonicalPreset(presetName);
            }

            getPresetDisplayName(presetName, includeModificationIndicator = false) {
                let baseName = presetName === 'user' ? 'User Settings' :
                              PRESET_CONFIGS[presetName]?.name || presetName;

                if (includeModificationIndicator && this.isPresetModified(presetName)) {
                    baseName += ' *';
                }

                return baseName;
            }

            isPresetModified(presetName) {
                if (presetName === 'user') {
                    return false;
                } else if (PRESET_CONFIGS[presetName]) {
                    return !!(this.appState && this.appState.presets && this.appState.presets[presetName]);
                }
                return false;
            }

            loadPreset(presetName) {
                this.appState.currentPreset = presetName;
                const presetSettings = this.getCurrentPresetSettings(presetName);
                if (presetSettings) {
                    this.setState({ ...presetSettings, currentPreset: presetName });
                    return true;
                }
                return false;
            }

            resetCurrentPreset() {
                const presetName = this.state.currentPreset;

                // Remove user modifications for this preset
                if (this.appState.presets[presetName]) {
                    delete this.appState.presets[presetName];
                }

                // Load canonical preset
                const canonicalSettings = this.getCanonicalPreset(presetName);
                if (canonicalSettings) {
                    this.setState({ ...canonicalSettings, currentPreset: presetName });
                    return true;
                }
                return false;
            }

            shouldShowResetButton() {
                const canonical = this.getCanonicalPreset(this.state.currentPreset);
                return canonical && Object.keys(canonical).some(key =>
                    this.state[key] !== canonical[key]
                );
            }
        }

        class SimulationModel {
            constructor() {
                // Initialize caches with LRU policy
                this.linearizationCache = new LRUCache(CONFIG.LRU_DETAIL_CACHE_SIZE);
                this.positionCache = new LRUCache(CONFIG.LRU_DETAIL_CACHE_SIZE);
                this.chunkPositionCache = new LRUCache(CONFIG.LRU_CONFIG_CACHE_SIZE);
                this.cellPositionCache = new LRUCache(CONFIG.LRU_CONFIG_CACHE_SIZE);
                this.cellCoordinateCache = new Map();
            }

            // Create or get cached CellCoordinate system for given params
            getCellCoordinateSystem(params) {
                const [sizeX, sizeY, sizeZ = 1] = params.size;
                const [chunkX, chunkY, chunkZ = 1] = params.chunk;
                const { cellAlgorithm = 'row-major', chunkAlgorithm = 'row-major' } = params;

                const cacheKey = JSON.stringify([sizeX, sizeY, sizeZ, chunkX, chunkY, chunkZ, cellAlgorithm, chunkAlgorithm]);
                if (this.cellCoordinateCache.has(cacheKey)) {
                    return this.cellCoordinateCache.get(cacheKey);
                }

                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const chunksZ = Math.ceil(sizeZ / chunkZ);

                const chunkGrid = new GridCoordinate(chunksX, chunksY, chunksZ, chunkAlgorithm, this.chunkPositionCache);
                const cellCoordinate = new CellCoordinate(
                    sizeX, sizeY, sizeZ,
                    cellAlgorithm,
                    chunkGrid,
                    chunkX, chunkY, chunkZ,
                    this.linearizationCache
                );

                this.cellCoordinateCache.set(cacheKey, cellCoordinate);
                return cellCoordinate;
            }

            linearizeCoordinate(x, y, z, sizeX, sizeY, sizeZ, algorithm) {
                const tempGrid = new GridCoordinate(sizeX, sizeY, sizeZ, algorithm, this.linearizationCache);
                return tempGrid.linearize(x, y, z);
            }

            getIntraChunkPosition(x, y, z, params) {
                const [sizeX, sizeY, sizeZ = 1] = params.size;
                const [chunkX, chunkY, chunkZ = 1] = params.chunk;
                const chunkCX = Math.floor(x / chunkX);
                const chunkCY = Math.floor(y / chunkY);
                const chunkCZ = Math.floor(z / chunkZ);
                const chunkStartX = chunkCX * chunkX;
                const chunkStartY = chunkCY * chunkY;
                const chunkStartZ = chunkCZ * chunkZ;
                const actualChunkX = Math.min(chunkStartX + chunkX, sizeX) - chunkStartX;
                const actualChunkY = Math.min(chunkStartY + chunkY, sizeY) - chunkStartY;
                const actualChunkZ = Math.min(chunkStartZ + chunkZ, sizeZ) - chunkStartZ;
                const localX = x - chunkStartX;
                const localY = y - chunkStartY;
                const localZ = z - chunkStartZ;
                return this.linearizeCoordinate(localX, localY, localZ, actualChunkX, actualChunkY, actualChunkZ, params.cellAlgorithm);
            }

            getInterChunkPosition(x, y, z, params) {
                const cellCoord = this.getCellCoordinateSystem(params);
                const chunk = cellCoord.getParentChunk(x, y, z);
                return cellCoord.chunkGrid.linearize(chunk.x, chunk.y, chunk.z);
            }

            getNormalizedChunkPosition(x, y, z, params) {
                return this.getInterChunkPosition(x, y, z, params);
            }

            getGlobalPosition(x, y, z, params) {
                const cellCoord = this.getCellCoordinateSystem(params);
                return cellCoord.getGlobalIndex(x, y, z);
            }

            getChunkBounds(chunkCX, chunkCY, chunkX, chunkY, sizeX, sizeY) {
                const startX = chunkCX * chunkX;
                const startY = chunkCY * chunkY;
                const endX = Math.min(startX + chunkX, sizeX);
                const endY = Math.min(startY + chunkY, sizeY);
                return { startX, startY, endX, endY };
            }

            getChunkGlobalRange(chunkCX, chunkCY, params) {
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY] = params.chunk;
                const positions = [];
                for (let dy = 0; dy < chunkY; dy++) {
                    for (let dx = 0; dx < chunkX; dx++) {
                        const x = chunkCX * chunkX + dx;
                        const y = chunkCY * chunkY + dy;
                        if (x < sizeX && y < sizeY) {
                            positions.push(this.getGlobalPosition(x, y, 0, params));
                        }
                    }
                }
                if (positions.length === 0) return null;
                return {
                    min: Math.min(...positions),
                    max: Math.max(...positions),
                    positions: positions
                };
            }

            getChunkIndex(x, y, z, params) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const cx = Math.floor(x / chunkX);
                const cy = Math.floor(y / chunkY);
                const cz = Math.floor(z / chunkZ);
                const [sizeX, sizeY] = params.size;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                return cx + cy * chunksX + cz * chunksX * chunksY;
            }

            calculateData(params) {
                const [sizeX, sizeY, sizeZ] = params.size;
                const totalCells = sizeX * sizeY * Math.max(1, sizeZ);
                const { requestedCells, touchedChunks } = this.calculateRequestedCellsAndChunks(params, sizeX, sizeY, sizeZ);
                const actualCells = this.calculateActualCellsFromChunks(touchedChunks, params, sizeX, sizeY, sizeZ);
                const chunkedRanges = this.calculateByteRanges(this.cellSetToPositions(actualCells, params));
                const unchunkedRanges = this.calculateByteRanges(this.cellSetToPositions(requestedCells, params));
                return { requestedCells, actualCells, touchedChunks, chunkedRanges, unchunkedRanges, totalCells };
            }

            calculateRequestedCellsAndChunks(params, sizeX, sizeY, sizeZ) {
                const requestedCells = new Set();
                const touchedChunks = new Set();
                for (let x = params.query.x[0]; x <= Math.min(params.query.x[1], sizeX - 1); x++) {
                    for (let y = params.query.y[0]; y <= Math.min(params.query.y[1], sizeY - 1); y++) {
                        if (sizeZ > 0) {
                            for (let z = params.query.z[0]; z <= Math.min(params.query.z[1], sizeZ - 1); z++) {
                                requestedCells.add(`${x},${y},${z}`);
                                touchedChunks.add(this.getChunkIndex(x, y, z, params));
                            }
                        } else {
                            requestedCells.add(`${x},${y},0`);
                            touchedChunks.add(this.getChunkIndex(x, y, 0, params));
                        }
                    }
                }
                return { requestedCells, touchedChunks };
            }

            calculateActualCellsFromChunks(touchedChunks, params, sizeX, sizeY, sizeZ) {
                const actualCells = new Set();
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                touchedChunks.forEach(chunkIdx => {
                    const chunkCoords = this.getChunkCoordsFromIndex(chunkIdx, chunksX, chunksY);
                    this.addChunkCells(actualCells, chunkCoords, params, sizeX, sizeY, sizeZ);
                });
                return actualCells;
            }

            getChunkCoordsFromIndex(chunkIdx, chunksX, chunksY) {
                const cz = Math.floor(chunkIdx / (chunksX * chunksY));
                const cy = Math.floor((chunkIdx % (chunksX * chunksY)) / chunksX);
                const cx = chunkIdx % chunksX;
                return { cx, cy, cz };
            }

            addChunkCells(actualCells, chunkCoords, params, sizeX, sizeY, sizeZ) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const { cx, cy, cz } = chunkCoords;
                for (let dx = 0; dx < chunkX; dx++) {
                    for (let dy = 0; dy < chunkY; dy++) {
                        for (let dz = 0; dz < (sizeZ > 0 ? chunkZ : 1); dz++) {
                            const x = cx * chunkX + dx;
                            const y = cy * chunkY + dy;
                            const z = cz * chunkZ + dz;
                            if (x < sizeX && y < sizeY && (sizeZ === 0 || z < sizeZ)) {
                                actualCells.add(`${x},${y},${z}`);
                            }
                        }
                    }
                }
            }

            cellSetToPositions(cellSet, params) {
                return [...cellSet].map(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    return this.getGlobalPosition(x, y, z, params);
                });
            }

            calculateByteRanges(positions) {
                if (positions.length === 0) return [];
                const sorted = [...positions].sort((a, b) => a - b);
                const ranges = [];
                let start = sorted[0];
                let end = sorted[0];
                for (let i = 1; i < sorted.length; i++) {
                    if (sorted[i] === end + 1) {
                        end = sorted[i];
                    } else {
                        ranges.push([start, end]);
                        start = end = sorted[i];
                    }
                }
                ranges.push([start, end]);
                return ranges;
            }

            getOrCreateChunkColorMap(params, sizeX, sizeY, sizeZ) {
                const [chunkX, chunkY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const chunksZ = Math.ceil(Math.max(1, sizeZ) / Math.max(1, params.chunk[2]));
                const cacheKey = JSON.stringify([chunksX, chunksY, chunksZ, params.chunkAlgorithm]);
                let chunkColorMap = this.positionCache.get(cacheKey);
                if (!chunkColorMap) {
                    chunkColorMap = this.createChunkColorMap(params, chunksX, chunksY, chunksZ);
                    this.positionCache.set(cacheKey, chunkColorMap);
                }
                return chunkColorMap;
            }

            createChunkColorMap(params, chunksX, chunksY, chunksZ) {
                const chunkPositions = [];
                for (let chunkCZ = 0; chunkCZ < chunksZ; chunkCZ++) {
                    for (let chunkCY = 0; chunkCY < chunksY; chunkCY++) {
                        for (let chunkCX = 0; chunkCX < chunksX; chunkCX++) {
                            const linearPos = this.linearizeCoordinate(chunkCX, chunkCY, chunkCZ, chunksX, chunksY, chunksZ, params.chunkAlgorithm);
                            chunkPositions.push({ chunkCX, chunkCY, chunkCZ, linearPos });
                        }
                    }
                }
                chunkPositions.sort((a, b) => a.linearPos - b.linearPos);
                const chunkColorMap = new Map();
                chunkPositions.forEach((chunk, index) => {
                    const key = `${chunk.chunkCX},${chunk.chunkCY},${chunk.chunkCZ}`;
                    chunkColorMap.set(key, index);
                });
                return chunkColorMap;
            }

            getOrCreatePositionToCellMap(params, sizeX, sizeY, sizeZ) {
                const [chunkSizeX, chunkSizeY] = params.chunk;
                const cacheKey = JSON.stringify([sizeX, sizeY, params.cellAlgorithm, params.chunkAlgorithm, chunkSizeX, chunkSizeY]);
                let positionToCell = this.positionCache.get(cacheKey);
                if (!positionToCell) {
                    positionToCell = new Map();
                    for (let z = 0; z < Math.max(1, sizeZ); z++) {
                        for (let y = 0; y < sizeY; y++) {
                            for (let x = 0; x < sizeX; x++) {
                                const globalPos = this.getGlobalPosition(x, y, z, params);
                                positionToCell.set(globalPos, {x, y, z});
                            }
                        }
                    }
                    this.positionCache.set(cacheKey, positionToCell);
                }
                return positionToCell;
            }

            getCellFromLinearIndex(cellIndex, params, sizeX, sizeY, chunkX, chunkY) {
                for (let cy = 0; cy < sizeY; cy++) {
                    for (let cx = 0; cx < sizeX; cx++) {
                        const globalPos = this.getGlobalPosition(cx, cy, 0, params);
                        if (globalPos === cellIndex) {
                            return {
                                x: cx,
                                y: cy,
                                chunkX: Math.floor(cx / chunkX),
                                chunkY: Math.floor(cy / chunkY)
                            };
                        }
                    }
                }
                return null;
            }
        }

        class DataVisualizer {
            constructor() {
                this.simulationModel = new SimulationModel();
                this.coordinateService = new CoordinateService();
                this.settingsManager = new SettingsManager();
                this.selectionState = new SelectionState();
                this.colorCache = new LRUCache(CONFIG.LRU_DETAIL_CACHE_SIZE);
                this.canvasManager = new CanvasManager(this);

                this.initializeControls();
                this.canvasManager.initializeCanvases();
                this.updateUI();
                this.update();
            }


            setState(newState) {
                const { oldState, hasStructuralChanges } = this.settingsManager.setState(newState);
            }

            updateUI() {
                this.settingsManager.renderUI();
                this.settingsManager.updateDOMConstraints();
                this.updateResetButton();
                this.updatePresetDisplay();
                this.update();
            }

            clearCaches() {
                this.colorCache.clear();
                if (this.coordinateService) this.coordinateService.clearCache();
                // simulationModel caches are not cleared here, they have their own lifecycle
            }

            populatePresetOptions() {
                const presetsSelect = document.getElementById('presets');
                Object.keys(PRESET_CONFIGS).forEach(presetKey => {
                    const option = document.createElement('option');
                    option.value = presetKey;
                    option.textContent = this.settingsManager.getPresetDisplayName(presetKey, true);
                    presetsSelect.appendChild(option);
                });
            }

            initializeControls() {
                this.populatePresetOptions();
                const controls = ['cellAlgorithm', 'chunkAlgorithm', 'sizeX', 'sizeY', 'sizeZ', 'chunkX', 'chunkY', 'chunkZ', 'queryX1', 'queryX2', 'queryY1', 'queryY2', 'queryZ1', 'queryZ2'];
                controls.forEach(id => {
                    const element = document.getElementById(id);
                    element.addEventListener('change', (e) => {
                        let value = e.target.type === 'number' ? parseInt(e.target.value) : e.target.value;
                        if (e.target.type === 'number') {
                            if (isNaN(value)) {
                                console.warn(`Invalid input value: ${e.target.value}, resetting to 1`);
                                value = 1;
                            } else {
                                if (id.startsWith('size') || id.startsWith('chunk')) {
                                    value = Math.max(1, value);
                                } else {
                                    value = Math.max(0, value);
                                }
                                if (id.startsWith('size')) value = Math.min(value, 64);
                                if (id === 'sizeZ') value = Math.min(value, 16);
                            }
                        }
                        this.setState({ [id]: value });
                        this.updateUI();
                        this.settingsManager.saveSettings();
                    });
                });

                document.getElementById('presets').addEventListener('change', (e) => {
                    this.settingsManager.loadPreset(e.target.value);
                    this.updateUI();
                    this.settingsManager.saveSettings();
                });

                document.getElementById('resetButton').addEventListener('click', () => {
                    this.settingsManager.resetCurrentPreset();
                    this.updateUI();
                    this.settingsManager.saveSettings();
                });

                this.updateConstraints();
                this.updateResetButton();
            }

            updateResetButton() {
                const resetButton = document.getElementById('resetButton');
                const shouldShow = this.settingsManager.shouldShowResetButton();
                resetButton.disabled = !shouldShow;
                resetButton.style.opacity = shouldShow ? '1' : '0.5';
            }

            updatePresetDisplay() {
                const presetsSelect = document.getElementById('presets');
                presetsSelect.querySelectorAll('option').forEach(option => {
                    option.textContent = this.settingsManager.getPresetDisplayName(option.value, true);
                });
            }

            updateConstraints() {
                const updates = this.settingsManager.validateAndClampState();
                this.settingsManager.updateDOMConstraints();
                if (Object.keys(updates).length > 0) {
                    this.setState(updates);
                    this.settingsManager.renderUI();
                }
            }

            getParameters() {
                const state = this.settingsManager.state;
                return {
                    cellAlgorithm: state.cellAlgorithm,
                    chunkAlgorithm: state.chunkAlgorithm,
                    size: [state.sizeX, state.sizeY, state.sizeZ],
                    chunk: [state.chunkX, state.chunkY, state.chunkZ],
                    query: {
                        x: [state.queryX1, state.queryX2],
                        y: [state.queryY1, state.queryY2],
                        z: [state.queryZ1, state.queryZ2]
                    }
                };
            }

            getColorForLinearPosition(position, maxPosition) {
                const key = `${position}-${maxPosition}`;
                const cachedColor = this.colorCache.get(key);
                if (cachedColor) return cachedColor;
                const hue = 120 - (position / maxPosition) * 120;
                const color = `hsl(${hue}, 70%, 50%)`;
                this.colorCache.set(key, color);
                return color;
            }

            getEffectiveCell() {
                return this.selectionState.getEffectiveCell();
            }

            getEffectiveChunk() {
                return this.selectionState.getEffectiveChunk();
            }

            update() {
                const params = this.getParameters();
                document.getElementById('zRange').style.display = params.size[2] > 0 ? 'flex' : 'none';
                const data = this.simulationModel.calculateData(params);
                this.currentData = data;
                this.canvasManager.renderAll(params, data);
                this.updateMetrics(data);
            }

            updateMetrics(data) {
                const params = this.getParameters();
                const amplification = data.actualCells.size / Math.max(1, data.requestedCells.size);
                const coalescingFactor = data.touchedChunks.size / Math.max(1, data.chunkedRanges.length);
                const amplificationScore = 1 / Math.max(1, amplification);
                const rangeScore = 1 / Math.max(1, data.chunkedRanges.length);
                const storageAlignment =
                    (.9 * amplificationScore) + (.1 * rangeScore);

                document.getElementById('requested-cells').textContent = data.requestedCells.size;
                document.getElementById('actual-cells').textContent = data.actualCells.size;
                document.getElementById('amplification').innerHTML = amplification.toFixed(2) + '<span class="metric-suffix">x</span>';
                document.getElementById('chunks-touched').textContent = data.touchedChunks.size;
                document.getElementById('byte-ranges').textContent = data.chunkedRanges.length;
                document.getElementById('efficiency').innerHTML = (100 / amplification).toFixed(1) + '<span class="metric-suffix">%</span>';
                document.getElementById('coalescing-factor').innerHTML = coalescingFactor.toFixed(1) + '<span class="metric-suffix">x</span>';
                document.getElementById('storage-alignment').textContent = storageAlignment.toFixed(2);
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            new DataVisualizer();
        });
    </script>
</body>
</html>
