<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multidimensional Data Linearization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            padding: 20px;
            color: #eee;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 2em;
            text-align: center;
        }

        .subtitle {
            color: #aaa;
            margin-bottom: 30px;
            text-align: center;
        }

        .controls-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-section {
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .section-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 5px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 500;
            color: #bbb;
            margin-bottom: 5px;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="number"], select {
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transition: all 0.3s;
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #4a9eff;
            background: rgba(255, 255, 255, 0.15);
        }

        select option {
            background: #2a2a3e;
            color: #fff;
        }

        .query-controls {
            background: rgba(255, 200, 0, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 200, 0, 0.3);
        }

        .query-title {
            font-weight: 600;
            color: #ffc107;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        .range-inputs {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .range-group {
            display: flex;
            gap: 10px;
            align-items: center;
            color: #ddd;
        }

        .range-group input {
            width: 60px;
        }

        .spatial-views {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .viz-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .viz-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
        }

        canvas {
            display: block;
            width: 100%;
            cursor: crosshair;
        }

        .linear-views {
            margin-bottom: 30px;
        }

        .linear-viz {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
        }

        .metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .metric-label {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #fff;
        }

        .metric-suffix {
            font-size: 0.5em;
            color: rgba(255, 255, 255, 0.7);
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .explanation {
            max-width: 1600px;
            margin: 40px auto 0 auto;
            padding: 30px 20px 40px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .explanation h2 {
            color: #fff;
            font-size: 1.8em;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .explanation-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 25px;
        }

        @media (min-width: 1200px) {
            .explanation-content {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .explanation-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .explanation-section h3 {
            color: #4a9eff;
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .explanation-section p {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .explanation-section ul {
            color: #ccc;
            margin-left: 20px;
            line-height: 1.6;
        }

        .explanation-section li {
            margin-bottom: 8px;
        }

        .color-example {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
            vertical-align: middle;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .highlight-blue {
            background: rgba(74, 158, 255, 0.7);
        }

        .highlight-white {
            background: rgba(255, 255, 255, 0.4);
        }

        .gradient-example {
            background: linear-gradient(90deg, #00ff00, #ff0000);
        }

        /* Hide Z dimension controls for now */
        .z-control {
            display: none !important;
            /*display: flex !important;*/
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #aaa;
            font-size: 0.9em;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .reset-button {
            display: block;
            margin: 20px auto;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            width: fit-content;
        }

        .reset-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #4a9eff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Multidimensional Data Linearization Visualizer</h1>
        <p class="subtitle">Explore how chunking and linearization strategies affect read patterns</p>
        
        <div style="text-align: center; margin: 10px 0;">
            <a href="https://github.com/jkeifer/vischunk" target="_blank" style="color: #4a9eff; text-decoration: none; font-size: 14px; display: inline-flex; align-items: center; gap: 5px;">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
                View on GitHub
            </a>
        </div>
        
        <button class="reset-button" id="resetButton">Reset to Defaults</button>

        <div class="controls">
            <div class="control-section">
                <div class="section-title">Array Settings</div>
                <div class="control-group">
                    <label>Array Size X</label>
                    <input type="number" id="sizeX" min="1" max="32" value="16">
                </div>

                <div class="control-group">
                    <label>Array Size Y</label>
                    <input type="number" id="sizeY" min="1" max="32" value="16">
                </div>

                <div class="control-group z-control" id="arraySizeZGroup">
                    <label>Array Size Z</label>
                    <input type="number" id="sizeZ" min="1" max="16" value="1">
                </div>

                <div class="control-group">
                    <label>Cell Linearization (within chunk)</label>
                    <select id="cellAlgorithm">
                        <option value="row-major">Row-Major</option>
                        <option value="col-major">Column-Major</option>
                        <option value="z-order">Z-Order (Morton)</option>
                        <option value="hilbert">Hilbert Curve</option>
                    </select>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Chunk Settings</div>
                <div class="control-group">
                    <label>Chunk Size X</label>
                    <input type="number" id="chunkX" min="1" max="32" value="4">
                </div>

                <div class="control-group">
                    <label>Chunk Size Y</label>
                    <input type="number" id="chunkY" min="1" max="32" value="4">
                </div>

                <div class="control-group z-control" id="chunkZGroup">
                    <label>Chunk Size Z</label>
                    <input type="number" id="chunkZ" min="1" max="32" value="1">
                </div>

                <div class="control-group">
                    <label>Chunk Linearization</label>
                    <select id="chunkAlgorithm">
                        <option value="row-major">Row-Major</option>
                        <option value="col-major">Column-Major</option>
                        <option value="z-order">Z-Order (Morton)</option>
                        <option value="hilbert">Hilbert Curve</option>
                    </select>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Query Region</div>
                <div class="range-group">
                    <label>X:</label>
                    <input type="number" id="queryX1" min="0" value="3">
                    <span>to</span>
                    <input type="number" id="queryX2" min="0" value="10">
                </div>
                <div class="range-group">
                    <label>Y:</label>
                    <input type="number" id="queryY1" min="0" value="3">
                    <span>to</span>
                    <input type="number" id="queryY2" min="0" value="10">
                </div>
                <div class="range-group z-control" id="zRange">
                    <label>Z:</label>
                    <input type="number" id="queryZ1" min="0" value="0">
                    <span>to</span>
                    <input type="number" id="queryZ2" min="0" value="0">
                </div>
            </div>
        </div>

        <div class="spatial-views">
            <div class="viz-panel">
                <div class="viz-title">Logical Array (Cell Linearization within Chunks)</div>
                <div class="canvas-container">
                    <canvas id="spatial-unchunked"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #00ff00, #ff0000);"></div>
                        <span>Linearization Order</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="border: 3px solid #4a9eff; background: transparent;"></div>
                        <span>Query Region</span>
                    </div>
                </div>
            </div>

            <div class="viz-panel">
                <div class="viz-title">Chunked Array (Chunk Linearization)</div>
                <div class="canvas-container">
                    <canvas id="spatial-chunked"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #00ff00, #ff0000);"></div>
                        <span>Linearization Order</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="border: 3px solid #4a9eff; background: transparent;"></div>
                        <span>Chunks to Read</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="linear-views">
            <div class="linear-viz">
                <div class="viz-title">Linear Storage (Combined Linearization)</div>
                <div class="canvas-container">
                    <canvas id="linear-unchunked"></canvas>
                </div>
            </div>

            <div class="linear-viz">
                <div class="viz-title">Linear Storage (Chunk-Colored View)</div>
                <div class="canvas-container">
                    <canvas id="linear-chunked"></canvas>
                </div>
            </div>
        </div>

        <div class="metrics">
            <div class="metric">
                <div class="metric-label">Requested Cells</div>
                <div class="metric-value" id="requested-cells">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Actual Cells Read</div>
                <div class="metric-value" id="actual-cells">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Read Amplification</div>
                <div class="metric-value" id="amplification">1.0<span class="metric-suffix">x</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Efficiency</div>
                <div class="metric-value" id="efficiency">100<span class="metric-suffix">%</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Chunks Touched</div>
                <div class="metric-value" id="chunks-touched">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Range Reads</div>
                <div class="metric-value" id="byte-ranges">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Coalescing Factor</div>
                <div class="metric-value" id="coalescing-factor">1.0<span class="metric-suffix">x</span></div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <div class="explanation">
        <h2>How to Interpret the Visualizations</h2>

        <div class="explanation-content">
            <div class="explanation-section">
                <h3>Color Coding</h3>
                <p><span class="color-example gradient-example"></span><strong>Green to Red Gradient:</strong> Shows the linearization order from first (green) to last (red) in memory. This helps you understand how different algorithms arrange data sequentially.</p>

                <p><span class="color-example highlight-blue"></span><strong>Blue Highlights:</strong> Indicate query regions and all cells that need to be read to satisfy the query. This includes both requested cells and extra cells read due to chunking.</p>

                <p><span class="color-example highlight-white"></span><strong>White Overlays:</strong> Show currently hovered elements. Direct hovers have both overlay and outline, while cross-highlighted elements show only the overlay.</p>
            </div>

            <div class="explanation-section">
                <h3>Array Views (Top Row)</h3>
                <p><strong>Left - Logical Array:</strong> Shows how individual cells are organized and linearized within chunks. Each cell's color represents its position in the combined linearization order.</p>

                <p><strong>Right - Chunked Array:</strong> Displays chunk-level organization where all cells in the same chunk share the same color. This shows how chunks are linearized relative to each other.</p>

                <p><strong>Interactive Cross-highlighting:</strong> Hovering in one view highlights corresponding elements in all other views, helping you trace relationships between logical and physical layouts.</p>
            </div>

            <div class="explanation-section">
                <h3>Linear Storage Views (Bottom Row)</h3>
                <p><strong>Top Linear View:</strong> Shows how data is actually stored in linear memory, with the same cell-level coloring as the logical array. Blue regions indicate cells that need to be read.</p>

                <p><strong>Bottom Linear View:</strong> Same linear layout but colored by chunks to show how chunking affects the distribution of read operations. Blue bars below show the byte ranges that need to be fetched.</p>

                <p><strong>Byte Range Indicators:</strong> Lines below each linear view show how many separate read operations are required - fewer ranges mean better I/O performance.</p>
            </div>

            <div class="explanation-section">
                <h3>Performance Metrics</h3>
                <p><strong>Requested Cells:</strong> The number of cells in your query region that you actually want to read.</p>

                <p><strong>Actual Cells Read:</strong> The total number of cells that must be read due to chunking, including both requested and extra cells.</p>

                <p><strong>Read Amplification:</strong> Shows how much extra data you read due to chunking. Values > 1.0 indicate wasted bandwidth. Lower is better.</p>

                <p><strong>Efficiency:</strong> Percentage of useful data in each read operation. Higher percentages indicate better performance with less wasted I/O.</p>

                <p><strong>Chunks Touched:</strong> How many chunks intersect with your query region. Fewer chunks generally mean more efficient access patterns.</p>

                <p><strong>Range Reads:</strong> Number of separate read operations needed. Fewer range reads reduce I/O overhead and improve performance.</p>

                <p><strong>Coalescing Factor:</strong> Shows how much read coalescing improves I/O efficiency compared to worst-case (chunks touched ÷ range reads). Values > 1.0 indicate that multiple chunks are being read in fewer operations due to spatial locality.</p>
            </div>

            <div class="explanation-section">
                <h3>Algorithm Comparison</h3>
                <p><strong>Row-Major:</strong> Best for queries that access consecutive rows. Common in C/C++ and most programming languages.</p>

                <p><strong>Column-Major:</strong> Optimal for column-wise access patterns. Used in Fortran, R, and some scientific computing applications.</p>

                <p><strong>Z-Order (Morton):</strong> Space-filling curve that preserves spatial locality well. Good for 2D range queries and spatial databases.</p>

                <p><strong>Hilbert Curve:</strong> Optimal space-filling curve with the best spatial locality preservation. Excellent for 2D spatial queries but more complex to compute.</p>
            </div>

            <div class="explanation-section">
                <h3>Optimization Tips</h3>
                <p><strong>Match Access Patterns:</strong> Choose linearization algorithms that align with how your application accesses data most frequently.</p>

                <p><strong>Chunk Size Balance:</strong> Larger chunks reduce metadata overhead but may increase read amplification. Smaller chunks provide finer granularity but more management overhead.</p>

                <p><strong>Query Shape Matters:</strong> Square queries often work best with space-filling curves, while rectangular queries may favor row/column-major ordering.</p>

                <p><strong>Monitor Metrics:</strong> Use the real-time metrics to compare different configurations and find the optimal balance for your specific use case.</p>
            </div>
        </div>
    </div>

    <script>
        class DataVisualizer {
            constructor() {
                this.hoveredCell = null;
                this.hoveredChunk = null;
                this.linearizationCache = new Map();
                this.positionCache = new Map();
                this.lastCanvasSize = new Map();
                this.loadSettings();
                this.initializeControls();
                this.initializeCanvases();
                this.update();
            }

            initializeControls() {
                const controls = ['cellAlgorithm', 'chunkAlgorithm', 'sizeX', 'sizeY', 'sizeZ',
                                 'chunkX', 'chunkY', 'chunkZ',
                                 'queryX1', 'queryX2', 'queryY1', 'queryY2',
                                 'queryZ1', 'queryZ2'];

                controls.forEach(id => {
                    const element = document.getElementById(id);
                    element.addEventListener('change', () => {
                        this.updateConstraints();
                        this.saveSettings();
                        this.update();
                    });
                });

                // Add reset button handler
                document.getElementById('resetButton').addEventListener('click', () => {
                    this.resetSettings();
                });

                this.updateConstraints();
            }

            saveSettings() {
                const settings = {
                    cellAlgorithm: document.getElementById('cellAlgorithm').value,
                    chunkAlgorithm: document.getElementById('chunkAlgorithm').value,
                    sizeX: document.getElementById('sizeX').value,
                    sizeY: document.getElementById('sizeY').value,
                    sizeZ: document.getElementById('sizeZ').value,
                    chunkX: document.getElementById('chunkX').value,
                    chunkY: document.getElementById('chunkY').value,
                    chunkZ: document.getElementById('chunkZ').value,
                    queryX1: document.getElementById('queryX1').value,
                    queryX2: document.getElementById('queryX2').value,
                    queryY1: document.getElementById('queryY1').value,
                    queryY2: document.getElementById('queryY2').value,
                    queryZ1: document.getElementById('queryZ1').value,
                    queryZ2: document.getElementById('queryZ2').value
                };
                localStorage.setItem('vischunk-settings', JSON.stringify(settings));
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('vischunk-settings');
                    if (saved) {
                        const settings = JSON.parse(saved);
                        
                        // Apply settings to controls
                        Object.keys(settings).forEach(key => {
                            const element = document.getElementById(key);
                            if (element) {
                                element.value = settings[key];
                            }
                        });
                    }
                } catch (error) {
                    console.warn('Failed to load settings from localStorage:', error);
                }
            }

            resetSettings() {
                // Reset all controls to their default values
                const defaults = {
                    cellAlgorithm: 'row-major',
                    chunkAlgorithm: 'row-major',
                    sizeX: '16',
                    sizeY: '16',
                    sizeZ: '1',
                    chunkX: '4',
                    chunkY: '4',
                    chunkZ: '1',
                    queryX1: '3',
                    queryX2: '10',
                    queryY1: '3',
                    queryY2: '10',
                    queryZ1: '0',
                    queryZ2: '0'
                };

                Object.keys(defaults).forEach(key => {
                    const element = document.getElementById(key);
                    if (element) {
                        element.value = defaults[key];
                    }
                });

                // Update constraints, save settings, and refresh visualization
                this.updateConstraints();
                this.saveSettings();
                this.update();
            }

            updateConstraints() {
                // Clamp input values to reasonable limits to prevent browser lockup
                const sizeXEl = document.getElementById('sizeX');
                const sizeYEl = document.getElementById('sizeY');
                const sizeZEl = document.getElementById('sizeZ');
                
                let sizeX = parseInt(sizeXEl.value) || 1;
                let sizeY = parseInt(sizeYEl.value) || 1;
                let sizeZ = parseInt(sizeZEl.value) || 1;
                
                // Cap dimensions to prevent browser lockup
                if (sizeX > 64) { sizeX = 64; sizeXEl.value = 64; }
                if (sizeY > 64) { sizeY = 64; sizeYEl.value = 64; }
                if (sizeZ > 16) { sizeZ = 16; sizeZEl.value = 16; }
                
                // Also prevent total cells from being too large
                const totalCells = sizeX * sizeY * Math.max(1, sizeZ);
                if (totalCells > 4096) {
                    // Reset to safer defaults if total is too large
                    sizeX = 32; sizeXEl.value = 32;
                    sizeY = 32; sizeYEl.value = 32;
                    sizeZ = 1; sizeZEl.value = 1;
                }

                // Z controls are statically hidden for now

                // Update all constraints
                document.getElementById('chunkX').max = sizeX;
                document.getElementById('chunkY').max = sizeY;
                document.getElementById('chunkZ').max = Math.max(1, sizeZ);

                document.getElementById('queryX1').max = Math.max(0, sizeX - 1);
                document.getElementById('queryX2').max = Math.max(0, sizeX - 1);
                document.getElementById('queryY1').max = Math.max(0, sizeY - 1);
                document.getElementById('queryY2').max = Math.max(0, sizeY - 1);
                document.getElementById('queryZ1').max = Math.max(0, sizeZ - 1);
                document.getElementById('queryZ2').max = Math.max(0, sizeZ - 1);

                // Clamp chunk sizes to valid ranges
                const chunkX = document.getElementById('chunkX');
                const chunkY = document.getElementById('chunkY');
                const chunkZ = document.getElementById('chunkZ');

                if (parseInt(chunkX.value) > sizeX) chunkX.value = sizeX;
                if (parseInt(chunkY.value) > sizeY) chunkY.value = sizeY;
                if (parseInt(chunkZ.value) > sizeZ) chunkZ.value = Math.max(1, sizeZ);

                // Clamp query values to valid ranges
                const queryX1 = document.getElementById('queryX1');
                const queryX2 = document.getElementById('queryX2');
                const queryY1 = document.getElementById('queryY1');
                const queryY2 = document.getElementById('queryY2');
                const queryZ1 = document.getElementById('queryZ1');
                const queryZ2 = document.getElementById('queryZ2');

                const maxX = sizeX - 1;
                const maxY = sizeY - 1;
                const maxZ = sizeZ - 1;

                if (parseInt(queryX1.value) > maxX) queryX1.value = Math.max(0, maxX);
                if (parseInt(queryX2.value) > maxX) queryX2.value = Math.max(0, maxX);
                if (parseInt(queryY1.value) > maxY) queryY1.value = Math.max(0, maxY);
                if (parseInt(queryY2.value) > maxY) queryY2.value = Math.max(0, maxY);
                if (parseInt(queryZ1.value) > maxZ) queryZ1.value = Math.max(0, maxZ);
                if (parseInt(queryZ2.value) > maxZ) queryZ2.value = Math.max(0, maxZ);

                // Handle edge case: if array dimension is 1, set sensible defaults
                if (sizeX === 1) {
                    chunkX.value = 1;
                    queryX1.value = 0;
                    queryX2.value = 0;
                }
                if (sizeY === 1) {
                    chunkY.value = 1;
                    queryY1.value = 0;
                    queryY2.value = 0;
                }
                if (sizeZ === 1) {
                    chunkZ.value = 1;
                    queryZ1.value = 0;
                    queryZ2.value = 0;
                }
            }

            initializeCanvases() {
                this.canvases = {
                    spatialUnchunked: document.getElementById('spatial-unchunked'),
                    spatialChunked: document.getElementById('spatial-chunked'),
                    linearUnchunked: document.getElementById('linear-unchunked'),
                    linearChunked: document.getElementById('linear-chunked')
                };

                this.contexts = {};
                for (const [key, canvas] of Object.entries(this.canvases)) {
                    this.contexts[key] = canvas.getContext('2d');

                    // Add mouse interaction for spatial and linear views
                    if (key.startsWith('spatial') || key.startsWith('linear')) {
                        canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e, key));
                        canvas.addEventListener('mouseleave', () => this.handleMouseLeave());
                    }
                }

                this.tooltip = document.getElementById('tooltip');

                this.resizeCanvases();
                // Debounce resize events for better performance
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        const needsUpdate = this.resizeCanvases();
                        if (needsUpdate) {
                            this.update();
                        }
                    }, 150);
                });
            }

            resizeCanvases() {
                let needsUpdate = false;

                // Spatial canvases - square aspect
                ['spatialUnchunked', 'spatialChunked'].forEach(key => {
                    const canvas = this.canvases[key];
                    const rect = canvas.getBoundingClientRect();
                    const size = Math.min(rect.width, 400);
                    const lastSize = this.lastCanvasSize.get(key);

                    if (!lastSize || lastSize.width !== size || lastSize.height !== size) {
                        canvas.width = size;
                        canvas.height = size;
                        this.lastCanvasSize.set(key, { width: size, height: size });
                        needsUpdate = true;
                    }
                });

                // Linear canvases - full width
                ['linearUnchunked', 'linearChunked'].forEach(key => {
                    const canvas = this.canvases[key];
                    const rect = canvas.getBoundingClientRect();
                    const width = rect.width;
                    const height = 120;
                    const lastSize = this.lastCanvasSize.get(key);

                    if (!lastSize || lastSize.width !== width || lastSize.height !== height) {
                        canvas.width = width;
                        canvas.height = height;
                        this.lastCanvasSize.set(key, { width, height });
                        needsUpdate = true;
                    }
                });

                return needsUpdate;
            }

            getParameters() {
                return {
                    cellAlgorithm: document.getElementById('cellAlgorithm').value,
                    chunkAlgorithm: document.getElementById('chunkAlgorithm').value,
                    size: [
                        parseInt(document.getElementById('sizeX').value) || 1,
                        parseInt(document.getElementById('sizeY').value) || 1,
                        parseInt(document.getElementById('sizeZ').value) || 0
                    ],
                    chunk: [
                        parseInt(document.getElementById('chunkX').value) || 1,
                        parseInt(document.getElementById('chunkY').value) || 1,
                        parseInt(document.getElementById('chunkZ').value) || 1
                    ],
                    query: {
                        x: [parseInt(document.getElementById('queryX1').value) || 0,
                            parseInt(document.getElementById('queryX2').value) || 0],
                        y: [parseInt(document.getElementById('queryY1').value) || 0,
                            parseInt(document.getElementById('queryY2').value) || 0],
                        z: [parseInt(document.getElementById('queryZ1').value) || 0,
                            parseInt(document.getElementById('queryZ2').value) || 0]
                    }
                };
            }

            linearizeCoordinate(x, y, z, sizeX, sizeY, sizeZ, algorithm) {
                const key = `${x},${y},${z},${sizeX},${sizeY},${sizeZ},${algorithm}`;
                if (this.linearizationCache.has(key)) {
                    return this.linearizationCache.get(key);
                }

                let result;

                switch(algorithm) {
                    case 'row-major':
                        result = x + y * sizeX + z * sizeX * sizeY;
                        break;

                    case 'col-major':
                        result = y + x * sizeY + z * sizeX * sizeY;
                        break;

                    case 'z-order':
                        if (sizeZ > 0) {
                            result = this.mortonEncode3D(x, y, z);
                        } else {
                            result = this.mortonEncode2D(x, y);
                        }
                        break;

                    case 'hilbert':
                        if (sizeZ > 0) {
                            // For 3D, use simple layer-based approach
                            result = z * sizeX * sizeY + this.hilbertEncode2D(x, y, Math.max(sizeX, sizeY));
                        } else {
                            result = this.hilbertEncode2D(x, y, Math.max(sizeX, sizeY));
                        }
                        break;

                    default:
                        result = x + y * sizeX + z * sizeX * sizeY;
                }

                this.linearizationCache.set(key, result);
                return result;
            }

            // Get the linearization position of a cell within its chunk
            getIntraChunkPosition(x, y, z, params) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const localX = x % chunkX;
                const localY = y % chunkY;
                const localZ = z % chunkZ;
                const rawPos = this.linearizeCoordinate(localX, localY, localZ, chunkX, chunkY, chunkZ, params.cellAlgorithm);

                // For non-sequential cell algorithms, normalize to ensure contiguous chunk ranges
                if (params.cellAlgorithm === 'z-order' || params.cellAlgorithm === 'hilbert') {
                    const cacheKey = `cell-${params.cellAlgorithm}-${chunkX}-${chunkY}-${chunkZ}`;
                    if (!this.cellPositionCache) this.cellPositionCache = new Map();

                    if (!this.cellPositionCache.has(cacheKey)) {
                        const allCellPositions = [];
                        for (let cz = 0; cz < Math.max(1, chunkZ); cz++) {
                            for (let cy = 0; cy < chunkY; cy++) {
                                for (let cx = 0; cx < chunkX; cx++) {
                                    const pos = this.linearizeCoordinate(cx, cy, cz, chunkX, chunkY, chunkZ, params.cellAlgorithm);
                                    allCellPositions.push(pos);
                                }
                            }
                        }
                        allCellPositions.sort((a, b) => a - b);

                        const positionMap = new Map();
                        allCellPositions.forEach((pos, seqIndex) => {
                            positionMap.set(pos, seqIndex);
                        });
                        this.cellPositionCache.set(cacheKey, positionMap);
                    }

                    return this.cellPositionCache.get(cacheKey).get(rawPos) || 0;
                }

                return rawPos;
            }

            // Get the linearization position of a chunk
            getInterChunkPosition(x, y, z, params) {
                const [sizeX, sizeY, sizeZ] = params.size;
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const chunksZ = Math.ceil(sizeZ / chunkZ);
                const chunkCX = Math.floor(x / chunkX);
                const chunkCY = Math.floor(y / chunkY);
                const chunkCZ = Math.floor(z / chunkZ);
                return this.linearizeCoordinate(chunkCX, chunkCY, chunkCZ, chunksX, chunksY, chunksZ, params.chunkAlgorithm);
            }

            // Get the normalized chunk position (sequential order 0,1,2,3... regardless of algorithm)
            getNormalizedChunkPosition(x, y, z, params) {
                const rawChunkPos = this.getInterChunkPosition(x, y, z, params);

                if (params.chunkAlgorithm === 'z-order' || params.chunkAlgorithm === 'hilbert') {
                    // For non-sequential algorithms, normalize to get proper sequential positions
                    const [sizeX, sizeY] = params.size;
                    const [chunkX, chunkY] = params.chunk;
                    const chunksX = Math.ceil(sizeX / chunkX);
                    const chunksY = Math.ceil(sizeY / chunkY);

                    // Create mapping once and cache it
                    const cacheKey = `${params.chunkAlgorithm}-${chunksX}-${chunksY}`;
                    if (!this.chunkPositionCache) this.chunkPositionCache = new Map();

                    if (!this.chunkPositionCache.has(cacheKey)) {
                        const allChunkPositions = [];
                        for (let cy = 0; cy < chunksY; cy++) {
                            for (let cx = 0; cx < chunksX; cx++) {
                                const tempX = cx * chunkX;
                                const tempY = cy * chunkY;
                                const pos = this.getInterChunkPosition(tempX, tempY, 0, params);
                                allChunkPositions.push({pos, index: cy * chunksX + cx});
                            }
                        }
                        allChunkPositions.sort((a, b) => a.pos - b.pos);

                        const positionMap = new Map();
                        allChunkPositions.forEach((item, seqIndex) => {
                            positionMap.set(item.pos, seqIndex);
                        });
                        this.chunkPositionCache.set(cacheKey, positionMap);
                    }

                    return this.chunkPositionCache.get(cacheKey).get(rawChunkPos) || 0;
                }

                return rawChunkPos;
            }

            // Get the global linearization position combining both levels
            getGlobalPosition(x, y, z, params) {
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY, chunkZ] = params.chunk;

                // Calculate which chunk this cell belongs to
                const chunkCX = Math.floor(x / chunkX);
                const chunkCY = Math.floor(y / chunkY);
                const chunkCZ = Math.floor(z / Math.max(1, chunkZ));

                // Get linearization position of chunks
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const normalizedChunkPos = this.getNormalizedChunkPosition(x, y, z, params);

                // Calculate how many actual cells are in chunks before this one
                let cellsBeforeThisChunk = 0;
                for (let i = 0; i < normalizedChunkPos; i++) {
                    // Convert sequential chunk index back to chunk coordinates
                    const tempChunksX = Math.ceil(sizeX / chunkX);
                    const tempChunksY = Math.ceil(sizeY / chunkY);

                    let tempCX, tempCY;
                    // This depends on the chunk algorithm - for now assume row-major for chunk ordering
                    tempCY = Math.floor(i / tempChunksX);
                    tempCX = i % tempChunksX;

                    // Calculate actual cells in this chunk
                    const startX = tempCX * chunkX;
                    const startY = tempCY * chunkY;
                    const endX = Math.min(startX + chunkX, sizeX);
                    const endY = Math.min(startY + chunkY, sizeY);
                    const actualCellsInChunk = (endX - startX) * (endY - startY);
                    cellsBeforeThisChunk += actualCellsInChunk;
                }

                // Add position within current chunk
                const intraChunkPos = this.getIntraChunkPosition(x, y, z, params);
                return cellsBeforeThisChunk + intraChunkPos;
            }

            // Get the range of global positions for a chunk
            getChunkGlobalRange(chunkCX, chunkCY, params) {
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY] = params.chunk;
                const cellsPerChunk = chunkX * chunkY;

                const positions = [];
                for (let dy = 0; dy < chunkY; dy++) {
                    for (let dx = 0; dx < chunkX; dx++) {
                        const x = chunkCX * chunkX + dx;
                        const y = chunkCY * chunkY + dy;
                        if (x < sizeX && y < sizeY) {
                            positions.push(this.getGlobalPosition(x, y, 0, params));
                        }
                    }
                }

                if (positions.length === 0) return null;
                return {
                    min: Math.min(...positions),
                    max: Math.max(...positions),
                    positions: positions
                };
            }

            mortonEncode2D(x, y) {
                let result = 0;
                for (let i = 0; i < 16; i++) {
                    result |= ((x & (1 << i)) << i) | ((y & (1 << i)) << (i + 1));
                }
                return result;
            }

            mortonEncode3D(x, y, z) {
                let result = 0;
                for (let i = 0; i < 10; i++) {
                    result |= ((x & (1 << i)) << (2 * i)) |
                              ((y & (1 << i)) << (2 * i + 1)) |
                              ((z & (1 << i)) << (2 * i + 2));
                }
                return result;
            }

            hilbertEncode2D(x, y, n) {
                let d = 0;
                for (let s = n / 2; s > 0; s /= 2) {
                    let rx = (x & s) > 0 ? 1 : 0;
                    let ry = (y & s) > 0 ? 1 : 0;
                    d += s * s * ((3 * rx) ^ ry);
                    [x, y] = this.hilbertRotate(s, x, y, rx, ry);
                }
                return d;
            }

            hilbertRotate(n, x, y, rx, ry) {
                if (ry === 0) {
                    if (rx === 1) {
                        x = n - 1 - x;
                        y = n - 1 - y;
                    }
                    [x, y] = [y, x];
                }
                return [x, y];
            }

            getChunkIndex(x, y, z, params) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const cx = Math.floor(x / chunkX);
                const cy = Math.floor(y / chunkY);
                const cz = Math.floor(z / chunkZ);
                const [sizeX, sizeY] = params.size;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                return cx + cy * chunksX + cz * chunksX * chunksY;
            }

            getColorForLinearPosition(position, maxPosition) {
                // Cache color calculations for performance
                const key = `${position}-${maxPosition}`;
                if (!this.colorCache) this.colorCache = new Map();
                
                if (this.colorCache.has(key)) {
                    return this.colorCache.get(key);
                }
                
                const hue = 120 - (position / maxPosition) * 120; // Green to red (120° to 0°)
                const color = `hsl(${hue}, 70%, 50%)`;
                
                // Limit cache size to prevent memory leaks
                if (this.colorCache.size > 10000) {
                    this.colorCache.clear();
                }
                this.colorCache.set(key, color);
                return color;
            }

            handleMouseMove(e, canvasKey) {
                // Throttle mouse move updates for performance
                if (this.mouseThrottle) return;
                this.mouseThrottle = true;
                requestAnimationFrame(() => {
                    this.mouseThrottle = false;
                });

                const canvas = this.canvases[canvasKey];
                const rect = canvas.getBoundingClientRect();
                // Scale mouse coordinates to match canvas internal dimensions
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                const params = this.getParameters();
                const [sizeX, sizeY, sizeZ] = params.size;
                const [chunkX, chunkY] = params.chunk;

                if (canvasKey === 'spatialUnchunked') {
                    // Original cell-level interaction for unchunked view
                    const cellSize = Math.min(canvas.width / sizeX, canvas.height / sizeY) * 0.9;
                    const offsetX = (canvas.width - sizeX * cellSize) / 2;
                    const offsetY = (canvas.height - sizeY * cellSize) / 2;

                    const cellX = Math.floor((x - offsetX) / cellSize);
                    const cellY = Math.floor((y - offsetY) / cellSize);

                    if (cellX >= 0 && cellX < sizeX && cellY >= 0 && cellY < sizeY) {
                        this.hoveredCell = { x: cellX, y: cellY };
                        // Also set the corresponding chunk for cross-highlighting
                        this.hoveredChunk = {
                            x: Math.floor(cellX / chunkX),
                            y: Math.floor(cellY / chunkY)
                        };

                        // Show tooltip
                        const intraChunkPos = this.getIntraChunkPosition(cellX, cellY, 0, params);
                        const globalPos = this.getGlobalPosition(cellX, cellY, 0, params);
                        this.tooltip.style.display = 'block';
                        this.tooltip.style.left = `${e.clientX + 10}px`;
                        this.tooltip.style.top = `${e.clientY - 30}px`;
                        this.tooltip.textContent = `Cell (${cellX}, ${cellY}) → Intra-chunk: ${intraChunkPos}, Global: ${globalPos}`;
                    } else {
                        this.hoveredCell = null;
                        this.hoveredChunk = null;
                        this.tooltip.style.display = 'none';
                    }
                } else if (canvasKey === 'spatialChunked') {
                    // Cell-level interaction for chunked view (but highlight whole chunks)
                    const cellSize = Math.min(canvas.width / sizeX, canvas.height / sizeY) * 0.9;
                    const offsetX = (canvas.width - sizeX * cellSize) / 2;
                    const offsetY = (canvas.height - sizeY * cellSize) / 2;

                    const cellX = Math.floor((x - offsetX) / cellSize);
                    const cellY = Math.floor((y - offsetY) / cellSize);

                    if (cellX >= 0 && cellX < sizeX && cellY >= 0 && cellY < sizeY) {
                        // Calculate which chunk this cell belongs to
                        const chunkCX = Math.floor(cellX / chunkX);
                        const chunkCY = Math.floor(cellY / chunkY);

                        this.hoveredChunk = { x: chunkCX, y: chunkCY };
                        this.hoveredCell = null; // Clear individual cell when hovering chunk view

                        // Show tooltip
                        const chunksX = Math.ceil(sizeX / chunkX);
                        const chunkIdx = chunkCX + chunkCY * chunksX;
                        const startX = chunkCX * chunkX;
                        const startY = chunkCY * chunkY;
                        const endX = Math.min(startX + chunkX - 1, sizeX - 1);
                        const endY = Math.min(startY + chunkY - 1, sizeY - 1);
                        const interChunkPos = this.getInterChunkPosition(startX, startY, 0, params);

                        this.tooltip.style.display = 'block';
                        this.tooltip.style.left = `${e.clientX + 10}px`;
                        this.tooltip.style.top = `${e.clientY - 30}px`;
                        this.tooltip.textContent = `Chunk ${chunkIdx}: cells (${startX},${startY}) to (${endX},${endY}), Linear pos: ${interChunkPos}`;
                    } else {
                        this.hoveredChunk = null;
                        this.tooltip.style.display = 'none';
                    }
                } else if (canvasKey.startsWith('linear')) {
                    // Linear view interaction
                    const data = this.currentData;
                    if (!data) return;

                    const cellWidth = (canvas.width - 40) / data.totalCells;
                    const offsetX = 20;
                    const barHeight = 60;
                    const offsetY = 20;

                    // Check if mouse is over the bar area
                    if (y >= offsetY && y <= offsetY + barHeight) {
                        const cellIndex = Math.floor((x - offsetX) / cellWidth);

                        if (cellIndex >= 0 && cellIndex < data.totalCells) {
                            // Find which cell this linear position corresponds to
                            let foundCell = null;
                            for (let cy = 0; cy < sizeY; cy++) {
                                for (let cx = 0; cx < sizeX; cx++) {
                                    const globalPos = this.getGlobalPosition(cx, cy, 0, params);
                                    if (globalPos === cellIndex) {
                                        foundCell = { x: cx, y: cy };
                                        break;
                                    }
                                }
                                if (foundCell) break;
                            }

                            if (foundCell) {
                                if (canvasKey === 'linearUnchunked') {
                                    // Hovering cell linearization view - highlight individual cell
                                    this.hoveredCell = foundCell;
                                    this.hoveredChunk = {
                                        x: Math.floor(foundCell.x / chunkX),
                                        y: Math.floor(foundCell.y / chunkY)
                                    };

                                    const intraChunkPos = this.getIntraChunkPosition(foundCell.x, foundCell.y, 0, params);
                                    const globalPos = this.getGlobalPosition(foundCell.x, foundCell.y, 0, params);
                                    this.tooltip.style.display = 'block';
                                    this.tooltip.style.left = `${e.clientX + 10}px`;
                                    this.tooltip.style.top = `${e.clientY - 30}px`;
                                    this.tooltip.textContent = `Cell (${foundCell.x}, ${foundCell.y}) → Intra-chunk: ${intraChunkPos}, Global: ${globalPos}`;
                                } else {
                                    // Hovering chunked linearization view - highlight chunk
                                    this.hoveredCell = null;
                                    this.hoveredChunk = {
                                        x: Math.floor(foundCell.x / chunkX),
                                        y: Math.floor(foundCell.y / chunkY)
                                    };

                                    const chunksX = Math.ceil(sizeX / chunkX);
                                    const chunkIdx = this.hoveredChunk.x + this.hoveredChunk.y * chunksX;
                                    const startX = this.hoveredChunk.x * chunkX;
                                    const startY = this.hoveredChunk.y * chunkY;
                                    const endX = Math.min(startX + chunkX - 1, sizeX - 1);
                                    const endY = Math.min(startY + chunkY - 1, sizeY - 1);
                                    const interChunkPos = this.getInterChunkPosition(startX, startY, 0, params);

                                    this.tooltip.style.display = 'block';
                                    this.tooltip.style.left = `${e.clientX + 10}px`;
                                    this.tooltip.style.top = `${e.clientY - 30}px`;
                                    this.tooltip.textContent = `Chunk ${chunkIdx}: cells (${startX},${startY}) to (${endX},${endY}), Linear pos: ${interChunkPos}`;
                                }
                            } else {
                                this.hoveredCell = null;
                                this.hoveredChunk = null;
                                this.tooltip.style.display = 'none';
                            }
                        } else {
                            this.hoveredCell = null;
                            this.hoveredChunk = null;
                            this.tooltip.style.display = 'none';
                        }
                    } else {
                        this.hoveredCell = null;
                        this.hoveredChunk = null;
                        this.tooltip.style.display = 'none';
                    }
                }

                this.update();
            }

            handleMouseLeave() {
                this.hoveredCell = null;
                this.hoveredChunk = null;
                this.tooltip.style.display = 'none';
                // Use requestAnimationFrame for smoother updates
                if (this.updatePending) return;
                this.updatePending = true;
                requestAnimationFrame(() => {
                    this.updatePending = false;
                    this.update();
                });
            }

            update() {
                const params = this.getParameters();

                // Clear caches if parameters changed significantly
                const paramsChanged = this.lastParams && (
                    this.lastParams.cellAlgorithm !== params.cellAlgorithm ||
                    this.lastParams.chunkAlgorithm !== params.chunkAlgorithm ||
                    JSON.stringify(this.lastParams.size) !== JSON.stringify(params.size) ||
                    JSON.stringify(this.lastParams.chunk) !== JSON.stringify(params.chunk)
                );

                if (paramsChanged) {
                    this.linearizationCache.clear();
                    this.positionCache.clear();
                    if (this.chunkPositionCache) this.chunkPositionCache.clear();
                    if (this.cellPositionCache) this.cellPositionCache.clear();
                    if (this.colorCache) this.colorCache.clear();
                }
                this.lastParams = { ...params };

                // Update Z range visibility
                document.getElementById('zRange').style.display =
                    params.size[2] > 0 ? 'flex' : 'none';

                // Calculate data
                const data = this.calculateData(params);
                this.currentData = data; // Store for mouse interactions

                // Draw all views
                this.drawSpatialUnchunked(params, data);
                this.drawSpatialChunked(params, data);
                this.drawLinearUnchunked(params, data);
                this.drawLinearChunked(params, data);

                // Update metrics
                this.updateMetrics(data);
            }

            calculateData(params) {
                const [sizeX, sizeY, sizeZ] = params.size;
                const totalCells = sizeX * sizeY * Math.max(1, sizeZ);

                // Calculate requested cells
                const requestedCells = new Set();
                const touchedChunks = new Set();

                for (let x = params.query.x[0]; x <= Math.min(params.query.x[1], sizeX - 1); x++) {
                    for (let y = params.query.y[0]; y <= Math.min(params.query.y[1], sizeY - 1); y++) {
                        if (sizeZ > 0) {
                            for (let z = params.query.z[0]; z <= Math.min(params.query.z[1], sizeZ - 1); z++) {
                                requestedCells.add(`${x},${y},${z}`);
                                touchedChunks.add(this.getChunkIndex(x, y, z, params));
                            }
                        } else {
                            requestedCells.add(`${x},${y},0`);
                            touchedChunks.add(this.getChunkIndex(x, y, 0, params));
                        }
                    }
                }

                // Calculate actual cells read (all cells in touched chunks)
                const actualCells = new Set();
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);

                touchedChunks.forEach(chunkIdx => {
                    const cz = Math.floor(chunkIdx / (chunksX * chunksY));
                    const cy = Math.floor((chunkIdx % (chunksX * chunksY)) / chunksX);
                    const cx = chunkIdx % chunksX;

                    for (let dx = 0; dx < chunkX; dx++) {
                        for (let dy = 0; dy < chunkY; dy++) {
                            for (let dz = 0; dz < (sizeZ > 0 ? chunkZ : 1); dz++) {
                                const x = cx * chunkX + dx;
                                const y = cy * chunkY + dy;
                                const z = cz * chunkZ + dz;

                                if (x < sizeX && y < sizeY && (sizeZ === 0 || z < sizeZ)) {
                                    actualCells.add(`${x},${y},${z}`);
                                }
                            }
                        }
                    }
                });

                // Calculate byte ranges for chunked reads
                const chunkedRanges = this.calculateByteRanges(
                    [...actualCells].map(key => {
                        const [x, y, z] = key.split(',').map(Number);
                        return this.getGlobalPosition(x, y, z, params);
                    })
                );

                // Calculate byte ranges for unchunked reads
                const unchunkedRanges = this.calculateByteRanges(
                    [...requestedCells].map(key => {
                        const [x, y, z] = key.split(',').map(Number);
                        return this.getGlobalPosition(x, y, z, params);
                    })
                );

                return {
                    requestedCells,
                    actualCells,
                    touchedChunks,
                    chunkedRanges,
                    unchunkedRanges,
                    totalCells
                };
            }

            calculateByteRanges(positions) {
                if (positions.length === 0) return [];

                const sorted = [...positions].sort((a, b) => a - b);
                const ranges = [];
                let start = sorted[0];
                let end = sorted[0];

                for (let i = 1; i < sorted.length; i++) {
                    if (sorted[i] === end + 1) {
                        end = sorted[i];
                    } else {
                        ranges.push([start, end]);
                        start = end = sorted[i];
                    }
                }
                ranges.push([start, end]);
                return ranges;
            }

            drawSpatialUnchunked(params, data) {
                const ctx = this.contexts.spatialUnchunked;
                const canvas = this.canvases.spatialUnchunked;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const [sizeX, sizeY, sizeZ] = params.size;
                const cellSize = Math.min(canvas.width / sizeX, canvas.height / sizeY) * 0.9;
                const offsetX = (canvas.width - sizeX * cellSize) / 2;
                const offsetY = (canvas.height - sizeY * cellSize) / 2;

                // Draw cells with gradient based on global linearization order
                // Skip rendering individual cells if they're too small to see
                if (cellSize > 2) {
                    for (let y = 0; y < sizeY; y++) {
                        for (let x = 0; x < sizeX; x++) {
                            const globalPos = this.getGlobalPosition(x, y, 0, params);
                            const color = this.getColorForLinearPosition(globalPos, data.totalCells - 1);

                            ctx.fillStyle = color;
                            ctx.fillRect(
                                offsetX + x * cellSize,
                                offsetY + y * cellSize,
                                cellSize - 1,
                                cellSize - 1
                            );
                        }
                    }
                } else {
                    // For very small cells, draw as a single gradient rectangle
                    const gradient = ctx.createLinearGradient(offsetX, offsetY, offsetX + sizeX * cellSize, offsetY + sizeY * cellSize);
                    gradient.addColorStop(0, '#00ff00');
                    gradient.addColorStop(1, '#ff0000');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(offsetX, offsetY, sizeX * cellSize, sizeY * cellSize);
                }

                // Handle cell highlighting for visible cells
                if (cellSize > 2 && this.hoveredCell) {
                    const x = this.hoveredCell.x;
                    const y = this.hoveredCell.y;
                    
                    // Highlight if hovered cell
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.fillRect(
                        offsetX + x * cellSize,
                        offsetY + y * cellSize,
                        cellSize - 1,
                        cellSize - 1
                    );
                    // Add outline for directly hovered cell
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(
                        offsetX + x * cellSize,
                        offsetY + y * cellSize,
                        cellSize - 1,
                        cellSize - 1
                    );
                }

                // Draw query region outline
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 3;
                const x1 = Math.max(0, params.query.x[0]);
                const y1 = Math.max(0, params.query.y[0]);
                const x2 = Math.min(sizeX - 1, params.query.x[1]);
                const y2 = Math.min(sizeY - 1, params.query.y[1]);

                ctx.strokeRect(
                    offsetX + x1 * cellSize,
                    offsetY + y1 * cellSize,
                    (x2 - x1 + 1) * cellSize - 1,
                    (y2 - y1 + 1) * cellSize - 1
                );

                // Highlight all cells in hovered chunk (when hovering chunk view)
                if (this.hoveredChunk && !this.hoveredCell) {
                    const [chunkSizeX, chunkSizeY] = params.chunk;

                    for (let y = 0; y < sizeY; y++) {
                        for (let x = 0; x < sizeX; x++) {
                            const cellChunkX = Math.floor(x / chunkSizeX);
                            const cellChunkY = Math.floor(y / chunkSizeY);

                            if (cellChunkX === this.hoveredChunk.x && cellChunkY === this.hoveredChunk.y) {
                                // Draw semi-transparent white overlay
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                                ctx.fillRect(
                                    offsetX + x * cellSize,
                                    offsetY + y * cellSize,
                                    cellSize - 1,
                                    cellSize - 1
                                );
                            }
                        }
                    }
                }
            }

            drawSpatialChunked(params, data) {
                const ctx = this.contexts.spatialChunked;
                const canvas = this.canvases.spatialChunked;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const [sizeX, sizeY, sizeZ] = params.size;
                const [chunkX, chunkY] = params.chunk;

                // Use same sizing calculation as logical array view
                const cellSize = Math.min(canvas.width / sizeX, canvas.height / sizeY) * 0.9;
                const offsetX = (canvas.width - sizeX * cellSize) / 2;
                const offsetY = (canvas.height - sizeY * cellSize) / 2;

                // Calculate chunk dimensions
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);

                // Cache chunk color mapping for performance (include Z dimension)
                const chunksZ = Math.ceil(Math.max(1, sizeZ) / Math.max(1, params.chunk[2]));
                const chunkMapKey = `${chunksX},${chunksY},${chunksZ},${params.chunkAlgorithm}`;
                let chunkColorMap = this.positionCache.get(chunkMapKey);

                if (!chunkColorMap) {
                    // First, create a mapping of chunk coordinates to their linearization order (including Z)
                    const chunkPositions = [];
                    for (let chunkCZ = 0; chunkCZ < chunksZ; chunkCZ++) {
                        for (let chunkCY = 0; chunkCY < chunksY; chunkCY++) {
                            for (let chunkCX = 0; chunkCX < chunksX; chunkCX++) {
                                const linearPos = this.linearizeCoordinate(chunkCX, chunkCY, chunkCZ, chunksX, chunksY, chunksZ, params.chunkAlgorithm);
                                chunkPositions.push({
                                    chunkCX,
                                    chunkCY,
                                    chunkCZ,
                                    linearPos
                                });
                            }
                        }
                    }

                    // Sort chunks by their linearization position
                    chunkPositions.sort((a, b) => a.linearPos - b.linearPos);

                    // Create a map from chunk coordinates to color index
                    chunkColorMap = new Map();
                    chunkPositions.forEach((chunk, index) => {
                        const key = `${chunk.chunkCX},${chunk.chunkCY},${chunk.chunkCZ}`;
                        chunkColorMap.set(key, index);
                    });

                    this.positionCache.set(chunkMapKey, chunkColorMap);
                }

                // Now draw each cell using its chunk's color
                for (let y = 0; y < sizeY; y++) {
                    for (let x = 0; x < sizeX; x++) {
                        const chunkCX = Math.floor(x / chunkX);
                        const chunkCY = Math.floor(y / chunkY);
                        const chunkCZ = 0; // For 2D spatial view, we show Z=0 slice
                        const chunkKey = `${chunkCX},${chunkCY},${chunkCZ}`;
                        const colorIndex = chunkColorMap.get(chunkKey);
                        const totalChunks = chunksX * chunksY * chunksZ;
                        const color = this.getColorForLinearPosition(colorIndex, totalChunks - 1);

                        ctx.fillStyle = color;
                        ctx.fillRect(
                            offsetX + x * cellSize,
                            offsetY + y * cellSize,
                            cellSize - 1,
                            cellSize - 1
                        );
                    }
                }

                // Highlight chunk when hovering over a cell in the logical array
                if (this.hoveredCell) {
                    const hoveredChunkCX = Math.floor(this.hoveredCell.x / chunkX);
                    const hoveredChunkCY = Math.floor(this.hoveredCell.y / chunkY);

                    const startX = hoveredChunkCX * chunkX;
                    const startY = hoveredChunkCY * chunkY;
                    const endX = Math.min(startX + chunkX, sizeX);
                    const endY = Math.min(startY + chunkY, sizeY);

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.fillRect(
                        offsetX + startX * cellSize,
                        offsetY + startY * cellSize,
                        (endX - startX) * cellSize - 1,
                        (endY - startY) * cellSize - 1
                    );
                }

                // Draw single outline around all touched chunks
                if (data.touchedChunks.size > 0) {
                    ctx.strokeStyle = '#4a9eff';
                    ctx.lineWidth = 3;

                    // Find bounding box of all touched chunks
                    let minChunkX = Infinity, minChunkY = Infinity;
                    let maxChunkX = -Infinity, maxChunkY = -Infinity;

                    data.touchedChunks.forEach(chunkIdx => {
                        const chunkCY = Math.floor(chunkIdx / chunksX);
                        const chunkCX = chunkIdx % chunksX;
                        minChunkX = Math.min(minChunkX, chunkCX);
                        minChunkY = Math.min(minChunkY, chunkCY);
                        maxChunkX = Math.max(maxChunkX, chunkCX);
                        maxChunkY = Math.max(maxChunkY, chunkCY);
                    });

                    // Draw single rectangle around all touched chunks
                    const startX = minChunkX * chunkX;
                    const startY = minChunkY * chunkY;
                    const endX = Math.min((maxChunkX + 1) * chunkX, sizeX);
                    const endY = Math.min((maxChunkY + 1) * chunkY, sizeY);

                    ctx.strokeRect(
                        offsetX + startX * cellSize,
                        offsetY + startY * cellSize,
                        (endX - startX) * cellSize - 1,
                        (endY - startY) * cellSize - 1
                    );
                }

                // Highlight all cells in hovered chunk
                if (this.hoveredChunk && !this.hoveredCell) {
                    const chunkCX = this.hoveredChunk.x;
                    const chunkCY = this.hoveredChunk.y;

                    const startX = chunkCX * chunkX;
                    const startY = chunkCY * chunkY;
                    const endX = Math.min(startX + chunkX, sizeX);
                    const endY = Math.min(startY + chunkY, sizeY);

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.fillRect(
                        offsetX + startX * cellSize,
                        offsetY + startY * cellSize,
                        (endX - startX) * cellSize - 1,
                        (endY - startY) * cellSize - 1
                    );
                    // Add outline for directly hovered chunk
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(
                        offsetX + startX * cellSize,
                        offsetY + startY * cellSize,
                        (endX - startX) * cellSize - 1,
                        (endY - startY) * cellSize - 1
                    );
                }
            }

            drawLinearUnchunked(params, data) {
                const ctx = this.contexts.linearUnchunked;
                const canvas = this.canvases.linearUnchunked;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const cellWidth = (canvas.width - 40) / data.totalCells;
                const barHeight = 60;
                const offsetX = 20;
                const offsetY = 20;

                // Draw all cells with gradient - use batching for performance
                if (cellWidth < 1) {
                    // For very small cells, draw as a single gradient
                    const gradient = ctx.createLinearGradient(offsetX, offsetY, offsetX + data.totalCells * cellWidth, offsetY);
                    gradient.addColorStop(0, '#00ff00');
                    gradient.addColorStop(1, '#ff0000');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(offsetX, offsetY, data.totalCells * cellWidth, barHeight);
                } else {
                    // Normal cell-by-cell rendering
                    for (let i = 0; i < data.totalCells; i++) {
                        const color = this.getColorForLinearPosition(i, data.totalCells);
                        ctx.fillStyle = color;
                        ctx.fillRect(offsetX + i * cellWidth, offsetY, cellWidth, barHeight);
                    }
                }

                // Highlight requested cells
                [...data.requestedCells].forEach(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    const pos = this.getGlobalPosition(x, y, z, params);
                    ctx.fillStyle = 'rgba(74, 158, 255, 0.5)';
                    ctx.fillRect(offsetX + pos * cellWidth, offsetY, cellWidth, barHeight);
                });

                // Highlight hovered cell
                if (this.hoveredCell) {
                    const pos = this.getGlobalPosition(
                        this.hoveredCell.x,
                        this.hoveredCell.y,
                        0,
                        params
                    );
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(offsetX + pos * cellWidth, offsetY, cellWidth, barHeight);
                }

                // Highlight hovered chunk range
                if (this.hoveredChunk) {
                    const chunkRange = this.getChunkGlobalRange(this.hoveredChunk.x, this.hoveredChunk.y, params);
                    if (chunkRange) {
                        // Background highlight for chunk range
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fillRect(
                            offsetX + chunkRange.min * cellWidth,
                            offsetY,
                            (chunkRange.max - chunkRange.min + 1) * cellWidth,
                            barHeight
                        );

                        // Single outline box around entire chunk range (when hovering chunk directly)
                        if (!this.hoveredCell) {
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(
                                offsetX + chunkRange.min * cellWidth,
                                offsetY,
                                (chunkRange.max - chunkRange.min + 1) * cellWidth,
                                barHeight
                            );
                        }
                    }
                }

                // Draw byte ranges
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 2;
                data.unchunkedRanges.forEach(([start, end]) => {
                    const x1 = offsetX + start * cellWidth;
                    const x2 = offsetX + (end + 1) * cellWidth;

                    ctx.beginPath();
                    ctx.moveTo(x1, offsetY + barHeight + 5);
                    ctx.lineTo(x2, offsetY + barHeight + 5);
                    ctx.stroke();

                    // Range markers
                    ctx.beginPath();
                    ctx.moveTo(x1, offsetY + barHeight);
                    ctx.lineTo(x1, offsetY + barHeight + 10);
                    ctx.moveTo(x2, offsetY + barHeight);
                    ctx.lineTo(x2, offsetY + barHeight + 10);
                    ctx.stroke();
                });

                // Labels
                ctx.fillStyle = '#aaa';
                ctx.font = '11px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${data.unchunkedRanges.length} byte range(s)`, canvas.width / 2, offsetY + barHeight + 25);
            }

            drawLinearChunked(params, data) {
                const ctx = this.contexts.linearChunked;
                const canvas = this.canvases.linearChunked;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const cellWidth = (canvas.width - 40) / data.totalCells;
                const barHeight = 60;
                const offsetX = 20;
                const offsetY = 20;

                // Draw all cells colored by their chunk
                const [sizeX, sizeY] = params.size;
                const [chunkSizeX, chunkSizeY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkSizeX);
                const chunksY = Math.ceil(sizeY / chunkSizeY);
                const totalChunks = chunksX * chunksY;

                // Cache position-to-cell mapping for performance
                const posMapKey = `${sizeX},${sizeY},${params.cellAlgorithm},${params.chunkAlgorithm},${chunkSizeX},${chunkSizeY}`;
                let positionToCell = this.positionCache.get(posMapKey);

                if (!positionToCell) {
                    positionToCell = new Map();
                    for (let y = 0; y < sizeY; y++) {
                        for (let x = 0; x < sizeX; x++) {
                            const globalPos = this.getGlobalPosition(x, y, 0, params);
                            positionToCell.set(globalPos, {x, y});
                        }
                    }
                    this.positionCache.set(posMapKey, positionToCell);
                }

                // Use the same chunk color mapping as the spatial view for consistency
                const chunksZ3D = Math.ceil(Math.max(1, sizeZ) / Math.max(1, params.chunk[2]));
                const chunkMapKey2 = `${chunksX},${chunksY},${chunksZ3D},${params.chunkAlgorithm}`;
                const spatialChunkColorMap = this.positionCache.get(chunkMapKey2);

                for (let i = 0; i < data.totalCells; i++) {
                    const cell = positionToCell.get(i);
                    if (cell && spatialChunkColorMap) {
                        // Use the same chunk color mapping as the spatial chunked view
                        const chunkCX = Math.floor(cell.x / chunkSizeX);
                        const chunkCY = Math.floor(cell.y / chunkSizeY);
                        const chunkCZ = Math.floor((cell.z || 0) / Math.max(1, params.chunk[2]));
                        const chunkKey = `${chunkCX},${chunkCY},${chunkCZ}`;
                        const colorIndex = spatialChunkColorMap.get(chunkKey);

                        if (colorIndex !== undefined) {
                            const totalChunks3D = chunksX * chunksY * chunksZ3D;
                            const color = this.getColorForLinearPosition(colorIndex, totalChunks3D - 1);
                            ctx.fillStyle = color;
                        } else {
                            // Fallback for invalid chunks
                            ctx.fillStyle = '#333';
                        }
                    } else {
                        // Fallback to gradient if position mapping fails
                        const color = this.getColorForLinearPosition(i, data.totalCells);
                        ctx.fillStyle = color;
                    }
                    // Remove gaps between cells by adding a small overlap
                    ctx.fillRect(offsetX + i * cellWidth, offsetY, cellWidth + 0.5, barHeight);
                }

                // Highlight actual cells read (amplification)
                [...data.actualCells].forEach(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    const pos = this.getGlobalPosition(x, y, z, params);

                    if (data.requestedCells.has(key)) {
                        ctx.fillStyle = 'rgba(74, 158, 255, 0.5)';
                    } else {
                        ctx.fillStyle = 'rgba(74, 158, 255, 0.5)';
                    }
                    ctx.fillRect(offsetX + pos * cellWidth, offsetY, cellWidth, barHeight);
                });

                // Highlight hovered chunk's cells and range
                if (this.hoveredChunk) {
                    const chunkRange = this.getChunkGlobalRange(this.hoveredChunk.x, this.hoveredChunk.y, params);
                    if (chunkRange) {
                        // Highlight chunk range with background
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fillRect(
                            offsetX + chunkRange.min * cellWidth,
                            offsetY,
                            (chunkRange.max - chunkRange.min + 1) * cellWidth,
                            barHeight
                        );

                        // Draw single outline box around entire chunk range (when hovering chunk directly)
                        if (!this.hoveredCell) {
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(
                                offsetX + chunkRange.min * cellWidth,
                                offsetY,
                                (chunkRange.max - chunkRange.min + 1) * cellWidth,
                                barHeight
                            );
                        }
                    }
                }

                // Draw byte ranges
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 2;
                data.chunkedRanges.forEach(([start, end]) => {
                    const x1 = offsetX + start * cellWidth;
                    const x2 = offsetX + (end + 1) * cellWidth;

                    ctx.beginPath();
                    ctx.moveTo(x1, offsetY + barHeight + 5);
                    ctx.lineTo(x2, offsetY + barHeight + 5);
                    ctx.stroke();

                    // Range markers
                    ctx.beginPath();
                    ctx.moveTo(x1, offsetY + barHeight);
                    ctx.lineTo(x1, offsetY + barHeight + 10);
                    ctx.moveTo(x2, offsetY + barHeight);
                    ctx.lineTo(x2, offsetY + barHeight + 10);
                    ctx.stroke();
                });

                // Labels
                ctx.fillStyle = '#aaa';
                ctx.font = '11px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${data.chunkedRanges.length} byte range(s) with chunking`, canvas.width / 2, offsetY + barHeight + 25);
            }

            updateMetrics(data) {
                const amplification = data.actualCells.size / Math.max(1, data.requestedCells.size);
                const coalescingFactor = data.touchedChunks.size / Math.max(1, data.chunkedRanges.length);

                document.getElementById('requested-cells').textContent = data.requestedCells.size;
                document.getElementById('actual-cells').textContent = data.actualCells.size;
                document.getElementById('amplification').innerHTML =
                    amplification.toFixed(2) + '<span class="metric-suffix">x</span>';
                document.getElementById('chunks-touched').textContent = data.touchedChunks.size;
                document.getElementById('byte-ranges').textContent = data.chunkedRanges.length;
                document.getElementById('efficiency').innerHTML =
                    (100 / amplification).toFixed(1) + '<span class="metric-suffix">%</span>';
                document.getElementById('coalescing-factor').innerHTML =
                    coalescingFactor.toFixed(1) + '<span class="metric-suffix">x</span>';
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            new DataVisualizer();
        });
    </script>
</body>
</html>
