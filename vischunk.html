<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multidimensional Data Linearization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            padding: 20px;
            color: #eee;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 2em;
            text-align: center;
        }

        .subtitle {
            color: #aaa;
            margin-bottom: 30px;
            text-align: center;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-section {
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .section-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 5px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 500;
            color: #bbb;
            margin-bottom: 5px;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="number"], select {
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transition: all 0.3s;
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #4a9eff;
            background: rgba(255, 255, 255, 0.15);
        }

        select option {
            background: #2a2a3e;
            color: #fff;
        }

        .query-controls {
            background: rgba(255, 200, 0, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 200, 0, 0.3);
        }

        .query-title {
            font-weight: 600;
            color: #ffc107;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        .range-inputs {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .range-group {
            display: flex;
            gap: 10px;
            align-items: center;
            color: #ddd;
        }

        .range-group input {
            width: 60px;
        }

        .spatial-views {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .viz-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .viz-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
        }

        canvas {
            display: block;
            width: 100%;
            cursor: crosshair;
        }

        .linear-views {
            margin-bottom: 30px;
        }

        .linear-viz {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
        }

        .metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .metric-label {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #fff;
        }

        .metric-suffix {
            font-size: 0.5em;
            color: rgba(255, 255, 255, 0.7);
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #aaa;
            font-size: 0.9em;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Multidimensional Data Linearization Visualizer</h1>
        <p class="subtitle">Explore how chunking and linearization strategies affect read patterns</p>

        <div class="controls">
            <div class="control-section">
                <div class="section-title">Array Settings</div>
                <div class="control-group">
                    <label>Array Size X</label>
                    <input type="number" id="sizeX" min="1" max="32" value="16">
                </div>

                <div class="control-group">
                    <label>Array Size Y</label>
                    <input type="number" id="sizeY" min="1" max="32" value="16">
                </div>

                <div class="control-group" id="arraySizeZGroup" style="display: none;">
                    <label>Array Size Z</label>
                    <input type="number" id="sizeZ" min="0" max="16" value="0">
                </div>

                <div class="control-group">
                    <label>Cell Linearization (within chunk)</label>
                    <select id="cellAlgorithm">
                        <option value="row-major">Row-Major</option>
                        <option value="col-major">Column-Major</option>
                        <option value="z-order">Z-Order (Morton)</option>
                        <option value="hilbert">Hilbert Curve</option>
                    </select>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Chunk Settings</div>
                <div class="control-group">
                    <label>Chunk Size X</label>
                    <input type="number" id="chunkX" min="1" max="32" value="4">
                </div>

                <div class="control-group">
                    <label>Chunk Size Y</label>
                    <input type="number" id="chunkY" min="1" max="32" value="4">
                </div>

                <div class="control-group" id="chunkZGroup">
                    <label>Chunk Size Z</label>
                    <input type="number" id="chunkZ" min="1" max="32" value="1">
                </div>

                <div class="control-group">
                    <label>Chunk Linearization</label>
                    <select id="chunkAlgorithm">
                        <option value="row-major">Row-Major</option>
                        <option value="col-major">Column-Major</option>
                        <option value="z-order">Z-Order (Morton)</option>
                        <option value="hilbert">Hilbert Curve</option>
                    </select>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Query Region</div>
                <div class="range-group">
                    <label>X:</label>
                    <input type="number" id="queryX1" min="0" value="3">
                    <span>to</span>
                    <input type="number" id="queryX2" min="0" value="10">
                </div>
                <div class="range-group">
                    <label>Y:</label>
                    <input type="number" id="queryY1" min="0" value="3">
                    <span>to</span>
                    <input type="number" id="queryY2" min="0" value="10">
                </div>
                <div class="range-group" id="zRange" style="display: none;">
                    <label>Z:</label>
                    <input type="number" id="queryZ1" min="0" value="0">
                    <span>to</span>
                    <input type="number" id="queryZ2" min="0" value="0">
                </div>
            </div>
        </div>

        <div class="spatial-views">
            <div class="viz-panel">
                <div class="viz-title">Logical Array (Cell Linearization within Chunks)</div>
                <div class="canvas-container">
                    <canvas id="spatial-unchunked"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #00ff00, #ff0000);"></div>
                        <span>Linearization Order</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="border: 3px solid #4a9eff; background: transparent;"></div>
                        <span>Query Region</span>
                    </div>
                </div>
            </div>

            <div class="viz-panel">
                <div class="viz-title">Chunked Array (Chunk Linearization)</div>
                <div class="canvas-container">
                    <canvas id="spatial-chunked"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #00ff00, #ff0000);"></div>
                        <span>Linearization Order</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="border: 3px solid #4a9eff; background: transparent;"></div>
                        <span>Chunks to Read</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="linear-views">
            <div class="linear-viz">
                <div class="viz-title">Linear Storage (Combined Linearization)</div>
                <div class="canvas-container">
                    <canvas id="linear-unchunked"></canvas>
                </div>
            </div>

            <div class="linear-viz">
                <div class="viz-title">Linear Storage (Chunk-Colored View)</div>
                <div class="canvas-container">
                    <canvas id="linear-chunked"></canvas>
                </div>
            </div>
        </div>

        <div class="metrics">
            <div class="metric">
                <div class="metric-label">Requested Cells</div>
                <div class="metric-value" id="requested-cells">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Actual Cells Read</div>
                <div class="metric-value" id="actual-cells">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Read Amplification</div>
                <div class="metric-value" id="amplification">1.0<span class="metric-suffix">x</span></div>
            </div>
            <div class="metric">
                <div class="metric-label">Chunks Touched</div>
                <div class="metric-value" id="chunks-touched">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Byte Ranges</div>
                <div class="metric-value" id="byte-ranges">0</div>
            </div>
            <div class="metric">
                <div class="metric-label">Efficiency</div>
                <div class="metric-value" id="efficiency">100<span class="metric-suffix">%</span></div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        class DataVisualizer {
            constructor() {
                this.hoveredCell = null;
                this.hoveredChunk = null;
                this.linearizationCache = new Map();
                this.initializeControls();
                this.initializeCanvases();
                this.update();
            }

            initializeControls() {
                const controls = ['cellAlgorithm', 'chunkAlgorithm', 'sizeX', 'sizeY', 'sizeZ',
                                 'chunkX', 'chunkY', 'chunkZ',
                                 'queryX1', 'queryX2', 'queryY1', 'queryY2',
                                 'queryZ1', 'queryZ2'];

                controls.forEach(id => {
                    const element = document.getElementById(id);
                    element.addEventListener('change', () => {
                        this.updateConstraints();
                        this.update();
                    });
                    element.addEventListener('input', () => {
                        this.updateConstraints();
                        this.update();
                    });
                });
                
                this.updateConstraints();
            }
            
            updateConstraints() {
                const sizeX = parseInt(document.getElementById('sizeX').value) || 1;
                const sizeY = parseInt(document.getElementById('sizeY').value) || 1;
                const sizeZ = parseInt(document.getElementById('sizeZ').value) || 0;
                
                // Show/hide Z-related controls based on whether we have a 3D array
                const chunkZGroup = document.getElementById('chunkZGroup');
                const zRange = document.getElementById('zRange');
                
                if (sizeZ > 0) {
                    chunkZGroup.style.display = 'flex';
                    zRange.style.display = 'flex';
                    
                    // Update chunk size constraints for 3D
                    document.getElementById('chunkX').max = sizeX;
                    document.getElementById('chunkY').max = sizeY;
                    document.getElementById('chunkZ').max = sizeZ;
                    
                    // Update query constraints for 3D
                    document.getElementById('queryZ1').max = sizeZ - 1;
                    document.getElementById('queryZ2').max = sizeZ - 1;
                    
                    // Clamp chunk Z if needed
                    if (parseInt(document.getElementById('chunkZ').value) > sizeZ) {
                        document.getElementById('chunkZ').value = sizeZ;
                    }
                } else {
                    chunkZGroup.style.display = 'none';
                    zRange.style.display = 'none';
                    
                    // Update chunk size constraints for 2D
                    document.getElementById('chunkX').max = sizeX;
                    document.getElementById('chunkY').max = sizeY;
                    // Don't set chunkZ constraints since it's hidden
                }
                
                // Update X,Y query constraints (always applies)
                document.getElementById('queryX1').max = sizeX - 1;
                document.getElementById('queryX2').max = sizeX - 1;
                document.getElementById('queryY1').max = sizeY - 1;
                document.getElementById('queryY2').max = sizeY - 1;
                
                // Clamp current values if they exceed new constraints
                if (parseInt(document.getElementById('chunkX').value) > sizeX) {
                    document.getElementById('chunkX').value = sizeX;
                }
                if (parseInt(document.getElementById('chunkY').value) > sizeY) {
                    document.getElementById('chunkY').value = sizeY;
                }
            }

            initializeCanvases() {
                this.canvases = {
                    spatialUnchunked: document.getElementById('spatial-unchunked'),
                    spatialChunked: document.getElementById('spatial-chunked'),
                    linearUnchunked: document.getElementById('linear-unchunked'),
                    linearChunked: document.getElementById('linear-chunked')
                };

                this.contexts = {};
                for (const [key, canvas] of Object.entries(this.canvases)) {
                    this.contexts[key] = canvas.getContext('2d');

                    // Add mouse interaction for spatial views
                    if (key.startsWith('spatial')) {
                        canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e, key));
                        canvas.addEventListener('mouseleave', () => this.handleMouseLeave());
                    }
                }

                this.tooltip = document.getElementById('tooltip');

                this.resizeCanvases();
                window.addEventListener('resize', () => this.resizeCanvases());
            }

            resizeCanvases() {
                // Spatial canvases - square aspect
                ['spatialUnchunked', 'spatialChunked'].forEach(key => {
                    const canvas = this.canvases[key];
                    const rect = canvas.getBoundingClientRect();
                    const size = Math.min(rect.width, 400);
                    canvas.width = size;
                    canvas.height = size;
                });

                // Linear canvases - full width
                ['linearUnchunked', 'linearChunked'].forEach(key => {
                    const canvas = this.canvases[key];
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = 120;
                });
            }

            getParameters() {
                return {
                    cellAlgorithm: document.getElementById('cellAlgorithm').value,
                    chunkAlgorithm: document.getElementById('chunkAlgorithm').value,
                    size: [
                        parseInt(document.getElementById('sizeX').value) || 1,
                        parseInt(document.getElementById('sizeY').value) || 1,
                        parseInt(document.getElementById('sizeZ').value) || 0
                    ],
                    chunk: [
                        parseInt(document.getElementById('chunkX').value) || 1,
                        parseInt(document.getElementById('chunkY').value) || 1,
                        parseInt(document.getElementById('chunkZ').value) || 1
                    ],
                    query: {
                        x: [parseInt(document.getElementById('queryX1').value) || 0,
                            parseInt(document.getElementById('queryX2').value) || 0],
                        y: [parseInt(document.getElementById('queryY1').value) || 0,
                            parseInt(document.getElementById('queryY2').value) || 0],
                        z: [parseInt(document.getElementById('queryZ1').value) || 0,
                            parseInt(document.getElementById('queryZ2').value) || 0]
                    }
                };
            }

            linearizeCoordinate(x, y, z, sizeX, sizeY, sizeZ, algorithm) {
                const key = `${x},${y},${z},${sizeX},${sizeY},${sizeZ},${algorithm}`;
                if (this.linearizationCache.has(key)) {
                    return this.linearizationCache.get(key);
                }

                let result;

                switch(algorithm) {
                    case 'row-major':
                        result = x + y * sizeX + z * sizeX * sizeY;
                        break;

                    case 'col-major':
                        result = y + x * sizeY + z * sizeX * sizeY;
                        break;

                    case 'z-order':
                        if (sizeZ > 0) {
                            result = this.mortonEncode3D(x, y, z);
                        } else {
                            result = this.mortonEncode2D(x, y);
                        }
                        break;

                    case 'hilbert':
                        if (sizeZ > 0) {
                            // For 3D, use simple layer-based approach
                            result = z * sizeX * sizeY + this.hilbertEncode2D(x, y, Math.max(sizeX, sizeY));
                        } else {
                            result = this.hilbertEncode2D(x, y, Math.max(sizeX, sizeY));
                        }
                        break;

                    default:
                        result = x + y * sizeX + z * sizeX * sizeY;
                }

                this.linearizationCache.set(key, result);
                return result;
            }

            // Get the linearization position of a cell within its chunk
            getIntraChunkPosition(x, y, z, params) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const localX = x % chunkX;
                const localY = y % chunkY;
                const localZ = z % chunkZ;
                const rawPos = this.linearizeCoordinate(localX, localY, localZ, chunkX, chunkY, chunkZ, params.cellAlgorithm);
                
                // For non-sequential cell algorithms, normalize to ensure contiguous chunk ranges
                if (params.cellAlgorithm === 'z-order' || params.cellAlgorithm === 'hilbert') {
                    const cacheKey = `cell-${params.cellAlgorithm}-${chunkX}-${chunkY}-${chunkZ}`;
                    if (!this.cellPositionCache) this.cellPositionCache = new Map();
                    
                    if (!this.cellPositionCache.has(cacheKey)) {
                        const allCellPositions = [];
                        for (let cz = 0; cz < Math.max(1, chunkZ); cz++) {
                            for (let cy = 0; cy < chunkY; cy++) {
                                for (let cx = 0; cx < chunkX; cx++) {
                                    const pos = this.linearizeCoordinate(cx, cy, cz, chunkX, chunkY, chunkZ, params.cellAlgorithm);
                                    allCellPositions.push(pos);
                                }
                            }
                        }
                        allCellPositions.sort((a, b) => a - b);
                        
                        const positionMap = new Map();
                        allCellPositions.forEach((pos, seqIndex) => {
                            positionMap.set(pos, seqIndex);
                        });
                        this.cellPositionCache.set(cacheKey, positionMap);
                    }
                    
                    return this.cellPositionCache.get(cacheKey).get(rawPos) || 0;
                }
                
                return rawPos;
            }

            // Get the linearization position of a chunk
            getInterChunkPosition(x, y, z, params) {
                const [sizeX, sizeY, sizeZ] = params.size;
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                const chunksZ = Math.ceil(sizeZ / chunkZ);
                const chunkCX = Math.floor(x / chunkX);
                const chunkCY = Math.floor(y / chunkY);
                const chunkCZ = Math.floor(z / chunkZ);
                return this.linearizeCoordinate(chunkCX, chunkCY, chunkCZ, chunksX, chunksY, chunksZ, params.chunkAlgorithm);
            }

            // Get the normalized chunk position (sequential order 0,1,2,3... regardless of algorithm)
            getNormalizedChunkPosition(x, y, z, params) {
                const rawChunkPos = this.getInterChunkPosition(x, y, z, params);
                
                if (params.chunkAlgorithm === 'z-order' || params.chunkAlgorithm === 'hilbert') {
                    // For non-sequential algorithms, normalize to get proper sequential positions
                    const [sizeX, sizeY] = params.size;
                    const [chunkX, chunkY] = params.chunk;
                    const chunksX = Math.ceil(sizeX / chunkX);
                    const chunksY = Math.ceil(sizeY / chunkY);
                    
                    // Create mapping once and cache it
                    const cacheKey = `${params.chunkAlgorithm}-${chunksX}-${chunksY}`;
                    if (!this.chunkPositionCache) this.chunkPositionCache = new Map();
                    
                    if (!this.chunkPositionCache.has(cacheKey)) {
                        const allChunkPositions = [];
                        for (let cy = 0; cy < chunksY; cy++) {
                            for (let cx = 0; cx < chunksX; cx++) {
                                const tempX = cx * chunkX;
                                const tempY = cy * chunkY;
                                const pos = this.getInterChunkPosition(tempX, tempY, 0, params);
                                allChunkPositions.push({pos, index: cy * chunksX + cx});
                            }
                        }
                        allChunkPositions.sort((a, b) => a.pos - b.pos);
                        
                        const positionMap = new Map();
                        allChunkPositions.forEach((item, seqIndex) => {
                            positionMap.set(item.pos, seqIndex);
                        });
                        this.chunkPositionCache.set(cacheKey, positionMap);
                    }
                    
                    return this.chunkPositionCache.get(cacheKey).get(rawChunkPos) || 0;
                }
                
                return rawChunkPos;
            }

            // Get the global linearization position combining both levels
            getGlobalPosition(x, y, z, params) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const cellsPerChunk = chunkX * chunkY * Math.max(1, chunkZ);
                const normalizedChunkPos = this.getNormalizedChunkPosition(x, y, z, params);
                const intraChunkPos = this.getIntraChunkPosition(x, y, z, params);
                return normalizedChunkPos * cellsPerChunk + intraChunkPos;
            }

            // Get the range of global positions for a chunk
            getChunkGlobalRange(chunkCX, chunkCY, params) {
                const [sizeX, sizeY] = params.size;
                const [chunkX, chunkY] = params.chunk;
                const cellsPerChunk = chunkX * chunkY;
                
                const positions = [];
                for (let dy = 0; dy < chunkY; dy++) {
                    for (let dx = 0; dx < chunkX; dx++) {
                        const x = chunkCX * chunkX + dx;
                        const y = chunkCY * chunkY + dy;
                        if (x < sizeX && y < sizeY) {
                            positions.push(this.getGlobalPosition(x, y, 0, params));
                        }
                    }
                }
                
                if (positions.length === 0) return null;
                return {
                    min: Math.min(...positions),
                    max: Math.max(...positions),
                    positions: positions
                };
            }

            mortonEncode2D(x, y) {
                let result = 0;
                for (let i = 0; i < 16; i++) {
                    result |= ((x & (1 << i)) << i) | ((y & (1 << i)) << (i + 1));
                }
                return result;
            }

            mortonEncode3D(x, y, z) {
                let result = 0;
                for (let i = 0; i < 10; i++) {
                    result |= ((x & (1 << i)) << (2 * i)) |
                              ((y & (1 << i)) << (2 * i + 1)) |
                              ((z & (1 << i)) << (2 * i + 2));
                }
                return result;
            }

            hilbertEncode2D(x, y, n) {
                let d = 0;
                for (let s = n / 2; s > 0; s /= 2) {
                    let rx = (x & s) > 0 ? 1 : 0;
                    let ry = (y & s) > 0 ? 1 : 0;
                    d += s * s * ((3 * rx) ^ ry);
                    [x, y] = this.hilbertRotate(s, x, y, rx, ry);
                }
                return d;
            }

            hilbertRotate(n, x, y, rx, ry) {
                if (ry === 0) {
                    if (rx === 1) {
                        x = n - 1 - x;
                        y = n - 1 - y;
                    }
                    [x, y] = [y, x];
                }
                return [x, y];
            }

            getChunkIndex(x, y, z, params) {
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const cx = Math.floor(x / chunkX);
                const cy = Math.floor(y / chunkY);
                const cz = Math.floor(z / chunkZ);
                const [sizeX, sizeY] = params.size;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);
                return cx + cy * chunksX + cz * chunksX * chunksY;
            }

            getColorForLinearPosition(position, maxPosition) {
                const hue = 120 - (position / maxPosition) * 120; // Green to red (120° to 0°)
                return `hsl(${hue}, 70%, 50%)`;
            }

            handleMouseMove(e, canvasKey) {
                const canvas = this.canvases[canvasKey];
                const rect = canvas.getBoundingClientRect();
                // Scale mouse coordinates to match canvas internal dimensions
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                const params = this.getParameters();
                const [sizeX, sizeY, sizeZ] = params.size;
                const [chunkX, chunkY] = params.chunk;

                if (canvasKey === 'spatialUnchunked') {
                    // Original cell-level interaction for unchunked view
                    const cellSize = Math.min(canvas.width / sizeX, canvas.height / sizeY) * 0.9;
                    const offsetX = (canvas.width - sizeX * cellSize) / 2;
                    const offsetY = (canvas.height - sizeY * cellSize) / 2;

                    const cellX = Math.floor((x - offsetX) / cellSize);
                    const cellY = Math.floor((y - offsetY) / cellSize);

                    if (cellX >= 0 && cellX < sizeX && cellY >= 0 && cellY < sizeY) {
                        this.hoveredCell = { x: cellX, y: cellY };
                        // Also set the corresponding chunk for cross-highlighting
                        this.hoveredChunk = {
                            x: Math.floor(cellX / chunkX),
                            y: Math.floor(cellY / chunkY)
                        };

                        // Show tooltip
                        const intraChunkPos = this.getIntraChunkPosition(cellX, cellY, 0, params);
                        const globalPos = this.getGlobalPosition(cellX, cellY, 0, params);
                        this.tooltip.style.display = 'block';
                        this.tooltip.style.left = `${e.clientX + 10}px`;
                        this.tooltip.style.top = `${e.clientY - 30}px`;
                        this.tooltip.textContent = `Cell (${cellX}, ${cellY}) → Intra-chunk: ${intraChunkPos}, Global: ${globalPos}`;
                    } else {
                        this.hoveredCell = null;
                        this.hoveredChunk = null;
                        this.tooltip.style.display = 'none';
                    }
                } else {
                    // Cell-level interaction for chunked view (but highlight whole chunks)
                    const cellSize = Math.min(canvas.width / sizeX, canvas.height / sizeY) * 0.9;
                    const offsetX = (canvas.width - sizeX * cellSize) / 2;
                    const offsetY = (canvas.height - sizeY * cellSize) / 2;

                    const cellX = Math.floor((x - offsetX) / cellSize);
                    const cellY = Math.floor((y - offsetY) / cellSize);

                    if (cellX >= 0 && cellX < sizeX && cellY >= 0 && cellY < sizeY) {
                        // Calculate which chunk this cell belongs to
                        const chunkCX = Math.floor(cellX / chunkX);
                        const chunkCY = Math.floor(cellY / chunkY);
                        
                        this.hoveredChunk = { x: chunkCX, y: chunkCY };
                        this.hoveredCell = null; // Clear individual cell when hovering chunk view

                        // Show tooltip
                        const chunksX = Math.ceil(sizeX / chunkX);
                        const chunkIdx = chunkCX + chunkCY * chunksX;
                        const startX = chunkCX * chunkX;
                        const startY = chunkCY * chunkY;
                        const endX = Math.min(startX + chunkX - 1, sizeX - 1);
                        const endY = Math.min(startY + chunkY - 1, sizeY - 1);
                        const interChunkPos = this.getInterChunkPosition(startX, startY, 0, params);

                        this.tooltip.style.display = 'block';
                        this.tooltip.style.left = `${e.clientX + 10}px`;
                        this.tooltip.style.top = `${e.clientY - 30}px`;
                        this.tooltip.textContent = `Chunk ${chunkIdx}: cells (${startX},${startY}) to (${endX},${endY}), Linear pos: ${interChunkPos}`;
                    } else {
                        this.hoveredChunk = null;
                        this.tooltip.style.display = 'none';
                    }
                }

                this.update();
            }

            handleMouseLeave() {
                this.hoveredCell = null;
                this.hoveredChunk = null;
                this.tooltip.style.display = 'none';
                this.update();
            }

            update() {
                const params = this.getParameters();

                // Clear linearization cache if parameters changed significantly
                if (this.lastParams && (
                    this.lastParams.cellAlgorithm !== params.cellAlgorithm ||
                    this.lastParams.chunkAlgorithm !== params.chunkAlgorithm ||
                    JSON.stringify(this.lastParams.size) !== JSON.stringify(params.size) ||
                    JSON.stringify(this.lastParams.chunk) !== JSON.stringify(params.chunk)
                )) {
                    this.linearizationCache.clear();
                    if (this.chunkPositionCache) this.chunkPositionCache.clear();
                    if (this.cellPositionCache) this.cellPositionCache.clear();
                }
                this.lastParams = { ...params };

                // Update Z range visibility
                document.getElementById('zRange').style.display =
                    params.size[2] > 0 ? 'flex' : 'none';

                // Calculate data
                const data = this.calculateData(params);

                // Draw all views
                this.drawSpatialUnchunked(params, data);
                this.drawSpatialChunked(params, data);
                this.drawLinearUnchunked(params, data);
                this.drawLinearChunked(params, data);

                // Update metrics
                this.updateMetrics(data);
            }

            calculateData(params) {
                const [sizeX, sizeY, sizeZ] = params.size;
                const totalCells = sizeX * sizeY * Math.max(1, sizeZ);

                // Calculate requested cells
                const requestedCells = new Set();
                const touchedChunks = new Set();

                for (let x = params.query.x[0]; x <= Math.min(params.query.x[1], sizeX - 1); x++) {
                    for (let y = params.query.y[0]; y <= Math.min(params.query.y[1], sizeY - 1); y++) {
                        if (sizeZ > 0) {
                            for (let z = params.query.z[0]; z <= Math.min(params.query.z[1], sizeZ - 1); z++) {
                                requestedCells.add(`${x},${y},${z}`);
                                touchedChunks.add(this.getChunkIndex(x, y, z, params));
                            }
                        } else {
                            requestedCells.add(`${x},${y},0`);
                            touchedChunks.add(this.getChunkIndex(x, y, 0, params));
                        }
                    }
                }

                // Calculate actual cells read (all cells in touched chunks)
                const actualCells = new Set();
                const [chunkX, chunkY, chunkZ] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);

                touchedChunks.forEach(chunkIdx => {
                    const cz = Math.floor(chunkIdx / (chunksX * chunksY));
                    const cy = Math.floor((chunkIdx % (chunksX * chunksY)) / chunksX);
                    const cx = chunkIdx % chunksX;

                    for (let dx = 0; dx < chunkX; dx++) {
                        for (let dy = 0; dy < chunkY; dy++) {
                            for (let dz = 0; dz < (sizeZ > 0 ? chunkZ : 1); dz++) {
                                const x = cx * chunkX + dx;
                                const y = cy * chunkY + dy;
                                const z = cz * chunkZ + dz;

                                if (x < sizeX && y < sizeY && (sizeZ === 0 || z < sizeZ)) {
                                    actualCells.add(`${x},${y},${z}`);
                                }
                            }
                        }
                    }
                });

                // Calculate byte ranges for chunked reads
                const chunkedRanges = this.calculateByteRanges(
                    [...actualCells].map(key => {
                        const [x, y, z] = key.split(',').map(Number);
                        return this.getGlobalPosition(x, y, z, params);
                    })
                );

                // Calculate byte ranges for unchunked reads
                const unchunkedRanges = this.calculateByteRanges(
                    [...requestedCells].map(key => {
                        const [x, y, z] = key.split(',').map(Number);
                        return this.getGlobalPosition(x, y, z, params);
                    })
                );

                return {
                    requestedCells,
                    actualCells,
                    touchedChunks,
                    chunkedRanges,
                    unchunkedRanges,
                    totalCells
                };
            }

            calculateByteRanges(positions) {
                if (positions.length === 0) return [];

                const sorted = [...positions].sort((a, b) => a - b);
                const ranges = [];
                let start = sorted[0];
                let end = sorted[0];

                for (let i = 1; i < sorted.length; i++) {
                    if (sorted[i] === end + 1) {
                        end = sorted[i];
                    } else {
                        ranges.push([start, end]);
                        start = end = sorted[i];
                    }
                }
                ranges.push([start, end]);
                return ranges;
            }

            drawSpatialUnchunked(params, data) {
                const ctx = this.contexts.spatialUnchunked;
                const canvas = this.canvases.spatialUnchunked;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const [sizeX, sizeY, sizeZ] = params.size;
                const cellSize = Math.min(canvas.width / sizeX, canvas.height / sizeY) * 0.9;
                const offsetX = (canvas.width - sizeX * cellSize) / 2;
                const offsetY = (canvas.height - sizeY * cellSize) / 2;

                // Draw cells with gradient based on global linearization order
                for (let y = 0; y < sizeY; y++) {
                    for (let x = 0; x < sizeX; x++) {
                        const globalPos = this.getGlobalPosition(x, y, 0, params);
                        const color = this.getColorForLinearPosition(globalPos, data.totalCells - 1);

                        ctx.fillStyle = color;
                        ctx.fillRect(
                            offsetX + x * cellSize,
                            offsetY + y * cellSize,
                            cellSize - 1,
                            cellSize - 1
                        );

                        // Highlight if hovered cell
                        if (this.hoveredCell && this.hoveredCell.x === x && this.hoveredCell.y === y) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                            ctx.fillRect(
                                offsetX + x * cellSize,
                                offsetY + y * cellSize,
                                cellSize - 1,
                                cellSize - 1
                            );
                            // Add outline for directly hovered cell
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(
                                offsetX + x * cellSize,
                                offsetY + y * cellSize,
                                cellSize - 1,
                                cellSize - 1
                            );
                        }
                        
                    }
                }

                // Draw query region outline
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 3;
                const x1 = Math.max(0, params.query.x[0]);
                const y1 = Math.max(0, params.query.y[0]);
                const x2 = Math.min(sizeX - 1, params.query.x[1]);
                const y2 = Math.min(sizeY - 1, params.query.y[1]);

                ctx.strokeRect(
                    offsetX + x1 * cellSize,
                    offsetY + y1 * cellSize,
                    (x2 - x1 + 1) * cellSize - 1,
                    (y2 - y1 + 1) * cellSize - 1
                );

                // Highlight all cells in hovered chunk (when hovering chunk view)
                if (this.hoveredChunk && !this.hoveredCell) {
                    const [chunkSizeX, chunkSizeY] = params.chunk;
                    
                    for (let y = 0; y < sizeY; y++) {
                        for (let x = 0; x < sizeX; x++) {
                            const cellChunkX = Math.floor(x / chunkSizeX);
                            const cellChunkY = Math.floor(y / chunkSizeY);
                            
                            if (cellChunkX === this.hoveredChunk.x && cellChunkY === this.hoveredChunk.y) {
                                // Draw semi-transparent white overlay
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                                ctx.fillRect(
                                    offsetX + x * cellSize,
                                    offsetY + y * cellSize,
                                    cellSize - 1,
                                    cellSize - 1
                                );
                            }
                        }
                    }
                }
            }

            drawSpatialChunked(params, data) {
                const ctx = this.contexts.spatialChunked;
                const canvas = this.canvases.spatialChunked;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const [sizeX, sizeY, sizeZ] = params.size;
                const [chunkX, chunkY] = params.chunk;
                
                // Use same sizing calculation as logical array view
                const cellSize = Math.min(canvas.width / sizeX, canvas.height / sizeY) * 0.9;
                const offsetX = (canvas.width - sizeX * cellSize) / 2;
                const offsetY = (canvas.height - sizeY * cellSize) / 2;
                
                // Calculate chunk dimensions
                const chunksX = Math.ceil(sizeX / chunkX);
                const chunksY = Math.ceil(sizeY / chunkY);

                // First, create a mapping of chunk coordinates to their linearization order
                const chunkPositions = [];
                for (let chunkCY = 0; chunkCY < chunksY; chunkCY++) {
                    for (let chunkCX = 0; chunkCX < chunksX; chunkCX++) {
                        const firstCellX = chunkCX * chunkX;
                        const firstCellY = chunkCY * chunkY;
                        const linearPos = this.linearizeCoordinate(chunkCX, chunkCY, 0, chunksX, chunksY, 1, params.chunkAlgorithm);
                        chunkPositions.push({
                            chunkCX,
                            chunkCY,
                            linearPos
                        });
                    }
                }
                
                // Sort chunks by their linearization position
                chunkPositions.sort((a, b) => a.linearPos - b.linearPos);
                
                // Create a map from chunk coordinates to color index
                const chunkColorMap = new Map();
                chunkPositions.forEach((chunk, index) => {
                    const key = `${chunk.chunkCX},${chunk.chunkCY}`;
                    chunkColorMap.set(key, index);
                });
                
                // Now draw each cell using its chunk's color
                for (let y = 0; y < sizeY; y++) {
                    for (let x = 0; x < sizeX; x++) {
                        const chunkCX = Math.floor(x / chunkX);
                        const chunkCY = Math.floor(y / chunkY);
                        const chunkKey = `${chunkCX},${chunkCY}`;
                        const colorIndex = chunkColorMap.get(chunkKey);
                        const totalChunks = chunksX * chunksY;
                        const color = this.getColorForLinearPosition(colorIndex, totalChunks - 1);
                        
                        ctx.fillStyle = color;
                        ctx.fillRect(
                            offsetX + x * cellSize,
                            offsetY + y * cellSize,
                            cellSize - 1,
                            cellSize - 1
                        );
                    }
                }

                // Highlight chunk when hovering over a cell in the logical array
                if (this.hoveredCell) {
                    const hoveredChunkCX = Math.floor(this.hoveredCell.x / chunkX);
                    const hoveredChunkCY = Math.floor(this.hoveredCell.y / chunkY);
                    
                    const startX = hoveredChunkCX * chunkX;
                    const startY = hoveredChunkCY * chunkY;
                    const endX = Math.min(startX + chunkX, sizeX);
                    const endY = Math.min(startY + chunkY, sizeY);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.fillRect(
                        offsetX + startX * cellSize,
                        offsetY + startY * cellSize,
                        (endX - startX) * cellSize - 1,
                        (endY - startY) * cellSize - 1
                    );
                }

                // Draw single outline around all touched chunks
                if (data.touchedChunks.size > 0) {
                    ctx.strokeStyle = '#4a9eff';
                    ctx.lineWidth = 3;
                    
                    // Find bounding box of all touched chunks
                    let minChunkX = Infinity, minChunkY = Infinity;
                    let maxChunkX = -Infinity, maxChunkY = -Infinity;
                    
                    data.touchedChunks.forEach(chunkIdx => {
                        const chunkCY = Math.floor(chunkIdx / chunksX);
                        const chunkCX = chunkIdx % chunksX;
                        minChunkX = Math.min(minChunkX, chunkCX);
                        minChunkY = Math.min(minChunkY, chunkCY);
                        maxChunkX = Math.max(maxChunkX, chunkCX);
                        maxChunkY = Math.max(maxChunkY, chunkCY);
                    });
                    
                    // Draw single rectangle around all touched chunks
                    const startX = minChunkX * chunkX;
                    const startY = minChunkY * chunkY;
                    const endX = Math.min((maxChunkX + 1) * chunkX, sizeX);
                    const endY = Math.min((maxChunkY + 1) * chunkY, sizeY);
                    
                    ctx.strokeRect(
                        offsetX + startX * cellSize,
                        offsetY + startY * cellSize,
                        (endX - startX) * cellSize - 1,
                        (endY - startY) * cellSize - 1
                    );
                }

                // Highlight all cells in hovered chunk
                if (this.hoveredChunk && !this.hoveredCell) {
                    const chunkCX = this.hoveredChunk.x;
                    const chunkCY = this.hoveredChunk.y;
                    
                    const startX = chunkCX * chunkX;
                    const startY = chunkCY * chunkY;
                    const endX = Math.min(startX + chunkX, sizeX);
                    const endY = Math.min(startY + chunkY, sizeY);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.fillRect(
                        offsetX + startX * cellSize,
                        offsetY + startY * cellSize,
                        (endX - startX) * cellSize - 1,
                        (endY - startY) * cellSize - 1
                    );
                    // Add outline for directly hovered chunk
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(
                        offsetX + startX * cellSize,
                        offsetY + startY * cellSize,
                        (endX - startX) * cellSize - 1,
                        (endY - startY) * cellSize - 1
                    );
                }
            }

            drawLinearUnchunked(params, data) {
                const ctx = this.contexts.linearUnchunked;
                const canvas = this.canvases.linearUnchunked;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const cellWidth = (canvas.width - 40) / data.totalCells;
                const barHeight = 60;
                const offsetX = 20;
                const offsetY = 20;

                // Draw all cells with gradient
                for (let i = 0; i < data.totalCells; i++) {
                    const color = this.getColorForLinearPosition(i, data.totalCells);
                    ctx.fillStyle = color;
                    ctx.fillRect(offsetX + i * cellWidth, offsetY, cellWidth, barHeight);
                }

                // Highlight requested cells
                [...data.requestedCells].forEach(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    const pos = this.getGlobalPosition(x, y, z, params);
                    ctx.fillStyle = 'rgba(74, 158, 255, 0.5)';
                    ctx.fillRect(offsetX + pos * cellWidth, offsetY, cellWidth, barHeight);
                });

                // Highlight hovered cell
                if (this.hoveredCell) {
                    const pos = this.getGlobalPosition(
                        this.hoveredCell.x,
                        this.hoveredCell.y,
                        0,
                        params
                    );
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(offsetX + pos * cellWidth, offsetY, cellWidth, barHeight);
                }

                // Highlight hovered chunk range
                if (this.hoveredChunk) {
                    const chunkRange = this.getChunkGlobalRange(this.hoveredChunk.x, this.hoveredChunk.y, params);
                    if (chunkRange) {
                        // Background highlight for chunk range
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fillRect(
                            offsetX + chunkRange.min * cellWidth, 
                            offsetY, 
                            (chunkRange.max - chunkRange.min + 1) * cellWidth, 
                            barHeight
                        );

                        // Single outline box around entire chunk range (when hovering chunk directly)
                        if (!this.hoveredCell) {
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(
                                offsetX + chunkRange.min * cellWidth, 
                                offsetY, 
                                (chunkRange.max - chunkRange.min + 1) * cellWidth, 
                                barHeight
                            );
                        }
                    }
                }

                // Draw byte ranges
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 2;
                data.unchunkedRanges.forEach(([start, end]) => {
                    const x1 = offsetX + start * cellWidth;
                    const x2 = offsetX + (end + 1) * cellWidth;

                    ctx.beginPath();
                    ctx.moveTo(x1, offsetY + barHeight + 5);
                    ctx.lineTo(x2, offsetY + barHeight + 5);
                    ctx.stroke();

                    // Range markers
                    ctx.beginPath();
                    ctx.moveTo(x1, offsetY + barHeight);
                    ctx.lineTo(x1, offsetY + barHeight + 10);
                    ctx.moveTo(x2, offsetY + barHeight);
                    ctx.lineTo(x2, offsetY + barHeight + 10);
                    ctx.stroke();
                });

                // Labels
                ctx.fillStyle = '#aaa';
                ctx.font = '11px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${data.unchunkedRanges.length} byte range(s)`, canvas.width / 2, offsetY + barHeight + 25);
            }

            drawLinearChunked(params, data) {
                const ctx = this.contexts.linearChunked;
                const canvas = this.canvases.linearChunked;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const cellWidth = (canvas.width - 40) / data.totalCells;
                const barHeight = 60;
                const offsetX = 20;
                const offsetY = 20;

                // Draw all cells colored by their chunk
                const [sizeX, sizeY] = params.size;
                const [chunkSizeX, chunkSizeY] = params.chunk;
                const chunksX = Math.ceil(sizeX / chunkSizeX);
                const chunksY = Math.ceil(sizeY / chunkSizeY);
                const totalChunks = chunksX * chunksY;
                
                // Create a map from global position to cell coordinates
                const positionToCell = new Map();
                for (let y = 0; y < sizeY; y++) {
                    for (let x = 0; x < sizeX; x++) {
                        const globalPos = this.getGlobalPosition(x, y, 0, params);
                        positionToCell.set(globalPos, {x, y});
                    }
                }
                
                for (let i = 0; i < data.totalCells; i++) {
                    const cell = positionToCell.get(i);
                    if (cell) {
                        // Color based on normalized chunk position
                        const normalizedPos = this.getNormalizedChunkPosition(cell.x, cell.y, 0, params);
                        const color = this.getColorForLinearPosition(normalizedPos, totalChunks - 1);
                        ctx.fillStyle = color;
                    } else {
                        // Fallback to gradient if position mapping fails
                        const color = this.getColorForLinearPosition(i, data.totalCells);
                        ctx.fillStyle = color;
                    }
                    // Remove gaps between cells by adding a small overlap
                    ctx.fillRect(offsetX + i * cellWidth, offsetY, cellWidth + 0.5, barHeight);
                }

                // Highlight actual cells read (amplification)
                [...data.actualCells].forEach(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    const pos = this.getGlobalPosition(x, y, z, params);

                    if (data.requestedCells.has(key)) {
                        ctx.fillStyle = 'rgba(74, 158, 255, 0.5)';
                    } else {
                        ctx.fillStyle = 'rgba(74, 158, 255, 0.5)';
                    }
                    ctx.fillRect(offsetX + pos * cellWidth, offsetY, cellWidth, barHeight);
                });

                // Highlight hovered chunk's cells and range
                if (this.hoveredChunk) {
                    const chunkRange = this.getChunkGlobalRange(this.hoveredChunk.x, this.hoveredChunk.y, params);
                    if (chunkRange) {
                        // Highlight chunk range with background
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fillRect(
                            offsetX + chunkRange.min * cellWidth, 
                            offsetY, 
                            (chunkRange.max - chunkRange.min + 1) * cellWidth, 
                            barHeight
                        );

                        // Draw single outline box around entire chunk range (when hovering chunk directly)
                        if (!this.hoveredCell) {
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(
                                offsetX + chunkRange.min * cellWidth, 
                                offsetY, 
                                (chunkRange.max - chunkRange.min + 1) * cellWidth, 
                                barHeight
                            );
                        }
                    }
                }

                // Draw byte ranges
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 2;
                data.chunkedRanges.forEach(([start, end]) => {
                    const x1 = offsetX + start * cellWidth;
                    const x2 = offsetX + (end + 1) * cellWidth;

                    ctx.beginPath();
                    ctx.moveTo(x1, offsetY + barHeight + 5);
                    ctx.lineTo(x2, offsetY + barHeight + 5);
                    ctx.stroke();

                    // Range markers
                    ctx.beginPath();
                    ctx.moveTo(x1, offsetY + barHeight);
                    ctx.lineTo(x1, offsetY + barHeight + 10);
                    ctx.moveTo(x2, offsetY + barHeight);
                    ctx.lineTo(x2, offsetY + barHeight + 10);
                    ctx.stroke();
                });

                // Labels
                ctx.fillStyle = '#aaa';
                ctx.font = '11px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${data.chunkedRanges.length} byte range(s) with chunking`, canvas.width / 2, offsetY + barHeight + 25);
            }

            updateMetrics(data) {
                const amplification = data.actualCells.size / Math.max(1, data.requestedCells.size);

                document.getElementById('requested-cells').textContent = data.requestedCells.size;
                document.getElementById('actual-cells').textContent = data.actualCells.size;
                document.getElementById('amplification').innerHTML =
                    amplification.toFixed(2) + '<span class="metric-suffix">x</span>';
                document.getElementById('chunks-touched').textContent = data.touchedChunks.size;
                document.getElementById('byte-ranges').textContent = data.chunkedRanges.length;
                document.getElementById('efficiency').innerHTML =
                    (100 / amplification).toFixed(1) + '<span class="metric-suffix">%</span>';
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            new DataVisualizer();
        });
    </script>
</body>
</html>
